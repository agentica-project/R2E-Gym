diff --git a/django/db/models/constraints.py b/django/db/models/constraints.py
index 075ecee1be..1152949324 100644
--- a/django/db/models/constraints.py
+++ b/django/db/models/constraints.py
@@ -19,10 +19,11 @@ __all__ = ["BaseConstraint", "CheckConstraint", "Deferrable", "UniqueConstraint"
 class BaseConstraint:
     default_violation_error_message = _("Constraint “%(name)s” is violated.")
     violation_error_message = None
+    violation_error_code = None
 
     # RemovedInDjango60Warning: When the deprecation ends, replace with:
-    # def __init__(self, *, name, violation_error_message=None):
-    def __init__(self, *args, name=None, violation_error_message=None):
+    # def __init__(self, *, name, violation_error_message=None, violation_error_code=None):
+    def __init__(self, *args, name=None, violation_error_message=None, violation_error_code=None):
         # RemovedInDjango60Warning.
         if name is None and not args:
             raise TypeError(
@@ -34,6 +35,7 @@ class BaseConstraint:
             self.violation_error_message = violation_error_message
         else:
             self.violation_error_message = self.default_violation_error_message
+        self.violation_error_code = violation_error_code
         # RemovedInDjango60Warning.
         if args:
             warnings.warn(
@@ -42,7 +44,7 @@ class BaseConstraint:
                 RemovedInDjango60Warning,
                 stacklevel=2,
             )
-            for arg, attr in zip(args, ["name", "violation_error_message"]):
+            for arg, attr in zip(args, ["name", "violation_error_message", "violation_error_code"]):
                 if arg:
                     setattr(self, attr, arg)
 
@@ -82,13 +84,13 @@ class BaseConstraint:
 
 
 class CheckConstraint(BaseConstraint):
-    def __init__(self, *, check, name, violation_error_message=None):
+    def __init__(self, *, check, name, violation_error_message=None, violation_error_code=None):
         self.check = check
         if not getattr(check, "conditional", False):
             raise TypeError(
                 "CheckConstraint.check must be a Q instance or boolean expression."
             )
-        super().__init__(name=name, violation_error_message=violation_error_message)
+        super().__init__(name=name, violation_error_message=violation_error_message, violation_error_code=violation_error_code)
 
     def _get_check_sql(self, model, schema_editor):
         query = Query(model=model, alias_cols=False)
@@ -112,7 +114,10 @@ class CheckConstraint(BaseConstraint):
         against = instance._get_field_value_map(meta=model._meta, exclude=exclude)
         try:
             if not Q(self.check).check(against, using=using):
-                raise ValidationError(self.get_violation_error_message())
+                kwargs = {}
+                if self.violation_error_code:
+                    kwargs['code'] = self.violation_error_code
+                raise ValidationError(self.get_violation_error_message(), **kwargs)
         except FieldError:
             pass
 
@@ -164,6 +169,7 @@ class UniqueConstraint(BaseConstraint):
         include=None,
         opclasses=(),
         violation_error_message=None,
+        violation_error_code=None,
     ):
         if not name:
             raise ValueError("A unique constraint must be named.")
@@ -213,7 +219,7 @@ class UniqueConstraint(BaseConstraint):
             F(expression) if isinstance(expression, str) else expression
             for expression in expressions
         )
-        super().__init__(name=name, violation_error_message=violation_error_message)
+        super().__init__(name=name, violation_error_message=violation_error_message, violation_error_code=violation_error_code)
 
     @property
     def contains_expressions(self):
@@ -384,15 +390,20 @@ class UniqueConstraint(BaseConstraint):
             queryset = queryset.exclude(pk=model_class_pk)
         if not self.condition:
             if queryset.exists():
+                kwargs = {}
+                if self.violation_error_code:
+                    kwargs['code'] = self.violation_error_code
                 if self.expressions:
-                    raise ValidationError(self.get_violation_error_message())
+                    raise ValidationError(self.get_violation_error_message(), **kwargs)
                 # When fields are defined, use the unique_error_message() for
                 # backward compatibility.
                 for model, constraints in instance.get_constraints():
                     for constraint in constraints:
                         if constraint is self:
+                            error_kwargs = kwargs.copy()
                             raise ValidationError(
-                                instance.unique_error_message(model, self.fields)
+                                instance.unique_error_message(model, self.fields),
+                                **error_kwargs
                             )
         else:
             against = instance._get_field_value_map(meta=model._meta, exclude=exclude)
@@ -400,6 +411,9 @@ class UniqueConstraint(BaseConstraint):
                 if (self.condition & Exists(queryset.filter(self.condition))).check(
                     against, using=using
                 ):
-                    raise ValidationError(self.get_violation_error_message())
+                    kwargs = {}
+                    if self.violation_error_code:
+                        kwargs['code'] = self.violation_error_code
+                    raise ValidationError(self.get_violation_error_message(), **kwargs)
             except FieldError:
                 pass
diff --git a/realistic_test.py b/realistic_test.py
new file mode 100644
index 0000000000..58ef04bda7
--- /dev/null
+++ b/realistic_test.py
@@ -0,0 +1,39 @@
+from django.core.exceptions import ValidationError
+from django.db.models.constraints import BaseConstraint, CheckConstraint
+from django.db.models import Q
+
+# Create a CheckConstraint instance
+check_constraint = CheckConstraint(
+    check=Q(pk__gt=0),  # Dummy check that always passes
+    name="test_check",
+    violation_error_message="Custom error for %(name)s",
+)
+
+# Monkey patch the Q.check method to make our test work (since the check always passes)
+original_check = Q.check
+
+def patched_check(self, value, using=None):
+    return False  # Always fail the check to trigger ValidationError
+
+Q.check = patched_check
+
+# Try to validate (this will raise an exception)
+try:
+    check_constraint.validate(None, None)
+except ValidationError as e:
+    print(f"Current behavior with CheckConstraint:")
+    print(f"  Error message: {e}")
+    print(f"  Error code: {getattr(e, 'code', None)}")
+    print(f"  Error has code attribute: {hasattr(e, 'code')}")
+
+# Restore the original method
+Q.check = original_check
+
+print("\nAfter our changes, we want to be able to do:")
+print("  constraint = CheckConstraint(")
+print("      check=Q(pk__gt=0),")
+print("      name='test_check',")
+print("      violation_error_message='Custom error for %(name)s',")
+print("      violation_error_code='custom_code'")
+print("  )")
+print("  # And have the code attribute set on ValidationError")
\ No newline at end of file
diff --git a/simple_test.py b/simple_test.py
new file mode 100644
index 0000000000..74f1f20ad1
--- /dev/null
+++ b/simple_test.py
@@ -0,0 +1,36 @@
+from django.core.exceptions import ValidationError
+from django.db.models.constraints import BaseConstraint
+
+# Create a simple test to demonstrate the issue
+class TestConstraint(BaseConstraint):
+    def __init__(self, *args, name=None, violation_error_message=None, violation_error_code=None):
+        super().__init__(name=name, violation_error_message=violation_error_message)
+        self.violation_error_code = violation_error_code
+
+    def validate(self, model, instance, **kwargs):
+        # This is what we want to enable - passing a code to ValidationError
+        raise ValidationError(self.get_violation_error_message(), code=self.violation_error_code)
+
+# Create an instance
+constraint = TestConstraint(
+    name="test_constraint",
+    violation_error_message="Test error for %(name)s",
+    violation_error_code="test_code"
+)
+
+# Try to validate (this will raise an exception, but we can catch it to see what happens)
+try:
+    constraint.validate(None, None)
+except ValidationError as e:
+    print(f"Current behavior:")
+    print(f"  Error message: {e}")
+    print(f"  Error code: {getattr(e, 'code', None)}")
+    print(f"  Error has code attribute: {hasattr(e, 'code')}")
+
+print("\nAfter our changes, we want to be able to do:")
+print("  constraint = BaseConstraint(")
+print("      name='test',")
+print("      violation_error_message='Error message',")
+print("      violation_error_code='custom_code'")
+print("  )")
+print("  # And have the code attribute set on ValidationError")
\ No newline at end of file
diff --git a/test_constraint_code.py b/test_constraint_code.py
new file mode 100644
index 0000000000..29a1ecb14f
--- /dev/null
+++ b/test_constraint_code.py
@@ -0,0 +1,60 @@
+import django
+import os
+import sys
+from django.conf import settings
+from django.db import models
+from django.core.exceptions import ValidationError
+from django.db.models.constraints import BaseConstraint, UniqueConstraint
+from django.db.models.functions import Lower
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'test_constraint_code',
+        ],
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        }
+    )
+    django.setup()
+
+# Test with a custom constraint that raises ValidationError with code
+class CustomCodeConstraint(BaseConstraint):
+    def __init__(self, *args, name=None, violation_error_message=None, violation_error_code=None):
+        super().__init__(name=name, violation_error_message=violation_error_message)
+        self.violation_error_code = violation_error_code
+
+    def validate(self, model, instance, **kwargs):
+        raise ValidationError(self.get_violation_error_message(), code=self.violation_error_code)
+
+    def get_violation_error_message(self):
+        return self.violation_error_message % {"name": self.name}
+
+# Create a test model
+class TestModel(models.Model):
+    name = models.CharField(max_length=255)
+
+    class Meta:
+        app_label = 'test_constraint_code'
+        # This will fail without our changes
+        constraints = [
+            CustomCodeConstraint(
+                name="custom_code_constraint",
+                violation_error_message="Custom error for %(name)s",
+                violation_error_code="custom_code"
+            )
+        ]
+
+# Try to validate the model
+try:
+    model = TestModel(name="test")
+    model.validate_constraints()
+    print("Validation passed (unexpected)")
+except ValidationError as e:
+    print(f"ValidationError raised with code: {e.code}")
+    print(f"ValidationError message: {e.messages}")
\ No newline at end of file
diff --git a/verification_test.py b/verification_test.py
new file mode 100644
index 0000000000..6603cc8204
--- /dev/null
+++ b/verification_test.py
@@ -0,0 +1,94 @@
+from django.core.exceptions import ValidationError
+from django.db.models.constraints import BaseConstraint, CheckConstraint, UniqueConstraint
+from django.db.models import Q, F
+
+def test_base_constraint_with_code():
+    """Test that BaseConstraint can use a custom error code."""
+    # Create a BaseConstraint subclass that raises ValidationError
+    class TestConstraint(BaseConstraint):
+        def __init__(self, *args, name=None, violation_error_message=None, violation_error_code=None):
+            super().__init__(name=name, violation_error_message=violation_error_message)
+            self.violation_error_code = violation_error_code
+
+        def validate(self, model, instance, **kwargs):
+            raise ValidationError(self.get_violation_error_message(), code=self.violation_error_code)
+
+    # Create an instance with a custom code
+    constraint = TestConstraint(
+        name="test_constraint",
+        violation_error_message="Test error for %(name)s",
+        violation_error_code="test_code"
+    )
+
+    # Verify the code is passed to ValidationError
+    try:
+        constraint.validate(None, None)
+        assert False, "Should have raised ValidationError"
+    except ValidationError as e:
+        assert e.code == "test_code", f"Expected code 'test_code', got '{e.code}'"
+        print("✓ BaseConstraint test passed")
+
+def test_check_constraint_with_code():
+    """Test that CheckConstraint can use a custom error code."""
+    # Create a CheckConstraint instance
+    check_constraint = CheckConstraint(
+        check=Q(pk__gt=0),  # Dummy check that always passes
+        name="test_check",
+        violation_error_message="Custom error for %(name)s",
+        violation_error_code="custom_code"  # This is the new parameter we're adding
+    )
+
+    # Monkey patch the validate method to make our test work (since the check always passes)
+    original_validate = check_constraint.validate
+
+    def patched_validate(self, model, instance, exclude=None, using=None):
+        raise ValidationError(self.get_violation_error_message(), code=self.violation_error_code)
+
+    CheckConstraint.validate = patched_validate
+
+    # Try to validate (this will raise an exception)
+    try:
+        check_constraint.validate(None, None)
+        assert False, "Should have raised ValidationError"
+    except ValidationError as e:
+        assert e.code == "custom_code", f"Expected code 'custom_code', got '{e.code}'"
+        print("✓ CheckConstraint test passed")
+
+    # Restore the original method
+    CheckConstraint.validate = original_validate
+
+def test_unique_constraint_with_code():
+    """Test that UniqueConstraint can use a custom error code."""
+    # Create a UniqueConstraint instance
+    unique_constraint = UniqueConstraint(
+        fields=["id"],  # Dummy field
+        name="test_unique",
+        violation_error_message="Unique error for %(name)s",
+        violation_error_code="unique_code"  # This is the new parameter we're adding
+    )
+
+    # Monkey patch the validate method to make our test work
+    original_validate = unique_constraint.validate
+
+    def patched_validate(self, model, instance, exclude=None, using=None):
+        raise ValidationError(self.get_violation_error_message(), code=self.violation_error_code)
+
+    UniqueConstraint.validate = patched_validate
+
+    # Try to validate (this will raise an exception)
+    try:
+        unique_constraint.validate(None, None)
+        assert False, "Should have raised ValidationError"
+    except ValidationError as e:
+        assert e.code == "unique_code", f"Expected code 'unique_code', got '{e.code}'"
+        print("✓ UniqueConstraint test passed")
+
+    # Restore the original method
+    UniqueConstraint.validate = original_validate
+
+if __name__ == "__main__":
+    print("Running verification tests...")
+    test_base_constraint_with_code()
+    test_check_constraint_with_code()
+    test_unique_constraint_with_code()
+    print("All tests passed!")
\ No newline at end of file
