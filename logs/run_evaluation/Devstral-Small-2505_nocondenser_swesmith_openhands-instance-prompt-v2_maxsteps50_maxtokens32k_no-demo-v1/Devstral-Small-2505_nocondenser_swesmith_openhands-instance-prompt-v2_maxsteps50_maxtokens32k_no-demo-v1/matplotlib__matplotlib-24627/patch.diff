diff --git a/comprehensive_test.py b/comprehensive_test.py
new file mode 100644
index 0000000000..48c7e5435d
--- /dev/null
+++ b/comprehensive_test.py
@@ -0,0 +1,51 @@
+import matplotlib.pyplot as plt
+import numpy as np
+
+def test_axes_figure_deparenting():
+    """Test that cla() and clf() properly deparent artists."""
+
+    # Test case 1: Multiple artists on the same axes
+    print("Test case 1: Multiple artists on the same axes")
+    f, a = plt.subplots()
+    l1, = a.plot([1, 2], label='Line 1')
+    l2, = a.plot([2, 3], label='Line 2')
+    a.legend()  # This creates additional artists
+    print(f"Before cla: l1.axes = {l1.axes}, l2.axes = {l2.axes}")
+    a.cla()
+    print(f"After cla: l1.axes = {l1.axes}, l2.axes = {l2.axes}")
+    print()
+
+    # Test case 2: Artists with different parent relationships
+    print("Test case 2: Artists with different parent relationships")
+    f, (a1, a2) = plt.subplots(1, 2)
+    l1, = a1.plot([1, 2])
+    l2, = a2.plot([2, 3])
+    print(f"Before clf: l1.axes = {l1.axes}, l2.axes = {l2.axes}")
+    plt.clf()
+    print(f"After clf: l1.axes = {l1.axes}, l2.axes = {l2.axes}")
+    print()
+
+    # Test case 3: Different types of artists
+    print("Test case 3: Different types of artists")
+    f, a = plt.subplots()
+    l, = a.plot([1, 2])
+    p, = a.plot([1, 2], 'o')  # Marker artist
+    c = a.contour(np.array([[1, 2], [2, 3]]))
+    print(f"Before cla: l.axes = {l.axes}, p.axes = {p.axes}, c.axes = {c.axes}")
+    a.cla()
+    print(f"After cla: l.axes = {l.axes}, p.axes = {p.axes}, c.axes = {c.axes}")
+    print()
+
+    # Test case 4: Nested clearing
+    print("Test case 4: Nested clearing")
+    f, a = plt.subplots()
+    l, = a.plot([1, 2])
+    print(f"Before first cla: l.axes = {l.axes}")
+    a.cla()
+    print(f"After first cla: l.axes = {l.axes}")
+    a.cla()  # Call cla() again
+    print(f"After second cla: l.axes = {l.axes}")
+    print()
+
+if __name__ == "__main__":
+    test_axes_figure_deparenting()
\ No newline at end of file
diff --git a/debug_contour.py b/debug_contour.py
new file mode 100644
index 0000000000..219d8723be
--- /dev/null
+++ b/debug_contour.py
@@ -0,0 +1,23 @@
+import matplotlib.pyplot as plt
+import numpy as np
+
+# Test case with contour
+f, a = plt.subplots()
+l, = a.plot([1, 2])
+c = a.contour(np.array([[1, 2], [2, 3]]))
+
+# Print the children of the axes
+print("Children of the axes before cla():")
+for child in a._children:
+    print(f"  {type(child).__name__}: {child}")
+
+# Clear the axes
+a.cla()
+
+# Print the children of the axes
+print("\nChildren of the axes after cla():")
+for child in a._children:
+    print(f"  {type(child).__name__}: {child}")
+
+# Check the axes attribute of the contour
+print(f"\nContour axes after cla(): {c.axes}")
\ No newline at end of file
diff --git a/debug_contour_type.py b/debug_contour_type.py
new file mode 100644
index 0000000000..61ec438e66
--- /dev/null
+++ b/debug_contour_type.py
@@ -0,0 +1,29 @@
+import matplotlib.pyplot as plt
+import numpy as np
+
+# Test case with contour
+f, a = plt.subplots()
+l, = a.plot([1, 2])
+c = a.contour(np.array([[1, 2], [2, 3]]))
+
+# Print the type of c
+print(f"Type of c: {type(c)}")
+print(f"Dir of c: {dir(c)}")
+
+# Check if c has an axes attribute
+print(f"c.axes: {c.axes}")
+
+# Check if c has a _children attribute
+print(f"c has _children: {hasattr(c, '_children')}")
+
+# If it has _children, print them
+if hasattr(c, '_children'):
+    print("Children of contour:")
+    for child in c._children:
+        print(f"  {type(child).__name__}: {child}")
+
+# Clear the axes
+a.cla()
+
+# Check the axes attribute of the contour after cla()
+print(f"\nContour axes after cla(): {c.axes}")
\ No newline at end of file
diff --git a/lib/matplotlib/axes/_base.py b/lib/matplotlib/axes/_base.py
index 90b0bf117e..4704bc83cc 100644
--- a/lib/matplotlib/axes/_base.py
+++ b/lib/matplotlib/axes/_base.py
@@ -1308,6 +1308,14 @@ class _AxesBase(martist.Artist):
         self._get_patches_for_fill = _process_plot_var_args(self, 'fill')
 
         self._gridOn = mpl.rcParams['axes.grid']
+
+        # Deparent all children before clearing the list
+        for child in self._children:
+            if hasattr(child, 'axes') and child.axes is self:
+                child.axes = None
+            if hasattr(child, 'figure') and child.figure is self.figure:
+                child.figure = None
+
         self._children = []
         self._mouseover_set = _OrderedSet()
         self.child_axes = []
@@ -1861,7 +1869,7 @@ class _AxesBase(martist.Artist):
 
         if aspect is not None:
             aspect = float(aspect)
-            # when box_aspect is set to other than ´None`,
+            # when box_aspect is set to other than Â´None`,
             # adjustable must be "datalim"
             for ax in axs:
                 ax.set_adjustable("datalim")
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..47a2696098
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,27 @@
+import matplotlib.pyplot as plt
+
+# Test case 1: Using remove() - should set .axes to None
+print("Test case 1: Using remove()")
+f, a = plt.subplots()
+l, = a.plot([1, 2])
+print(f"Before remove: l.axes = {l.axes}")
+l.remove()
+print(f"After remove: l.axes = {l.axes}")
+print()
+
+# Test case 2: Using cla() - currently doesn't set .axes to None (the issue)
+print("Test case 2: Using cla()")
+f, a = plt.subplots()
+l, = a.plot([1, 2])
+print(f"Before cla: l.axes = {l.axes}")
+a.cla()
+print(f"After cla: l.axes = {l.axes}")
+print()
+
+# Test case 3: Using clf() - should also be checked
+print("Test case 3: Using clf()")
+f, a = plt.subplots()
+l, = a.plot([1, 2])
+print(f"Before clf: l.axes = {l.axes}")
+plt.clf()
+print(f"After clf: l.axes = {l.axes}")
\ No newline at end of file
