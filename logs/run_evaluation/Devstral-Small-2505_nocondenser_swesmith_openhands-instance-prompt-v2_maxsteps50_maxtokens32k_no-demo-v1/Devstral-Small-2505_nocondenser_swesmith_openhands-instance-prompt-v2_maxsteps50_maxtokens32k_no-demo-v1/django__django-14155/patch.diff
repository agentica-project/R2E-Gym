diff --git a/django/urls/resolvers.py b/django/urls/resolvers.py
index 9b00e24509..c27afd835b 100644
--- a/django/urls/resolvers.py
+++ b/django/urls/resolvers.py
@@ -31,7 +31,25 @@ from .utils import get_callable
 
 class ResolverMatch:
     def __init__(self, func, args, kwargs, url_name=None, app_names=None, namespaces=None, route=None, tried=None):
-        self.func = func
+        # Unwrap functools.partial objects
+        import functools
+        if isinstance(func, functools.partial):
+            # Store the original partial function
+            self.func = func
+            # Create a new partial with the provided args and kwargs combined
+            # This allows us to see the full set of arguments that will be passed
+            # when the function is called
+            combined_args = func.args + args
+            combined_kwargs = dict(func.keywords)
+            combined_kwargs.update(kwargs)
+            # Create a new partial with the combined arguments
+            self.func = functools.partial(func.func, *combined_args, **combined_kwargs)
+            # For display purposes in __repr__, we'll use the original function
+            func_for_display = func.func
+        else:
+            self.func = func
+            func_for_display = func
+
         self.args = args
         self.kwargs = kwargs
         self.url_name = url_name
@@ -45,12 +63,12 @@ class ResolverMatch:
         self.namespaces = [x for x in namespaces if x] if namespaces else []
         self.namespace = ':'.join(self.namespaces)
 
-        if not hasattr(func, '__name__'):
+        if not hasattr(func_for_display, '__name__'):
             # A class-based view
-            self._func_path = func.__class__.__module__ + '.' + func.__class__.__name__
+            self._func_path = func_for_display.__class__.__module__ + '.' + func_for_display.__class__.__name__
         else:
             # A function-based view
-            self._func_path = func.__module__ + '.' + func.__name__
+            self._func_path = func_for_display.__module__ + '.' + func_for_display.__name__
 
         view_path = url_name or self._func_path
         self.view_name = ':'.join(self.namespaces + [view_path])
@@ -220,7 +238,7 @@ def _route_to_regex(route, is_endpoint=False):
         elif not set(match.group()).isdisjoint(string.whitespace):
             raise ImproperlyConfigured(
                 "URL route '%s' cannot contain whitespace in angle brackets "
-                "<…>." % original_route
+                "<â€¦>." % original_route
             )
         parts.append(re.escape(route[:match.start()]))
         route = route[match.end():]
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..8a69cd95e2
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,70 @@
+import functools
+from django.urls.resolvers import ResolverMatch
+
+def test_function(arg1, arg2):
+    """A test function to be used with partial."""
+    return f"Called with {arg1} and {arg2}"
+
+# Test 1: Basic partial function
+print("Test 1: Basic partial function")
+partial_func = functools.partial(test_function, arg1="partial_arg")
+match = ResolverMatch(
+    func=partial_func,
+    args=(),
+    kwargs={"arg2": "kwargs_arg"},
+    url_name="test-view",
+    app_names=["test_app"],
+    namespaces=["test_namespace"],
+    route="/test/"
+)
+print(repr(match))
+# Verify the function can be called with the correct arguments
+print(f"Function call result: {match.func()}")
+print()
+
+# Test 2: Partial with positional arguments
+print("Test 2: Partial with positional arguments")
+partial_func_pos = functools.partial(test_function, "pos_arg")
+match_pos = ResolverMatch(
+    func=partial_func_pos,
+    args=(),
+    kwargs={},  # No arg2 here to avoid conflict
+    url_name="test-view",
+    app_names=["test_app"],
+    namespaces=["test_namespace"],
+    route="/test/"
+)
+print(repr(match_pos))
+print(f"Function call result: {match_pos.func(arg2='called_arg2')}")
+print()
+
+# Test 3: Partial with both positional and keyword arguments
+print("Test 3: Partial with both positional and keyword arguments")
+partial_func_mixed = functools.partial(test_function, "pos_arg")
+match_mixed = ResolverMatch(
+    func=partial_func_mixed,
+    args=(),
+    kwargs={"arg2": "kw_arg"},  # Only provide arg2
+    url_name="test-view",
+    app_names=["test_app"],
+    namespaces=["test_namespace"],
+    route="/test/"
+)
+print(repr(match_mixed))
+print(f"Function call result: {match_mixed.func()}")
+print()
+
+# For comparison, create a regular function match
+print("Regular function match:")
+regular_match = ResolverMatch(
+    func=test_function,
+    args=(),
+    kwargs={"arg1": "regular_arg", "arg2": "kwargs_arg"},
+    url_name="test-view",
+    app_names=["test_app"],
+    namespaces=["test_namespace"],
+    route="/test/"
+)
+print(repr(regular_match))
+# The regular function can be called with the kwargs
+print(f"Function call result: {test_function(arg1='regular_arg', arg2='kwargs_arg')}")
\ No newline at end of file
