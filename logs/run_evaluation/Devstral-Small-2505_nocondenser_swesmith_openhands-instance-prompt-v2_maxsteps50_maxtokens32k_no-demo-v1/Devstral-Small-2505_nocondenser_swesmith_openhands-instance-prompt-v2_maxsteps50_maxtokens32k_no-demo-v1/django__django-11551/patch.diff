diff --git a/comprehensive_test.py b/comprehensive_test.py
new file mode 100644
index 0000000000..93459a2195
--- /dev/null
+++ b/comprehensive_test.py
@@ -0,0 +1,126 @@
+import os
+import sys
+import django
+from django.db import models
+from django.contrib import admin
+from django.core import checks
+from django.core.exceptions import FieldDoesNotExist
+from django.apps import apps
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        INSTALLED_APPS=[
+            'django.contrib.admin',
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+        ],
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        SECRET_KEY='fake-key',
+    )
+    django.setup()
+
+# Import the check class
+from django.contrib.admin.checks import ModelAdminChecks
+
+# Test case 1: PositionField that raises AttributeError when accessed on model class
+class PositionField(models.Field):
+    def __init__(self, *args, **kwargs):
+        super().__init__(*args, **kwargs)
+
+    def get(self, instance):
+        return instance._position
+
+    def __get__(self, instance, owner):
+        if instance is None:
+            raise AttributeError("Cannot access PositionField on model class")
+        return self.get(instance)
+
+    def contribute_to_class(self, cls, name):
+        super().contribute_to_class(cls, name)
+        setattr(cls, name, self)
+
+class Thing(models.Model):
+    number = models.IntegerField(default=0)
+    order = PositionField()
+
+    class Meta:
+        app_label = 'comprehensive_test'
+        managed = False
+
+class ThingAdmin(admin.ModelAdmin):
+    list_display = ['number', 'order']
+
+thing_admin = ThingAdmin(Thing, admin.site)
+checker = ModelAdminChecks()
+
+print("Test 1: PositionField that raises AttributeError")
+errors = checker._check_list_display_item(thing_admin, 'order', "list_display[1]")
+print("Errors for 'order' (PositionField):", errors)
+assert not errors, "Expected no errors for PositionField"
+
+errors = checker._check_list_display_item(thing_admin, 'number', "list_display[0]")
+print("Errors for 'number':", errors)
+assert not errors, "Expected no errors for regular field"
+
+errors = checker._check_list_display_item(thing_admin, 'non_existent', "list_display[2]")
+print("Errors for 'non_existent':", errors)
+assert len(errors) == 1 and errors[0].id == 'admin.E108', "Expected E108 error for non-existent field"
+
+print("Test 1 passed!")
+
+# Test case 2: ManyToManyField
+class RelatedModel(models.Model):
+    name = models.CharField(max_length=100)
+
+    class Meta:
+        app_label = 'comprehensive_test'
+        managed = False
+
+class ModelWithM2M(models.Model):
+    name = models.CharField(max_length=100)
+    related = models.ManyToManyField(RelatedModel)
+
+    class Meta:
+        app_label = 'comprehensive_test'
+        managed = False
+
+class ModelWithM2MAdmin(admin.ModelAdmin):
+    list_display = ['name', 'related']
+
+model_with_m2m_admin = ModelWithM2MAdmin(ModelWithM2M, admin.site)
+
+print("\nTest 2: ManyToManyField")
+errors = checker._check_list_display_item(model_with_m2m_admin, 'related', "list_display[1]")
+print("Errors for ManyToManyField:", errors)
+assert len(errors) == 1 and errors[0].id == 'admin.E109', "Expected E109 error for ManyToManyField"
+
+errors = checker._check_list_display_item(model_with_m2m_admin, 'name', "list_display[0]")
+print("Errors for 'name':", errors)
+assert not errors, "Expected no errors for regular field"
+
+print("Test 2 passed!")
+
+# Test case 3: Callable
+def get_callable_value():
+    return "callable value"
+
+class ModelWithCallable(admin.ModelAdmin):
+    list_display = ['name', get_callable_value]
+
+model_with_callable = ModelWithCallable(ModelWithM2M, admin.site)
+
+print("\nTest 3: Callable")
+errors = checker._check_list_display_item(model_with_callable, get_callable_value, "list_display[1]")
+print("Errors for callable:", errors)
+assert not errors, "Expected no errors for callable"
+
+print("Test 3 passed!")
+
+print("\nAll tests passed! The fix is working correctly.")
\ No newline at end of file
diff --git a/django/contrib/admin/checks.py b/django/contrib/admin/checks.py
index f82c20c2f1..9fd77b5d41 100644
--- a/django/contrib/admin/checks.py
+++ b/django/contrib/admin/checks.py
@@ -720,33 +720,33 @@ class ModelAdminChecks(BaseModelAdminChecks):
             return []
         elif hasattr(obj, item):
             return []
-        elif hasattr(obj.model, item):
+        else:
             try:
                 field = obj.model._meta.get_field(item)
             except FieldDoesNotExist:
-                return []
-            else:
-                if isinstance(field, models.ManyToManyField):
+                try:
+                    field = getattr(obj.model, item)
+                except AttributeError:
                     return [
                         checks.Error(
-                            "The value of '%s' must not be a ManyToManyField." % label,
+                            "The value of '%s' refers to '%s', which is not a callable, "
+                            "an attribute of '%s', or an attribute or method on '%s.%s'." % (
+                                label, item, obj.__class__.__name__,
+                                obj.model._meta.app_label, obj.model._meta.object_name,
+                            ),
                             obj=obj.__class__,
-                            id='admin.E109',
+                            id='admin.E108',
                         )
                     ]
-                return []
-        else:
-            return [
-                checks.Error(
-                    "The value of '%s' refers to '%s', which is not a callable, "
-                    "an attribute of '%s', or an attribute or method on '%s.%s'." % (
-                        label, item, obj.__class__.__name__,
-                        obj.model._meta.app_label, obj.model._meta.object_name,
-                    ),
-                    obj=obj.__class__,
-                    id='admin.E108',
-                )
-            ]
+            if isinstance(field, models.ManyToManyField):
+                return [
+                    checks.Error(
+                        "The value of '%s' must not be a ManyToManyField." % label,
+                        obj=obj.__class__,
+                        id='admin.E109',
+                    )
+                ]
+            return []
 
     def _check_list_display_links(self, obj):
         """ Check that list_display_links is a unique subset of list_display.
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..ad0f4f6104
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,86 @@
+import os
+import sys
+import django
+from django.db import models
+from django.contrib import admin
+from django.core import checks
+from django.core.exceptions import FieldDoesNotExist
+from django.apps import apps
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        INSTALLED_APPS=[
+            'django.contrib.admin',
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+        ],
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        SECRET_KEY='fake-key',
+    )
+    django.setup()
+
+# Mock PositionField that behaves like the one described in the issue
+class PositionField(models.Field):
+    def __init__(self, *args, **kwargs):
+        super().__init__(*args, **kwargs)
+
+    def get(self, instance):
+        # This would throw an exception if called on the model class
+        # rather than an instance
+        return instance._position
+
+    # This is the key part - when accessed on the model class, this will raise an exception
+    def __get__(self, instance, owner):
+        if instance is None:
+            # This simulates the behavior described in the issue - when accessed on the model class
+            # rather than an instance, it raises an exception
+            raise AttributeError("Cannot access PositionField on model class")
+        return self.get(instance)
+
+    # Make sure the field is properly registered in the model's _meta
+    def contribute_to_class(self, cls, name):
+        super().contribute_to_class(cls, name)
+        # Override the descriptor behavior for the model class
+        setattr(cls, name, self)
+
+# Create a simple model with a PositionField
+class Thing(models.Model):
+    number = models.IntegerField(default=0)
+    order = PositionField()
+
+    class Meta:
+        app_label = 'reproduce_issue'
+        # Prevent Django from trying to create this model in the database
+        managed = False
+
+# Create a ModelAdmin for the model
+class ThingAdmin(admin.ModelAdmin):
+    list_display = ['number', 'order']
+
+# Create an instance of the ModelAdmin
+thing_admin = ThingAdmin(Thing, admin.site)
+
+# Import the correct check class
+from django.contrib.admin.checks import ModelAdminChecks
+
+# Create a check instance
+checker = ModelAdminChecks()
+
+# Run the check on the ModelAdmin
+errors = checker._check_list_display_item(thing_admin, 'order', "list_display[1]")
+print("Errors found:", errors)
+
+# For comparison, run the check on a regular field
+errors = checker._check_list_display_item(thing_admin, 'number', "list_display[0]")
+print("Errors for 'number':", errors)
+
+# For comparison, run the check on a non-existent field
+errors = checker._check_list_display_item(thing_admin, 'non_existent', "list_display[2]")
+print("Errors for 'non_existent':", errors)
\ No newline at end of file
