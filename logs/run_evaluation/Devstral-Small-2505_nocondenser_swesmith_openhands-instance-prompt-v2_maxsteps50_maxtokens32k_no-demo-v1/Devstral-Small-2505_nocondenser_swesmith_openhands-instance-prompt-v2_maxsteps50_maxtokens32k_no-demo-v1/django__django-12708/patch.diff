diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py
index 61f88401ab..b38fbbc2dc 100644
--- a/django/db/backends/base/schema.py
+++ b/django/db/backends/base/schema.py
@@ -403,6 +403,28 @@ class BaseDatabaseSchemaEditor:
         meta_constraint_names = {constraint.name for constraint in model._meta.constraints}
         meta_index_names = {constraint.name for constraint in model._meta.indexes}
         columns = [model._meta.get_field(field).column for field in fields]
+
+        # When deleting an index, we need to be careful not to delete a unique constraint
+        # that happens to be on the same fields
+        if constraint_kwargs.get('index'):
+            # First try to find an index constraint (not a unique constraint)
+            constraint_names = []
+            with self.connection.cursor() as cursor:
+                constraints = self.connection.introspection.get_constraints(cursor, model._meta.db_table)
+                for name, infodict in constraints.items():
+                    if (infodict['columns'] == columns and
+                        infodict['index'] and
+                        not infodict['unique'] and
+                        name not in meta_constraint_names and
+                        name not in meta_index_names):
+                        constraint_names.append(name)
+
+            # If we found exactly one index constraint, use it
+            if len(constraint_names) == 1:
+                self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))
+                return
+
+        # Fall back to the original behavior for other cases
         constraint_names = self._constraint_names(
             model, columns, exclude=meta_constraint_names | meta_index_names,
             **constraint_kwargs
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..4d00345e4a
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,82 @@
+import os
+import sys
+import django
+from django.db import models, connection
+from django.db.migrations.executor import MigrationExecutor
+from django.db.migrations.recorder import MigrationRecorder
+from django.db.migrations.loader import MigrationLoader
+from django.conf import settings
+from django.apps import AppConfig
+
+# Configure settings
+settings.configure(
+    SECRET_KEY='fake-key',
+    INSTALLED_APPS=[
+        'django.contrib.contenttypes',
+        'test_app',
+    ],
+    DATABASES={
+        'default': {
+            'ENGINE': 'django.db.backends.sqlite3',
+            'NAME': ':memory:',
+        }
+    }
+)
+
+# Create a simple app config
+class TestAppConfig(AppConfig):
+    name = 'test_app'
+
+# Register the app
+django.apps.app_configs['test_app'] = TestAppConfig
+
+django.setup()
+
+# Create a test model with both unique_together and index_together
+class TestModel(models.Model):
+    field1 = models.CharField(max_length=255)
+    field2 = models.CharField(max_length=255)
+
+    class Meta:
+        app_label = 'test_app'
+        db_table = 'test_model'
+        unique_together = [['field1', 'field2']]
+        index_together = [['field1', 'field2']]
+
+# Create the model
+with connection.schema_editor() as schema_editor:
+    schema_editor.create_model(TestModel)
+
+# Verify that both constraints exist
+constraints = connection.introspection.get_constraints(
+    connection.cursor(),
+    TestModel._meta.db_table
+)
+
+print("Initial constraints:")
+for name, details in constraints.items():
+    if details['columns'] == ['field1', 'field2']:
+        print(f"  {name}: {details}")
+
+# Now try to remove the index_together
+with connection.schema_editor() as schema_editor:
+    try:
+        schema_editor.alter_index_together(
+            TestModel,
+            TestModel._meta.index_together,
+            []
+        )
+        print("\nSuccessfully removed index_together")
+    except Exception as e:
+        print(f"\nError removing index_together: {e}")
+
+# Verify the constraints after the operation
+constraints = connection.introspection.get_constraints(
+    connection.cursor(),
+    TestModel._meta.db_table
+)
+
+print("\nFinal constraints:")
+for name, details in constraints.items():
+    if details['columns'] == ['field1', 'field2']:
+        print(f"  {name}: {details}")
\ No newline at end of file
diff --git a/test_fix.py b/test_fix.py
new file mode 100644
index 0000000000..8b0bd66250
--- /dev/null
+++ b/test_fix.py
@@ -0,0 +1,110 @@
+import unittest
+from unittest import mock
+from django.db.backends.base.schema import BaseDatabaseSchemaEditor
+
+class TestDeleteComposedIndex(unittest.TestCase):
+    def test_delete_composed_index_with_both_unique_and_index(self):
+        """Test that _delete_composed_index can handle both unique and index constraints."""
+        # Create a mock schema editor
+        schema_editor = mock.MagicMock(spec=BaseDatabaseSchemaEditor)
+
+        # Create a mock model with meta
+        model = mock.MagicMock()
+        model._meta.db_table = 'test_table'
+
+        # Mock the fields and their columns
+        fields = ['field1', 'field2']
+        field1 = mock.MagicMock()
+        field1.column = 'field1_col'
+        field2 = mock.MagicMock()
+        field2.column = 'field2_col'
+
+        # Mock model._meta.get_field to return our mock fields
+        model._meta.get_field.side_effect = lambda field: {'field1': field1, 'field2': field2}[field]
+
+        # Mock the constraint names method to return one constraint for each type
+        schema_editor._constraint_names.return_value = ['test_idx']
+
+        # Mock the execute method
+        schema_editor.execute = mock.MagicMock()
+
+        # Call the method directly since it's private
+        BaseDatabaseSchemaEditor._delete_composed_index(
+            schema_editor,
+            model,
+            fields,
+            {'index': True},
+            schema_editor.sql_delete_index
+        )
+
+        # Check that _constraint_names was called with index=True and the correct columns
+        schema_editor._constraint_names.assert_called_with(
+            model,
+            ['field1_col', 'field2_col'],
+            exclude=mock.ANY,
+            index=True
+        )
+
+        # Check that execute was called with the delete index SQL
+        schema_editor.execute.assert_called_once()
+
+    def test_delete_composed_index_with_both_unique_and_index_fixed(self):
+        """Test that _delete_composed_index can handle both unique and index constraints with the fix."""
+        # Create a mock schema editor
+        schema_editor = mock.MagicMock(spec=BaseDatabaseSchemaEditor)
+
+        # Create a mock model with meta
+        model = mock.MagicMock()
+        model._meta.db_table = 'test_table'
+
+        # Mock the fields and their columns
+        fields = ['field1', 'field2']
+        field1 = mock.MagicMock()
+        field1.column = 'field1_col'
+        field2 = mock.MagicMock()
+        field2.column = 'field2_col'
+
+        # Mock model._meta.get_field to return our mock fields
+        model._meta.get_field.side_effect = lambda field: {'field1': field1, 'field2': field2}[field]
+
+        # Mock the introspection.get_constraints to return both a unique and an index constraint
+        mock_constraints = {
+            'test_idx': {
+                'columns': ['field1_col', 'field2_col'],
+                'index': True,
+                'unique': False,
+            },
+            'test_uniq': {
+                'columns': ['field1_col', 'field2_col'],
+                'index': True,
+                'unique': True,
+            },
+        }
+
+        def mock_get_constraints(cursor, table_name):
+            return mock_constraints
+
+        schema_editor.connection.introspection.get_constraints.side_effect = mock_get_constraints
+
+        # Mock the _constraint_names method to return multiple constraints (the problematic case)
+        schema_editor._constraint_names.return_value = ['test_idx', 'test_uniq']
+
+        # Mock the execute method
+        schema_editor.execute = mock.MagicMock()
+
+        # Call the method directly since it's private
+        BaseDatabaseSchemaEditor._delete_composed_index(
+            schema_editor,
+            model,
+            fields,
+            {'index': True},
+            schema_editor.sql_delete_index
+        )
+
+        # Check that execute was called with the index constraint, not the unique constraint
+        schema_editor.execute.assert_called_once()
+        args, _ = schema_editor.execute.call_args
+        self.assertIn('test_idx', args[0])
+
+if __name__ == '__main__':
+    unittest.main()
\ No newline at end of file
