diff --git a/comprehensive_test.py b/comprehensive_test.py
new file mode 100644
index 0000000000..284e5afb2e
--- /dev/null
+++ b/comprehensive_test.py
@@ -0,0 +1,41 @@
+from django.db.backends.ddl_references import Table, Columns, Statement
+
+# Simulate the _index_columns method before the fix
+def index_columns_before_fix(table, columns):
+    # This is what the code was doing before the fix
+    return Columns(table, columns, lambda x: x)
+
+# Simulate the _index_columns method after the fix
+def index_columns_after_fix(table, columns):
+    # This is our fix
+    table_name = getattr(table, 'table', table)
+    return Columns(table_name, columns, lambda x: x)
+
+# Create a Table object
+table_obj = Table("my_table", lambda x: x)
+
+# Test with the original (broken) implementation
+columns_before = index_columns_before_fix(table_obj, ["column1"])
+statement_before = Statement(
+    "UNIQUE (%(columns)s)",
+    table=table_obj,
+    columns=columns_before,
+)
+
+# Test with our fixed implementation
+columns_after = index_columns_after_fix(table_obj, ["column1"])
+statement_after = Statement(
+    "UNIQUE (%(columns)s)",
+    table=table_obj,
+    columns=columns_after,
+)
+
+# Check if references_column works correctly
+print("BEFORE FIX:")
+print("  columns.references_column('my_table', 'column1'):", columns_before.references_column("my_table", "column1"))
+print("  statement.references_column('my_table', 'column1'):", statement_before.references_column("my_table", "column1"))
+print("  Expected: Both should be False (due to the issue)")
+print("\nAFTER FIX:")
+print("  columns.references_column('my_table', 'column1'):", columns_after.references_column("my_table", "column1"))
+print("  statement.references_column('my_table', 'column1'):", statement_after.references_column("my_table", "column1"))
+print("  Expected: Both should be True")
\ No newline at end of file
diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py
index ad2f5a7da1..994d0aeb28 100644
--- a/django/db/backends/base/schema.py
+++ b/django/db/backends/base/schema.py
@@ -1066,7 +1066,10 @@ class BaseDatabaseSchemaEditor:
         )
 
     def _index_columns(self, table, columns, col_suffixes, opclasses):
-        return Columns(table, columns, self.quote_name, col_suffixes=col_suffixes)
+        # Extract the table name from the Table object to fix the issue where
+        # references_column always returns False
+        table_name = getattr(table, 'table', table)
+        return Columns(table_name, columns, self.quote_name, col_suffixes=col_suffixes)
 
     def _model_indexes_sql(self, model):
         """
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..e1826728fe
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,25 @@
+from django.db.backends.ddl_references import Table, Columns
+
+# Create a Table object
+table_obj = Table("my_table", lambda x: x)
+
+# Before fix: Create a Columns object with the Table object
+# This would return False for references_column
+columns_before = Columns(table_obj, ["column1"], lambda x: x)
+print("Before fix (using Table object):")
+print("references_column result:", columns_before.references_column("my_table", "column1"))
+print("Expected result: False (due to the issue)")
+
+# The correct way: pass the table name as a string
+correct_columns = Columns("my_table", ["column1"], lambda x: x)
+print("\nWith correct string table name:")
+print("references_column result:", correct_columns.references_column("my_table", "column1"))
+print("Expected result: True")
+
+# After fix: Simulate the fixed _index_columns method
+# Extract the table name from the Table object
+table_name = getattr(table_obj, 'table', table_obj)
+columns_after = Columns(table_name, ["column1"], lambda x: x)
+print("\nAfter fix (extracting table name):")
+print("references_column result:", columns_after.references_column("my_table", "column1"))
+print("Expected result: True")
\ No newline at end of file
