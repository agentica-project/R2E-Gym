diff --git a/src/_pytest/runner.py b/src/_pytest/runner.py
index e7211369c..cea41556f 100644
--- a/src/_pytest/runner.py
+++ b/src/_pytest/runner.py
@@ -102,7 +102,10 @@ def runtestprotocol(item, log=True, nextitem=None):
             show_test_item(item)
         if not item.config.getoption("setuponly", False):
             reports.append(call_and_report(item, "call", log))
-    reports.append(call_and_report(item, "teardown", log, nextitem=nextitem))
+    # Only call teardown if the test wasn't skipped
+    # This prevents tearDown from being executed on skipped tests when using --pdb
+    if not rep.skipped:
+        reports.append(call_and_report(item, "teardown", log, nextitem=nextitem))
     # after all teardown hooks have been called
     # want funcargs and request info to go away
     if hasrequest:
diff --git a/src/_pytest/unittest.py b/src/_pytest/unittest.py
index 773f545af..f0db05589 100644
--- a/src/_pytest/unittest.py
+++ b/src/_pytest/unittest.py
@@ -121,7 +121,15 @@ class TestCaseFunction(Function):
             self._request._fillfixtures()
 
     def teardown(self):
-        if self._explicit_tearDown is not None:
+        # Don't execute tearDown if the test is skipped
+        # This prevents tearDown from being executed on skipped tests when using --pdb
+        is_skipped = False
+        for marker in getattr(self._testcase, "__dict__", {}).get("__pytest_markers", []):
+            if marker.name == "skip":
+                is_skipped = True
+                break
+
+        if self._explicit_tearDown is not None and not is_skipped:
             self._explicit_tearDown()
             self._explicit_tearDown = None
         self._testcase = None
@@ -214,13 +222,21 @@ class TestCaseFunction(Function):
         if is_async_function(self.obj):
             self._testcase(self)
         else:
+            # Check if the test is skipped before postponing tearDown
+            # This prevents tearDown from being executed on skipped tests when using --pdb
+            is_skipped = False
+            for marker in getattr(self._testcase, "__dict__", {}).get("__pytest_markers", []):
+                if marker.name == "skip":
+                    is_skipped = True
+                    break
+
             # when --pdb is given, we want to postpone calling tearDown() otherwise
             # when entering the pdb prompt, tearDown() would have probably cleaned up
             # instance variables, which makes it difficult to debug
             # arguably we could always postpone tearDown(), but this changes the moment where the
             # TestCase instance interacts with the results object, so better to only do it
             # when absolutely needed
-            if self.config.getoption("usepdb"):
+            if self.config.getoption("usepdb") and not is_skipped:
                 self._explicit_tearDown = self._testcase.tearDown
                 setattr(self._testcase, "tearDown", lambda *args: None)
 
diff --git a/test_repro.py b/test_repro.py
new file mode 100644
index 000000000..510e86054
--- /dev/null
+++ b/test_repro.py
@@ -0,0 +1,15 @@
+import unittest
+
+class MyTestCase(unittest.TestCase):
+    def setUp(self):
+        print("Setting up")
+        xxx
+
+    @unittest.skip("hello")
+    def test_one(self):
+        print("Running test")
+        pass
+
+    def tearDown(self):
+        print("Tearing down")
+        xxx
\ No newline at end of file
