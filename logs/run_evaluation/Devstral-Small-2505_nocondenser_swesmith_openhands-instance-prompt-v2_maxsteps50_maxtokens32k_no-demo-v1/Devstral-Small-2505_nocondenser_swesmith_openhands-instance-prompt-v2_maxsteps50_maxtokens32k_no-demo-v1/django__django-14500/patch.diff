diff --git a/django/db/migrations/executor.py b/django/db/migrations/executor.py
index 57042a8690..106ca069ee 100644
--- a/django/db/migrations/executor.py
+++ b/django/db/migrations/executor.py
@@ -254,6 +254,8 @@ class MigrationExecutor:
         if migration.replaces:
             for app_label, name in migration.replaces:
                 self.recorder.record_unapplied(app_label, name)
+            # Don't mark the squash migration itself as unapplied
+            # The squash migration should remain applied even when the replaced migrations are unapplied
         else:
             self.recorder.record_unapplied(migration.app_label, migration.name)
         # Report progress
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..844a13008c
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,77 @@
+#!/usr/bin/env python
+import os
+import sys
+import django
+from django.db import connection
+from django.db.migrations.executor import MigrationExecutor
+from django.db.migrations.recorder import MigrationRecorder
+from django.conf import settings
+from django.db.migrations.migration import Migration
+
+# Configure Django settings
+settings.configure(
+    INSTALLED_APPS=[
+        'django.contrib.contenttypes',
+        'tests.migrations.migrations_test_apps',
+    ],
+    DATABASES={
+        'default': {
+            'ENGINE': 'django.db.backends.sqlite3',
+            'NAME': ':memory:',
+        }
+    },
+    MIGRATION_MODULES={
+        "migrations": "tests.migrations.test_migrations_squashed",
+    }
+)
+django.setup()
+
+# Create tables
+connection.cursor().execute("""
+CREATE TABLE IF NOT EXISTS django_migrations (
+    id INTEGER PRIMARY KEY,
+    app VARCHAR(255) NOT NULL,
+    name VARCHAR(255) NOT NULL,
+    applied TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
+)
+""")
+
+# Set up recorder and executor
+recorder = MigrationRecorder(connection)
+executor = MigrationExecutor(connection)
+
+# Mark BOTH the individual migrations AND the squashed migration as applied
+# This simulates the scenario where the squashed migration is applied,
+# but the original migrations still exist
+recorder.record_applied("migrations", "0001_initial")
+recorder.record_applied("migrations", "0002_second")
+recorder.record_applied("migrations", "0001_squashed_0002")
+
+# Check initial state
+print("Initial applied migrations:")
+for migration in recorder.applied_migrations():
+    print(f"  {migration[0]}.{migration[1]}")
+
+# Create a mock squashed migration
+class MockSquashedMigration(Migration):
+    def __init__(self):
+        super().__init__("0001_squashed_0002", "migrations")
+        self.replaces = [("migrations", "0001_initial"), ("migrations", "0002_second")]
+
+migration = MockSquashedMigration()
+
+# Unapply the migration
+print("\nUnapplying migration...")
+executor.unapply_migration(None, migration, fake=True)
+
+# Check final state
+print("\nFinal applied migrations:")
+for migration in recorder.applied_migrations():
+    print(f"  {migration[0]}.{migration[1]}")
+
+# The squashed migration SHOULD still be marked as applied
+# But according to the issue, it's incorrectly marked as unapplied
+if ("migrations", "0001_squashed_0002") in recorder.applied_migrations():
+    print("\nSUCCESS: Squashed migration is still marked as applied")
+else:
+    print("\nFAILURE: Squashed migration is incorrectly marked as unapplied")
\ No newline at end of file
