diff --git a/django/contrib/auth/forms.py b/django/contrib/auth/forms.py
index d73d1c8495..4c9a4f5556 100644
--- a/django/contrib/auth/forms.py
+++ b/django/contrib/auth/forms.py
@@ -141,6 +141,7 @@ class UserCreationForm(forms.ModelForm):
         user.set_password(self.cleaned_data["password1"])
         if commit:
             user.save()
+            self.save_m2m()
         return user
 
 
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..9593fe3a4e
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,129 @@
+import os
+import sys
+import django
+from django.db import models
+from django import forms
+from django.contrib.auth.forms import UserCreationForm
+from django.contrib.auth.models import AbstractBaseUser, BaseUserManager
+
+# Add the testbed directory to the Python path
+sys.path.insert(0, '/testbed')
+
+# Set up Django
+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'django.conf.global_settings')
+
+# Configure settings
+from django.conf import settings
+if not settings.configured:
+    settings.configure(
+        INSTALLED_APPS=[
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+        ],
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        AUTHENTICATION_BACKENDS=[
+            'django.contrib.auth.backends.ModelBackend',
+        ],
+    )
+    django.setup()
+
+# Define a simple model with a ManyToMany field
+class Tag(models.Model):
+    name = models.CharField(max_length=50)
+
+    def __str__(self):
+        return self.name
+
+class CustomUserManager(BaseUserManager):
+    def create_user(self, username, password=None):
+        user = self.model(username=username)
+        user.set_password(password)
+        user.save(using=self._db)
+        return user
+
+class CustomUser(AbstractBaseUser):
+    username = models.CharField(max_length=30, unique=True)
+    tags = models.ManyToManyField(Tag, blank=True)
+
+    objects = CustomUserManager()
+
+    USERNAME_FIELD = 'username'
+
+    def __str__(self):
+        return self.username
+
+# Create a custom UserCreationForm
+class CustomUserCreationForm(UserCreationForm):
+    class Meta:
+        model = CustomUser
+        fields = ('username', 'tags')
+
+# Test the form
+def test_user_creation_form():
+    # Create some tags
+    tag1 = Tag.objects.create(name='Tag 1')
+    tag2 = Tag.objects.create(name='Tag 2')
+
+    # Create a form with valid data
+    form_data = {
+        'username': 'testuser',
+        'password1': 'testpassword123',
+        'password2': 'testpassword123',
+        'tags': [tag1.id, tag2.id]
+    }
+    form = CustomUserCreationForm(data=form_data)
+
+    # Check if the form is valid
+    if not form.is_valid():
+        print("Form is not valid:")
+        print(form.errors)
+        return
+
+    # Save the user
+    user = form.save()
+
+    # Check if the ManyToMany field was saved
+    user_tags = list(user.tags.all())
+    expected_tags = [tag1, tag2]
+
+    if set(user_tags) == set(expected_tags):
+        print("SUCCESS: ManyToMany field was saved correctly")
+    else:
+        print("FAILURE: ManyToMany field was not saved correctly")
+        print(f"Expected tags: {[t.name for t in expected_tags]}")
+        print(f"Actual tags: {[t.name for t in user_tags]}")
+
+if __name__ == '__main__':
+    # Create the tables
+    from django.db import connection
+    cursor = connection.cursor()
+    cursor.execute('''
+        CREATE TABLE IF NOT EXISTS auth_tests_tag (
+            id INTEGER PRIMARY KEY AUTOINCREMENT,
+            name VARCHAR(50)
+        )
+    ''')
+    cursor.execute('''
+        CREATE TABLE IF NOT EXISTS auth_tests_customuser (
+            id INTEGER PRIMARY KEY AUTOINCREMENT,
+            username VARCHAR(30) UNIQUE,
+            password VARCHAR(128)
+        )
+    ''')
+    cursor.execute('''
+        CREATE TABLE IF NOT EXISTS auth_tests_customuser_tags (
+            customuser_id INTEGER,
+            tag_id INTEGER,
+            PRIMARY KEY (customuser_id, tag_id),
+            FOREIGN KEY (customuser_id) REFERENCES auth_tests_customuser(id),
+            FOREIGN KEY (tag_id) REFERENCES auth_tests_tag(id)
+        )
+    ''')
+
+    # Run the test
+    test_user_creation_form()
\ No newline at end of file
diff --git a/verify_fix.py b/verify_fix.py
new file mode 100644
index 0000000000..4e4e5a0ee2
--- /dev/null
+++ b/verify_fix.py
@@ -0,0 +1,40 @@
+import os
+import sys
+import unittest
+from unittest import mock
+
+# Add the testbed directory to the Python path
+sys.path.insert(0, '/testbed')
+
+# Import the UserCreationForm directly
+from django.contrib.auth.forms import UserCreationForm
+
+# Test the form
+class UserCreationFormTest(unittest.TestCase):
+    def test_save_m2m_called(self):
+        """Test that save_m2m is called when saving a user with ManyToMany fields."""
+        form = UserCreationForm({
+            'username': 'testuser',
+            'password1': 'testpassword123',
+            'password2': 'testpassword123',
+        })
+
+        # Mock the save_m2m method to verify it gets called
+        with mock.patch.object(form.__class__, 'save_m2m') as mock_save_m2m:
+            # Make the form valid without validating the actual model
+            form.is_valid = mock.MagicMock(return_value=True)
+            form.instance = mock.MagicMock()
+            form.cleaned_data = {
+                'username': 'testuser',
+                'password1': 'testpassword123',
+                'password2': 'testpassword123',
+            }
+
+            # Call save with commit=True
+            form.save(commit=True)
+
+            # Verify save_m2m was called
+            mock_save_m2m.assert_called_once()
+
+if __name__ == '__main__':
+    unittest.main()
\ No newline at end of file
