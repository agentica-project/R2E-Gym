diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 00000000..0a1633c8
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,68 @@
+import xarray as xr
+import numpy as np
+
+def test_rolling_center_issue():
+    # Create test data
+    my_data = xr.DataArray(np.arange(1, 10), dims="x")
+
+    # Option 1: take a center-justified rolling average
+    result1 = my_data.rolling(x=3, center=True).mean().values
+    print("Result 1 (using .mean()):", result1)
+
+    # Option 2: try to manually iterate, but the result is not centered
+    my_data_rolling = my_data.rolling(x=3, center=True)
+
+    # Debug: print the windows and their means
+    print("\nWindows and their means:")
+    for i, (label, window) in enumerate(my_data_rolling):
+        window_values = window.values
+        window_mean = window.mean().values.item()
+        # Count non-NaN values in the window
+        non_nan_count = np.count_nonzero(~np.isnan(window_values))
+        print(f"Window {i} (label={label}): values={window_values}, mean={window_mean}, non-NaN count={non_nan_count}")
+
+    result2 = [window.mean().values.item() for label, window in my_data_rolling]
+    print("\nResult 2 (manual iteration):", result2)
+
+    # Check if results are different
+    print("\nResults are equal:", np.array_equal(result1, result2))
+
+    # Print the actual differences
+    if not np.array_equal(result1, result2):
+        print("Differences:")
+        for i, (v1, v2) in enumerate(zip(result1, result2)):
+            if v1 != v2:
+                print(f"Index {i}: .mean()={v1}, manual={v2}")
+
+    # Let's also look at how the reduction operation works
+    print("\nHow the reduction operation works:")
+
+    # Create a rolling object with center=True
+    rolling_obj = my_data.rolling(x=3, center=True)
+
+    # Look at the internal implementation
+    print("\nInternal implementation details:")
+    print(f"Window size: {rolling_obj.window[0]}")
+    print(f"Center parameter: {rolling_obj.center[0]}")
+
+    # Let's see what happens in the reduction operation
+    print("\nSimulating the reduction operation:")
+    for i in range(len(my_data)):
+        # For centered windows, we need to adjust the indices
+        half_window = rolling_obj.window[0] // 2
+
+        # Calculate start and stop indices for a centered window
+        start = max(i - half_window, 0)
+        stop = min(i + half_window + 1, len(my_data))
+
+        # Get the window
+        window = my_data.isel(x=slice(start, stop))
+
+        # Count non-NaN values
+        non_nan_count = np.count_nonzero(~np.isnan(window.values))
+        mean_val = window.mean().item() if non_nan_count > 0 else float('nan')
+
+        print(f"Window centered at index {i}: start={start}, stop={stop}, values={window.values}, mean={mean_val}, non-NaN count={non_nan_count}")
+
+if __name__ == "__main__":
+    test_rolling_center_issue()
\ No newline at end of file
diff --git a/xarray/core/rolling.py b/xarray/core/rolling.py
index aef290f6..952204b7 100644
--- a/xarray/core/rolling.py
+++ b/xarray/core/rolling.py
@@ -270,9 +270,45 @@ class DataArrayRolling(Rolling["DataArray"]):
     def __iter__(self) -> Iterator[tuple[RollingKey, DataArray]]:
         if self.ndim > 1:
             raise ValueError("__iter__ is only supported for 1d-rolling")
-        stops = np.arange(1, len(self.window_labels) + 1)
-        starts = stops - int(self.window[0])
-        starts[: int(self.window[0])] = 0
+
+        # Get the length of the dimension we're rolling over
+        dim_len = len(self.obj[self.dim[0]])
+        window_size = self.window[0]
+
+        if self.center[0]:
+            # For centered windows, we need to adjust the start and stop indices
+            # to center the window on the current index
+
+            # Create arrays to store the start and stop indices
+            starts = np.zeros(dim_len, dtype=int)
+            stops = np.zeros(dim_len, dtype=int)
+
+            # For each position in the array, calculate the start and stop indices
+            for i in range(dim_len):
+                # Center the window on the current index
+                half_window = window_size // 2
+
+                # For odd window sizes, the window is perfectly centered
+                # For even window sizes, we need to decide whether to include
+                # more elements before or after the current index
+                if window_size % 2 == 0:
+                    # For even-sized windows, we'll include more elements before
+                    # the current index to match the behavior of the reduction operations
+                    start = max(i - half_window, 0)
+                    stop = min(i + half_window + 1, dim_len)
+                else:
+                    # For odd-sized windows, we can center perfectly
+                    start = max(i - half_window, 0)
+                    stop = min(i + half_window + 1, dim_len)
+
+                starts[i] = start
+                stops[i] = stop
+        else:
+            # For non-centered windows (left-justified)
+            stops = np.arange(1, dim_len + 1)
+            starts = stops - window_size
+            starts[:window_size] = 0
+
         for (label, start, stop) in zip(self.window_labels, starts, stops):
             window = self.obj.isel({self.dim[0]: slice(start, stop)})
 
