diff --git a/comprehensive_test.py b/comprehensive_test.py
new file mode 100644
index 0000000000..9ab5aa86d5
--- /dev/null
+++ b/comprehensive_test.py
@@ -0,0 +1,188 @@
+import os
+import sys
+import unittest
+from unittest.mock import MagicMock
+
+# Add the testbed directory to the Python path
+sys.path.insert(0, os.path.abspath(os.path.dirname(__file__)))
+
+# Import the MigrationWriter class
+from django.db.migrations.writer import MigrationWriter
+
+class ImportSortingTest(unittest.TestCase):
+    def setUp(self):
+        # Create a mock migration
+        self.mock_migration = MagicMock()
+        self.mock_migration.operations = []
+        self.mock_migration.dependencies = []
+        self.mock_migration.replaces = None
+        self.mock_migration.initial = False
+
+        # Create a MigrationWriter instance
+        self.writer = MigrationWriter(self.mock_migration)
+
+    def test_basic_import_sorting(self):
+        """Test basic import sorting with a mix of import and from statements."""
+        imports = set([
+            "import datetime",
+            "from django.db import migrations, models",
+            "import time",
+            "from django.conf import settings",
+            "import os",
+        ])
+
+        # Apply the new sorting logic
+        simple_imports = [imp for imp in imports if imp.startswith('import ')]
+        from_imports = [imp for imp in imports if imp.startswith('from ')]
+
+        # Sort each group by module name
+        simple_imports = sorted(simple_imports, key=lambda i: i.split()[1])
+        from_imports = sorted(from_imports, key=lambda i: i.split()[1])
+
+        # Concatenate the groups
+        sorted_imports = simple_imports + from_imports
+
+        # Check that all simple imports come before from imports
+        for i, line in enumerate(sorted_imports):
+            if line.startswith('from '):
+                # All lines before this should be simple imports
+                for j in range(i):
+                    self.assertTrue(sorted_imports[j].startswith('import '),
+                                    f"Expected import statement at position {j}, got '{sorted_imports[j]}'")
+
+        # Check the order of the imports
+        # First check that all simple imports come before from imports
+        for i, line in enumerate(sorted_imports):
+            if line.startswith('from '):
+                # All lines before this should be simple imports
+                for j in range(i):
+                    self.assertTrue(sorted_imports[j].startswith('import '),
+                                    f"Expected import statement at position {j}, got '{sorted_imports[j]}'")
+
+        # Now check the actual order
+        expected_order = [
+            "import datetime",
+            "import os",
+            "import time",
+            "from django.conf import settings",
+            "from django.db import migrations, models"
+        ]
+        self.assertEqual(sorted_imports, expected_order)
+
+    def test_empty_imports(self):
+        """Test with an empty set of imports."""
+        imports = set()
+
+        # Apply the new sorting logic
+        simple_imports = [imp for imp in imports if imp.startswith('import ')]
+        from_imports = [imp for imp in imports if imp.startswith('from ')]
+
+        # Sort each group by module name
+        simple_imports = sorted(simple_imports, key=lambda i: i.split()[1])
+        from_imports = sorted(from_imports, key=lambda i: i.split()[1])
+
+        # Concatenate the groups
+        sorted_imports = simple_imports + from_imports
+
+        # Should be empty
+        self.assertEqual(sorted_imports, [])
+
+    def test_only_simple_imports(self):
+        """Test with only simple imports."""
+        imports = set([
+            "import datetime",
+            "import time",
+            "import os",
+        ])
+
+        # Apply the new sorting logic
+        simple_imports = [imp for imp in imports if imp.startswith('import ')]
+        from_imports = [imp for imp in imports if imp.startswith('from ')]
+
+        # Sort each group by module name
+        simple_imports = sorted(simple_imports, key=lambda i: i.split()[1])
+        from_imports = sorted(from_imports, key=lambda i: i.split()[1])
+
+        # Concatenate the groups
+        sorted_imports = simple_imports + from_imports
+
+        # Check the order of the imports
+        expected_order = [
+            "import datetime",
+            "import os",
+            "import time",
+        ]
+        self.assertEqual(sorted_imports, expected_order)
+
+    def test_only_from_imports(self):
+        """Test with only from imports."""
+        imports = set([
+            "from django.db import migrations, models",
+            "from django.conf import settings",
+            "from django.core import validators",
+        ])
+
+        # Apply the new sorting logic
+        simple_imports = [imp for imp in imports if imp.startswith('import ')]
+        from_imports = [imp for imp in imports if imp.startswith('from ')]
+
+        # Sort each group by module name
+        simple_imports = sorted(simple_imports, key=lambda i: i.split()[1])
+        from_imports = sorted(from_imports, key=lambda i: i.split()[1])
+
+        # Concatenate the groups
+        sorted_imports = simple_imports + from_imports
+
+        # Check the order of the imports
+        expected_order = [
+            "from django.conf import settings",
+            "from django.core import validators",
+            "from django.db import migrations, models"
+        ]
+        self.assertEqual(sorted_imports, expected_order)
+
+    def test_complex_case(self):
+        """Test with a more complex set of imports."""
+        imports = set([
+            "import datetime",
+            "from django.db import models",
+            "import os",
+            "from django.conf import settings",
+            "import time",
+            "from django.db import migrations",
+            "from django.core import validators",
+        ])
+
+        # Apply the new sorting logic
+        simple_imports = [imp for imp in imports if imp.startswith('import ')]
+        from_imports = [imp for imp in imports if imp.startswith('from ')]
+
+        # Sort each group by module name
+        simple_imports = sorted(simple_imports, key=lambda i: i.split()[1])
+        from_imports = sorted(from_imports, key=lambda i: i.split()[1])
+
+        # Concatenate the groups
+        sorted_imports = simple_imports + from_imports
+
+        # Check that all simple imports come before from imports
+        for i, line in enumerate(sorted_imports):
+            if line.startswith('from '):
+                # All lines before this should be simple imports
+                for j in range(i):
+                    self.assertTrue(sorted_imports[j].startswith('import '),
+                                    f"Expected import statement at position {j}, got '{sorted_imports[j]}'")
+
+        # Check the order of the imports
+        expected_order = [
+            "import datetime",
+            "import os",
+            "import time",
+            "from django.conf import settings",
+            "from django.core import validators",
+            "from django.db import migrations",
+            "from django.db import models"
+        ]
+        self.assertEqual(sorted_imports, expected_order)
+
+if __name__ == '__main__':
+    unittest.main()
\ No newline at end of file
diff --git a/django/db/migrations/writer.py b/django/db/migrations/writer.py
index a59f0c8dcb..4980010ae0 100644
--- a/django/db/migrations/writer.py
+++ b/django/db/migrations/writer.py
@@ -173,9 +173,14 @@ class MigrationWriter:
         else:
             imports.add("from django.db import migrations")
 
-        # Sort imports by the package / module to be imported (the part after
-        # "from" in "from ... import ..." or after "import" in "import ...").
-        sorted_imports = sorted(imports, key=lambda i: i.split()[1])
+        # Sort imports according to Django coding style and isort defaults:
+        # 1. All 'import module' statements before any 'from module import object' statements
+        # 2. Within each section, imports are sorted by module name
+        simple_imports = sorted([imp for imp in imports if imp.startswith('import ')],
+                               key=lambda i: i.split()[1])
+        from_imports = sorted([imp for imp in imports if imp.startswith('from ')],
+                             key=lambda i: i.split()[1])
+        sorted_imports = simple_imports + from_imports
         items["imports"] = "\n".join(sorted_imports) + "\n" if imports else ""
         if migration_imports:
             items["imports"] += (
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..bad21c6ac0
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,73 @@
+import os
+import sys
+from unittest.mock import MagicMock
+
+# Add the testbed directory to the Python path
+sys.path.insert(0, os.path.abspath(os.path.dirname(__file__)))
+
+# Import the MigrationWriter class
+from django.db.migrations.writer import MigrationWriter
+
+# Create a mock migration
+mock_migration = MagicMock()
+mock_migration.operations = []
+mock_migration.dependencies = []
+mock_migration.replaces = None
+mock_migration.initial = False
+
+# Create a MigrationWriter instance
+writer = MigrationWriter(mock_migration)
+
+# Test the import sorting logic directly
+def test_import_sorting():
+    # Create a set of imports that would be generated by a migration
+    imports = set([
+        "import datetime",
+        "from django.db import migrations, models",
+        "import time",
+        "from django.conf import settings",
+        "import os",
+    ])
+
+    # Current sorting logic (by module name)
+    sorted_imports_current = sorted(imports, key=lambda i: i.split()[1])
+    print("Old import ordering (sorted by module name):")
+    for imp in sorted_imports_current:
+        print(imp)
+
+    # Check if there are any 'from' imports before 'import' statements with old logic
+    for_imports_first_old = False
+    for i, line in enumerate(sorted_imports_current):
+        if line.startswith('from ') and any(sorted_imports_current[j].startswith('import ') for j in range(i+1, len(sorted_imports_current))):
+            for_imports_first_old = True
+            print("\nIssue found with old sorting: 'from module import object' statements appear before 'import module' statements")
+            print(f"Example: '{line}' appears before a simple import")
+            break
+
+    # New sorting logic (imports before from imports, both sorted by module name)
+    simple_imports = sorted([imp for imp in imports if imp.startswith('import ')],
+                           key=lambda i: i.split()[1])
+    from_imports = sorted([imp for imp in imports if imp.startswith('from ')],
+                         key=lambda i: i.split()[1])
+    sorted_imports_new = simple_imports + from_imports
+
+    print("\nNew import ordering (imports before from imports, both sorted by module name):")
+    for imp in sorted_imports_new:
+        print(imp)
+
+    # Check if there are any 'from' imports before 'import' statements with new logic
+    for_imports_first_new = False
+    for i, line in enumerate(sorted_imports_new):
+        if line.startswith('from ') and any(sorted_imports_new[j].startswith('import ') for j in range(i+1, len(sorted_imports_new))):
+            for_imports_first_new = True
+            print("\nIssue found with new sorting: 'from module import object' statements appear before 'import module' statements")
+            print(f"Example: '{line}' appears before a simple import")
+            break
+
+    if not for_imports_first_new:
+        print("\nSuccess! New sorting correctly places all 'import module' statements before 'from module import object' statements")
+
+    
+
+# Run the test
+test_import_sorting()
\ No newline at end of file
diff --git a/simple_test.py b/simple_test.py
new file mode 100644
index 0000000000..c340e0fd0f
--- /dev/null
+++ b/simple_test.py
@@ -0,0 +1,55 @@
+import os
+import sys
+import unittest
+
+# Add the testbed directory to the Python path
+sys.path.insert(0, os.path.abspath(os.path.dirname(__file__)))
+
+# Import the MigrationWriter class
+from django.db.migrations.writer import MigrationWriter
+
+class ImportSortingTest(unittest.TestCase):
+    def test_import_sorting(self):
+        """Test that imports are sorted correctly."""
+        # Create a set of imports
+        imports = set([
+            "import datetime",
+            "from django.db import migrations, models",
+            "import time",
+            "from django.conf import settings",
+            "import os",
+        ])
+
+        # Apply the new sorting logic
+        simple_imports = [imp for imp in imports if imp.startswith('import ')]
+        from_imports = [imp for imp in imports if imp.startswith('from ')]
+
+        # Sort each group by module name
+        simple_imports = sorted(simple_imports, key=lambda i: i.split()[1])
+        from_imports = sorted(from_imports, key=lambda i: i.split()[1])
+
+        # Concatenate the groups
+        sorted_imports = simple_imports + from_imports
+
+        # Print the sorted imports for debugging
+        print("Sorted imports:")
+        for imp in sorted_imports:
+            print(f"  {imp}")
+
+        # Check that all simple imports come before from imports
+        # First, check that all imports are properly sorted within their groups
+        self.assertEqual(simple_imports, ["import datetime", "import os", "import time"])
+        self.assertEqual(from_imports, ["from django.conf import settings", "from django.db import migrations, models"])
+
+        # Then check the final sorted order
+        expected_order = [
+            "import datetime",
+            "import os",
+            "import time",
+            "from django.conf import settings",
+            "from django.db import migrations, models"
+        ]
+        self.assertEqual(sorted_imports, expected_order)
+
+if __name__ == '__main__':
+    unittest.main()
\ No newline at end of file
