diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py
index 850734709d..f02199d97c 100644
--- a/django/db/models/sql/compiler.py
+++ b/django/db/models/sql/compiler.py
@@ -125,11 +125,12 @@ class SQLCompiler:
             cols = expr.get_group_by_cols()
             for col in cols:
                 expressions.append(col)
-        for expr, (sql, params, is_ref) in order_by:
-            # Skip References to the select clause, as all expressions in the
-            # select clause are already part of the group by.
-            if not is_ref:
-                expressions.extend(expr.get_group_by_cols())
+        if not self._meta_ordering:
+            for expr, (sql, params, is_ref) in order_by:
+                # Skip references to the SELECT clause, as all expressions in
+                # the SELECT clause are already part of the GROUP BY.
+                if not is_ref:
+                    expressions.extend(expr.get_group_by_cols())
         having_group_by = self.having.get_group_by_cols() if self.having else ()
         for expr in having_group_by:
             expressions.append(expr)
diff --git a/test_fix.py b/test_fix.py
new file mode 100644
index 0000000000..e3a17aa170
--- /dev/null
+++ b/test_fix.py
@@ -0,0 +1,107 @@
+#!/usr/bin/env python
+import os
+import sys
+from django.db.models.sql.compiler import SQLCompiler
+from django.db.models.expressions import Ref, OrderBy, F
+from django.db.models.sql.query import Query
+from django.utils.hashable import make_hashable
+
+# Create a mock Query object
+class MockQuery:
+    def __init__(self, group_by=None, default_ordering=True):
+        self.group_by = group_by
+        self.default_ordering = default_ordering
+        self.order_by = []
+        self.meta = type('Meta', (), {'ordering': ['name']})
+
+    def get_meta(self):
+        return self.meta
+
+    def resolve_ref(self, expr):
+        return expr
+
+# Create a mock SQLCompiler
+class MockSQLCompiler(SQLCompiler):
+    def __init__(self, query, connection=None, using=None):
+        self.query = query
+        self.connection = connection
+        self._meta_ordering = query.get_meta().ordering if query.get_meta().ordering else None
+        self.having = None
+
+    def compile(self, node):
+        return "compiled_sql", ()
+
+    def collapse_group_by(self, expressions, having_group_by):
+        return expressions
+
+# Test the original implementation
+def test_original_implementation():
+    # Create a query with Meta.ordering and group_by
+    query = MockQuery(group_by=True)
+
+    # Create a compiler
+    compiler = MockSQLCompiler(query)
+
+    # Create select and order_by
+    select = [("expr", None, None)]
+    order_by = [(F("name"), ("name ASC", (), False))]
+
+    # Get group_by
+    group_by = compiler.get_group_by(select, order_by)
+
+    # Print the result
+    print("Original implementation:")
+    print(f"Meta.ordering: {compiler._meta_ordering}")
+    print(f"GROUP BY clauses: {len(group_by)}")
+    for sql, params in group_by:
+        print(f"  {sql} - {params}")
+
+    # Check if Meta.ordering fields are in GROUP BY
+    meta_ordering_in_group_by = any("name" in sql for sql, _ in group_by)
+    return meta_ordering_in_group_by
+
+# Test the fixed implementation
+def test_fixed_implementation():
+    # Create a query with Meta.ordering and group_by
+    query = MockQuery(group_by=True)
+
+    # Create a compiler
+    compiler = MockSQLCompiler(query)
+
+    # Create select and order_by
+    select = [("expr", None, None)]
+    order_by = [(F("name"), ("name ASC", (), False))]
+
+    # Get group_by
+    group_by = compiler.get_group_by(select, order_by)
+
+    # Print the result
+    print("\nFixed implementation:")
+    print(f"Meta.ordering: {compiler._meta_ordering}")
+    print(f"GROUP BY clauses: {len(group_by)}")
+    for sql, params in group_by:
+        print(f"  {sql} - {params}")
+
+    # Check if Meta.ordering fields are in GROUP BY
+    meta_ordering_in_group_by = any("name" in sql for sql, _ in group_by)
+    return meta_ordering_in_group_by
+
+if __name__ == "__main__":
+    # Test original implementation
+    original_result = test_original_implementation()
+
+    # Test fixed implementation
+    fixed_result = test_fixed_implementation()
+
+    # Print summary
+    print("\nSummary:")
+    print(f"Original implementation includes Meta.ordering in GROUP BY: {original_result}")
+    print(f"Fixed implementation includes Meta.ordering in GROUP BY: {fixed_result}")
+
+    # Verify the fix
+    if not fixed_result and original_result:
+        print("\nFix verified: Meta.ordering fields are no longer included in GROUP BY!")
+        sys.exit(0)
+    else:
+        print("\nFix not working as expected.")
+        sys.exit(1)
\ No newline at end of file
diff --git a/test_meta_ordering_group_by.py b/test_meta_ordering_group_by.py
new file mode 100644
index 0000000000..9daa17e643
--- /dev/null
+++ b/test_meta_ordering_group_by.py
@@ -0,0 +1,76 @@
+#!/usr/bin/env python
+import os
+import sys
+import django
+from django.db import models
+from django.db.models import Count
+
+# Set up Django
+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'test_sqlite')
+django.setup()
+
+# Create the database tables
+from django.db import connection
+connection.cursor().execute('CREATE TABLE IF NOT EXISTS test_meta_ordering_group_by_author (id INTEGER PRIMARY KEY, name TEXT)')
+connection.cursor().execute('CREATE TABLE IF NOT EXISTS test_meta_ordering_group_by_article (id INTEGER PRIMARY KEY, title TEXT, author_id INTEGER, FOREIGN KEY(author_id) REFERENCES test_meta_ordering_group_by_author(id))')
+
+# Define a simple model with Meta.ordering
+class Author(models.Model):
+    name = models.CharField(max_length=100)
+
+    class Meta:
+        ordering = ['name']
+
+class Article(models.Model):
+    title = models.CharField(max_length=100)
+    author = models.ForeignKey(Author, on_delete=models.CASCADE)
+
+# Create test data
+def create_test_data():
+    # Create authors
+    author1 = Author.objects.create(name='Author 1')
+    author2 = Author.objects.create(name='Author 2')
+
+    # Create articles
+    Article.objects.create(title='Article 1', author=author1)
+    Article.objects.create(title='Article 2', author=author1)
+    Article.objects.create(title='Article 3', author=author2)
+
+# Test the fix
+def test_meta_ordering_group_by():
+    # Create test data
+    create_test_data()
+
+    # This query would include 'name' in GROUP BY before the fix
+    results = Article.objects.values('author').annotate(count=Count('author'))
+
+    # Print the SQL query to verify
+    print("SQL Query:")
+    print(results.query)
+
+    # Check the results
+    expected = [
+        {'author': 1, 'count': 2},  # author1 has 2 articles
+        {'author': 2, 'count': 1},  # author2 has 1 article
+    ]
+
+    results_list = list(results)
+    print("\nResults:")
+    print(results_list)
+
+    # Verify the results match expected
+    assert len(results_list) == len(expected), f"Expected {len(expected)} results, got {len(results_list)}"
+
+    # Check each result
+    for result in results_list:
+        author_id = result['author']
+        count = result['count']
+
+        # Find the expected result for this author
+        expected_result = next(e for e in expected if e['author'] == author_id)
+        assert count == expected_result['count'], f"Expected count {expected_result['count']} for author {author_id}, got {count}"
+
+    print("\nTest passed! Meta.ordering fields are not included in GROUP BY.")
+
+if __name__ == '__main__':
+    test_meta_ordering_group_by()
\ No newline at end of file
diff --git a/test_simple.py b/test_simple.py
new file mode 100644
index 0000000000..d00d59dc4d
--- /dev/null
+++ b/test_simple.py
@@ -0,0 +1,61 @@
+#!/usr/bin/env python
+import os
+import sys
+import django
+from django.db import models
+from django.db.models import Count, F
+
+# Set up Django
+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'test_sqlite')
+django.setup()
+
+# Create a simple model with Meta.ordering
+class Author(models.Model):
+    name = models.CharField(max_length=100)
+
+    class Meta:
+        ordering = ['name']
+
+class Article(models.Model):
+    title = models.CharField(max_length=100)
+    author = models.ForeignKey(Author, on_delete=models.CASCADE)
+
+# Create test data
+def create_test_data():
+    # Create authors
+    author1 = Author.objects.create(name='Author 1')
+    author2 = Author.objects.create(name='Author 2')
+
+    # Create articles
+    Article.objects.create(title='Article 1', author=author1)
+    Article.objects.create(title='Article 2', author=author1)
+    Article.objects.create(title='Article 3', author=author2)
+
+# Test the fix
+def test_meta_ordering_group_by():
+    # Create test data
+    create_test_data()
+
+    # This query would include 'name' in GROUP BY before the fix
+    results = Article.objects.values('author').annotate(count=Count('author'))
+
+    # Print the SQL query to verify
+    print("SQL Query:")
+    print(str(results.query))
+
+    # Check if 'name' is in the query (which would indicate it's in GROUP BY)
+    has_name_in_query = 'name' in str(results.query)
+
+    if not has_name_in_query:
+        print("\nFix verified: Meta.ordering fields are no longer included in GROUP BY!")
+        return True
+    else:
+        print("\nFix not working: Meta.ordering fields are still in GROUP BY.")
+        return False
+
+if __name__ == "__main__":
+    # Run the test
+    success = test_meta_ordering_group_by()
+
+    # Exit with appropriate code
+    sys.exit(0 if success else 1)
\ No newline at end of file
diff --git a/test_sqlite.py b/test_sqlite.py
new file mode 100644
index 0000000000..f257dc7c05
--- /dev/null
+++ b/test_sqlite.py
@@ -0,0 +1,19 @@
+import os
+import django
+
+BASE_DIR = os.path.dirname(os.path.abspath(__file__))
+
+INSTALLED_APPS = [
+    'django.contrib.contenttypes',
+    'django.contrib.auth',
+]
+
+DATABASES = {
+    'default': {
+        'ENGINE': 'django.db.backends.sqlite3',
+        'NAME': ':memory:',
+    }
+}
+
+SECRET_KEY = 'fake-key'
+USE_TZ = True
\ No newline at end of file
