diff --git a/comprehensive_test.py b/comprehensive_test.py
new file mode 100644
index 0000000000..aed83e3649
--- /dev/null
+++ b/comprehensive_test.py
@@ -0,0 +1,100 @@
+import os
+import sys
+import django
+from django.db import models
+from django.db.models import sql
+
+# Set up Django
+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'django.conf.global_settings')
+os.environ.setdefault('DATABASES', '{"default": {"ENGINE": "django.db.backends.sqlite3", "NAME": ":memory:"}}')
+django.setup()
+
+# Define the models
+class Base(models.Model):
+    base_id = models.AutoField(primary_key=True)
+    field_base = models.IntegerField()
+
+    class Meta:
+        app_label = 'comprehensive_test'
+        managed = False
+
+class OtherBase(models.Model):
+    otherbase_id = models.AutoField(primary_key=True)
+    field_otherbase = models.IntegerField()
+
+    class Meta:
+        app_label = 'comprehensive_test'
+        managed = False
+
+class Child(Base, OtherBase):
+    class Meta:
+        app_label = 'comprehensive_test'
+        managed = False
+
+# Create a mock field class
+class MockField:
+    def __init__(self):
+        self.model = None
+        self.auto_created = False
+        self.concrete = True
+        self.is_relation = False
+
+# Create a mock UpdateQuery for testing
+class MockUpdateQuery(sql.UpdateQuery):
+    def __init__(self, model):
+        self.model = model
+        self.related_updates = {}
+        self.related_ids = None
+
+    def get_meta(self):
+        class MockMeta:
+            def __init__(self, model):
+                self.model = model
+                self.concrete_model = model
+
+            def get_field(self, name):
+                if name == 'field_otherbase':
+                    field = MockField()
+                    field.name = 'field_otherbase'
+                    field.model = OtherBase
+                    field.auto_created = False
+                    field.concrete = True
+                    field.is_relation = False
+                    return field
+                return None
+
+        return MockMeta(self.model)
+
+    def add_related_update(self, model, field, value):
+        self.related_updates.setdefault(model, []).append((field, None, value))
+
+    def get_related_updates(self):
+        return []
+
+# Test the fix
+def test_fix():
+    # Create a queryset for the Child model
+    child_query = MockUpdateQuery(Child)
+
+    # Test updating a field from OtherBase
+    print("Testing update of field_otherbase (from OtherBase):")
+    child_query.add_update_values({'field_otherbase': 55})
+    print(f"Related updates: {child_query.related_updates}")
+
+    # Reset for next test
+    child_query.related_updates = {}
+
+    # Test updating a field from Base
+    print("\nTesting update of field_base (from Base):")
+    # This would require more setup to mock the field_base properly
+    # For now, we'll just check the logic
+
+    # The key check is whether the field's model is in the model's inheritance hierarchy
+    print(f"Child.__bases__: {Child.__bases__}")
+    for base in Child.__bases__:
+        print(f"Base class: {base}")
+        print(f"Is OtherBase? {base is OtherBase}")
+        print(f"Is Base? {base is Base}")
+
+if __name__ == '__main__':
+    test_fix()
\ No newline at end of file
diff --git a/django/db/models/sql/subqueries.py b/django/db/models/sql/subqueries.py
index 04063f73bc..e8aeb95688 100644
--- a/django/db/models/sql/subqueries.py
+++ b/django/db/models/sql/subqueries.py
@@ -95,7 +95,18 @@ class UpdateQuery(Query):
                     "Cannot update model field %r (only non-relations and "
                     "foreign keys permitted)." % field
                 )
-            if model is not self.get_meta().concrete_model:
+            # Check if the field's model is one of the parent models of the current model
+            # If it is, we should update the field directly rather than treating it as a related update
+            current_model = self.get_meta().concrete_model
+            is_parent = False
+
+            # Check if the field's model is in the model's inheritance hierarchy
+            for base in current_model.__bases__:
+                if model is base or model is base._meta.concrete_model:
+                    is_parent = True
+                    break
+
+            if model is not current_model and not is_parent:
                 self.add_related_update(model, field, val)
                 continue
             values_seq.append((field, model, val))
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..fb7e4f3eb4
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,88 @@
+import os
+import sys
+import django
+from django.db import models
+
+# Set up Django
+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'django.conf.global_settings')
+os.environ.setdefault('DATABASES', '{"default": {"ENGINE": "django.db.backends.sqlite3", "NAME": ":memory:"}}')
+django.setup()
+
+# Define the models
+class Base(models.Model):
+    base_id = models.AutoField(primary_key=True)
+    field_base = models.IntegerField()
+
+    class Meta:
+        app_label = 'reproduce_issue'
+
+class OtherBase(models.Model):
+    otherbase_id = models.AutoField(primary_key=True)
+    field_otherbase = models.IntegerField()
+
+    class Meta:
+        app_label = 'reproduce_issue'
+
+class Child(Base, OtherBase):
+    class Meta:
+        app_label = 'reproduce_issue'
+
+# Create the database tables
+from django.db import connection
+cursor = connection.cursor()
+
+# Create tables
+cursor.execute('''
+CREATE TABLE IF NOT EXISTS reproduce_issue_base (
+    base_id INTEGER PRIMARY KEY AUTOINCREMENT,
+    field_base INTEGER
+)
+''')
+
+cursor.execute('''
+CREATE TABLE IF NOT EXISTS reproduce_issue_otherbase (
+    otherbase_id INTEGER PRIMARY KEY AUTOINCREMENT,
+    field_otherbase INTEGER
+)
+''')
+
+cursor.execute('''
+CREATE TABLE IF NOT EXISTS reproduce_issue_child (
+    child_id INTEGER PRIMARY KEY AUTOINCREMENT,
+    base_id INTEGER,
+    otherbase_id INTEGER,
+    FOREIGN KEY (base_id) REFERENCES reproduce_issue_base(base_id),
+    FOREIGN KEY (otherbase_id) REFERENCES reproduce_issue_otherbase(otherbase_id)
+)
+''')
+
+# Create instances
+OtherBase.objects.create(field_otherbase=100)
+OtherBase.objects.create(field_otherbase=101)
+Child.objects.create(field_base=0, field_otherbase=0)
+Child.objects.create(field_base=1, field_otherbase=1)
+
+# Print initial state
+print("Initial state:")
+print("Child objects:")
+for child in Child.objects.all():
+    print(f"Child(base_id={child.base_id}, otherbase_id={child.otherbase_id}, field_base={child.field_base}, field_otherbase={child.field_otherbase})")
+
+print("\nOtherBase objects:")
+for other in OtherBase.objects.all():
+    print(f"OtherBase(otherbase_id={other.otherbase_id}, field_otherbase={other.field_otherbase})")
+
+# Perform the update
+print("\nPerforming update: Child.objects.update(field_otherbase=55)")
+rows = Child.objects.update(field_otherbase=55)
+print(f"Rows affected: {rows}")
+
+# Print final state
+print("\nFinal state:")
+print("Child objects:")
+for child in Child.objects.all():
+    print(f"Child(base_id={child.base_id}, otherbase_id={child.otherbase_id}, field_base={child.field_base}, field_otherbase={child.field_otherbase})")
+
+print("\nOtherBase objects:")
+for other in OtherBase.objects.all():
+    print(f"OtherBase(otherbase_id={other.otherbase_id}, field_otherbase={other.field_otherbase})")
\ No newline at end of file
diff --git a/simple_test.py b/simple_test.py
new file mode 100644
index 0000000000..af27ecf8f6
--- /dev/null
+++ b/simple_test.py
@@ -0,0 +1,49 @@
+import os
+import sys
+import django
+from django.db import models
+from django.db.models import sql
+
+# Set up Django
+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'django.conf.global_settings')
+os.environ.setdefault('DATABASES', '{"default": {"ENGINE": "django.db.backends.sqlite3", "NAME": ":memory:"}}')
+django.setup()
+
+# Define a simple test case
+class Base(models.Model):
+    field_base = models.IntegerField()
+
+    class Meta:
+        app_label = 'simple_test'
+        managed = False
+
+class OtherBase(models.Model):
+    field_otherbase = models.IntegerField()
+
+    class Meta:
+        app_label = 'simple_test'
+        managed = False
+
+class Child(Base, OtherBase):
+    class Meta:
+        app_label = 'simple_test'
+        managed = False
+
+# Test the fix
+def test_fix():
+    # Create a queryset for the Child model
+    queryset = Child.objects.all()
+
+    # Print the model hierarchy
+    print("Model hierarchy:")
+    print(f"Child.__bases__: {Child.__bases__}")
+    print(f"issubclass(Base, OtherBase): {issubclass(Base, OtherBase)}")
+    print(f"issubclass(OtherBase, Base): {issubclass(OtherBase, Base)}")
+
+    # Test if our fix would work
+    for base in Child.__bases__:
+        print(f"Base class: {base}")
+        print(f"Is parent of OtherBase: {issubclass(OtherBase, base)}")
+
+if __name__ == '__main__':
+    test_fix()
\ No newline at end of file
diff --git a/test_update.py b/test_update.py
new file mode 100644
index 0000000000..fbb60716ab
--- /dev/null
+++ b/test_update.py
@@ -0,0 +1,88 @@
+import os
+import sys
+import django
+from django.db import models
+from django.db.models import sql
+
+# Set up Django
+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'django.conf.global_settings')
+django.setup()
+
+# Create a simple test case to demonstrate the issue
+class MockOtherBase:
+    def __init__(self):
+        self._meta = MockMeta(self)
+
+class MockChild:
+    def __init__(self):
+        self._meta = MockMeta(self)
+
+    # Add __bases__ to simulate inheritance
+    __bases__ = (MockOtherBase,)
+
+class MockMeta:
+    def __init__(self, model):
+        self.model = model
+        self.concrete_model = model
+        self.__bases__ = []
+
+    def get_field(self, name):
+        # Simulate getting a field from a parent model
+        if name == 'field_otherbase':
+            # Return a field that belongs to OtherBase
+            field = MockField()
+            field.name = 'field_otherbase'
+            field.model = MockOtherBase()
+            field.auto_created = False
+            field.concrete = True
+            field.is_relation = False
+            return field
+        return None
+
+class MockField:
+    def __init__(self):
+        self.model = None
+        self.auto_created = False
+        self.concrete = True
+        self.is_relation = False
+
+class MockOtherBase:
+    def __init__(self):
+        self._meta = MockMeta(self)
+
+class MockChild:
+    def __init__(self):
+        self._meta = MockMeta(self)
+
+# Create a mock UpdateQuery
+class MockUpdateQuery(sql.UpdateQuery):
+    def __init__(self):
+        self.model = MockChild()
+        self.related_updates = {}
+        self.related_ids = None
+
+    def get_meta(self):
+        return self.model._meta
+
+    def add_related_update(self, model, field, value):
+        self.related_updates.setdefault(model, []).append((field, None, value))
+
+    def get_related_updates(self):
+        return []
+
+# Test the add_update_values method
+def test_update_values():
+    query = MockUpdateQuery()
+
+    # This simulates calling Child.objects.update(field_otherbase=55)
+    query.add_update_values({'field_otherbase': 55})
+
+    # Check if the update was added to related_updates
+    print("Related updates:", query.related_updates)
+
+    # In the current implementation, the update is added to related_updates
+    # because model is not self.get_meta().concrete_model
+    # This is the bug we need to fix
+
+if __name__ == '__main__':
+    test_update_values()
\ No newline at end of file
