diff --git a/fixed_variable_quantile.py b/fixed_variable_quantile.py
new file mode 100644
index 00000000..50ff0066
--- /dev/null
+++ b/fixed_variable_quantile.py
@@ -0,0 +1,79 @@
+def quantile(self, q, dim=None, interpolation="linear", keep_attrs=None):
+    """Compute the qth quantile of the data along the specified dimension.
+
+    Returns the qth quantiles(s) of the array elements.
+
+    Parameters
+    ----------
+    q : float in range of [0,1] (or sequence of floats)
+        Quantile to compute, which must be between 0 and 1
+        inclusive.
+    dim : str or sequence of str, optional
+        Dimension(s) over which to apply quantile.
+    interpolation : {'linear', 'lower', 'higher', 'midpoint', 'nearest'}
+        This optional parameter specifies the interpolation method to
+        use when the desired quantile lies between two data points
+        ``i < j``:
+            * linear: ``i + (j - i) * fraction``, where ``fraction`` is
+              the fractional part of the index surrounded by ``i`` and
+              ``j``.
+            * lower: ``i``.
+            * higher: ``j``.
+            * nearest: ``i`` or ``j``, whichever is nearest.
+            * midpoint: ``(i + j) / 2``.
+    keep_attrs : bool, optional
+        If True, the variable's attributes (`attrs`) will be copied from
+        the original object to the new one.  If False (default), the new
+        object will be returned without attributes.
+
+    Returns
+    -------
+    quantiles : Variable
+        If `q` is a single quantile, then the result
+        is a scalar. If multiple percentiles are given, first axis of
+        the result corresponds to the quantile and a quantile dimension
+        is added to the return array. The other dimensions are the
+        dimensions that remain after the reduction of the array.
+
+    See Also
+    --------
+    numpy.nanpercentile, pandas.Series.quantile, Dataset.quantile,
+    DataArray.quantile
+    """
+    if isinstance(self.data, dask_array_type):
+        raise TypeError(
+            "quantile does not work for arrays stored as dask "
+            "arrays. Load the data via .compute() or .load() "
+            "prior to calling this method."
+        )
+
+    q = np.asarray(q, dtype=np.float64)
+
+    new_dims = list(self.dims)
+    if dim is not None:
+        axis = self.get_axis_num(dim)
+        if utils.is_scalar(dim):
+            new_dims.remove(dim)
+        else:
+            for d in dim:
+                new_dims.remove(d)
+    else:
+        axis = None
+        new_dims = []
+
+    # only add the quantile dimension if q is array like
+    if q.ndim != 0:
+        new_dims = ["quantile"] + new_dims
+
+    qs = np.nanpercentile(
+        self.data, q * 100.0, axis=axis, interpolation=interpolation
+    )
+
+    # Create the new variable
+    result = Variable(new_dims, qs)
+
+    # Copy attributes if requested
+    if keep_attrs:
+        result.attrs = self.attrs.copy() if self.attrs else None
+
+    return result
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 00000000..983c4b44
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,10 @@
+import xarray as xr
+
+# Create a DataArray with attributes
+da = xr.DataArray([0, 0], dims="x", attrs={'units': 'K'})
+print("Original DataArray attributes:", da.attrs)
+
+# Call quantile with keep_attrs=True
+out = da.quantile(.9, dim='x', keep_attrs=True)
+print("Output DataArray attributes:", out.attrs)
+print("Expected attributes: OrderedDict([('units', 'K')])")
\ No newline at end of file
diff --git a/xarray/core/dataarray.py b/xarray/core/dataarray.py
index 807badde..8250496d 100644
--- a/xarray/core/dataarray.py
+++ b/xarray/core/dataarray.py
@@ -2875,6 +2875,8 @@ class DataArray(AbstractArray, DataWithCoords):
         ds = self._to_temp_dataset().quantile(
             q, dim=dim, keep_attrs=keep_attrs, interpolation=interpolation
         )
+
+        # Ensure attributes are preserved if keep_attrs is True\n        result = self._from_temp_dataset(ds)\n\n        if keep_attrs and not result.attrs and self.attrs:\n            result.attrs = self.attrs.copy()\n\n        return result
         return self._from_temp_dataset(ds)
 
     def rank(
diff --git a/xarray/core/variable.py b/xarray/core/variable.py
index 2e9906ce..82b7dd9a 100644
--- a/xarray/core/variable.py
+++ b/xarray/core/variable.py
@@ -1592,78 +1592,6 @@ class Variable(
         """
         return self.broadcast_equals(other, equiv=duck_array_ops.array_notnull_equiv)
 
-    def quantile(self, q, dim=None, interpolation="linear"):
-        """Compute the qth quantile of the data along the specified dimension.
-
-        Returns the qth quantiles(s) of the array elements.
-
-        Parameters
-        ----------
-        q : float in range of [0,1] (or sequence of floats)
-            Quantile to compute, which must be between 0 and 1
-            inclusive.
-        dim : str or sequence of str, optional
-            Dimension(s) over which to apply quantile.
-        interpolation : {'linear', 'lower', 'higher', 'midpoint', 'nearest'}
-            This optional parameter specifies the interpolation method to
-            use when the desired quantile lies between two data points
-            ``i < j``:
-                * linear: ``i + (j - i) * fraction``, where ``fraction`` is
-                  the fractional part of the index surrounded by ``i`` and
-                  ``j``.
-                * lower: ``i``.
-                * higher: ``j``.
-                * nearest: ``i`` or ``j``, whichever is nearest.
-                * midpoint: ``(i + j) / 2``.
-
-        Returns
-        -------
-        quantiles : Variable
-            If `q` is a single quantile, then the result
-            is a scalar. If multiple percentiles are given, first axis of
-            the result corresponds to the quantile and a quantile dimension
-            is added to the return array. The other dimensions are the
-             dimensions that remain after the reduction of the array.
-
-        See Also
-        --------
-        numpy.nanpercentile, pandas.Series.quantile, Dataset.quantile,
-        DataArray.quantile
-        """
-        if isinstance(self.data, dask_array_type):
-            raise TypeError(
-                "quantile does not work for arrays stored as dask "
-                "arrays. Load the data via .compute() or .load() "
-                "prior to calling this method."
-            )
-
-        q = np.asarray(q, dtype=np.float64)
-
-        new_dims = list(self.dims)
-        if dim is not None:
-            axis = self.get_axis_num(dim)
-            if utils.is_scalar(dim):
-                new_dims.remove(dim)
-            else:
-                for d in dim:
-                    new_dims.remove(d)
-        else:
-            axis = None
-            new_dims = []
-
-        # only add the quantile dimension if q is array like
-        if q.ndim != 0:
-            new_dims = ["quantile"] + new_dims
-
-        qs = np.nanpercentile(
-            self.data, q * 100.0, axis=axis, interpolation=interpolation
-        )
-        return Variable(new_dims, qs)
-
-    def rank(self, dim, pct=False):
-        """Ranks the data.
-
-        Equal values are assigned a rank that is the average of the ranks that
         would have been otherwise assigned to all of the values within that
         set.  Ranks begin at 1, not 0. If `pct`, computes percentage ranks.
 
@@ -2148,7 +2076,7 @@ def broadcast_variables(*variables):
     The data on the returned variables will be a view of the data on the
     corresponding original arrays, but dimensions will be reordered and
     inserted so that both broadcast arrays have the same dimensions. The new
-    dimensions are sorted in order of appearance in the first variable's
+    dimensions are sorted in order of appearance in the first variable's"
     dimensions followed by the second variable's dimensions.
     """
     dims_map = _unified_dims(variables)
