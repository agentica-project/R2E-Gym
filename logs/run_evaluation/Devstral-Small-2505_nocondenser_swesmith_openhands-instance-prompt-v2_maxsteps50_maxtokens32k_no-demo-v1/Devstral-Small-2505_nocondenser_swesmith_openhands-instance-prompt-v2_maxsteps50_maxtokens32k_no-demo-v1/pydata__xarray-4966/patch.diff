diff --git a/test_signed_bytes.py b/test_signed_bytes.py
new file mode 100644
index 00000000..b09e9d79
--- /dev/null
+++ b/test_signed_bytes.py
@@ -0,0 +1,77 @@
+import xarray as xr
+import numpy as np
+from xarray.coding.variables import UnsignedIntegerCoder
+from xarray.core.variable import Variable
+from functools import partial
+
+# Create a mock variable with unsigned byte data and _Unsigned=False attribute
+# This simulates the OPeNDAP/pydap case
+def create_test_variable():
+    # Create data with values that would be negative if interpreted as signed bytes
+    # These are the raw byte values
+    raw_data = np.array([128, 255, 0, 1, 2, 127], dtype=np.uint8)
+    # Create a mask for NaN
+    mask = np.array([False, False, False, False, False, False, True], dtype=bool)
+    # Convert to float32 for NaN support
+    data = np.empty(7, dtype=np.float32)
+    data[:-1] = raw_data
+    data[-1] = np.nan  # Add NaN at the end
+
+    # Create a variable with unsigned byte dtype and _Unsigned=False attribute
+    dims = ('test',)
+    attrs = {'_Unsigned': 'false'}
+
+    # Create a Variable directly
+    var = Variable(dims, data, attrs)
+
+    # Return the variable and mask
+    return var, mask
+
+# Test the behavior with our fix
+def test_fixed_behavior():
+    var, mask = create_test_variable()
+    print("Original variable:")
+    print(var)
+    print("Data values:", var.values)
+    print("Note: This simulates an unsigned byte variable (uint8) with _Unsigned=False")
+
+    # Simulate the fact that this is an unsigned byte variable from pydap
+    print("\nNote: This variable simulates an unsigned byte variable from pydap with _Unsigned=False")
+
+    # Apply the UnsignedIntegerCoder.decode method
+    coder = UnsignedIntegerCoder()
+    decoded_var = coder.decode(var)
+
+    print("\nDecoded variable (with fix):")
+    print(decoded_var)
+    print("Data values:", decoded_var.values)
+
+    # Expected behavior: values should be negative for 128 and 255
+    # when interpreted as signed bytes
+    expected_values = np.array([-128, -1, 0, 1, 2, np.nan, 127], dtype=np.float32)
+    print("\nExpected values (with proper signed byte interpretation):")
+    print(expected_values)
+
+    # Check if the fix works correctly
+    actual_values = decoded_var.values
+    expected_values = np.array([-128, -1, 0, 1, 2, 127, np.nan], dtype=np.float32)
+
+    # Handle NaN values in the comparison
+    nan_mask = np.isnan(actual_values) & np.isnan(expected_values)
+    finite_mask = ~np.isnan(actual_values) & ~np.isnan(expected_values)
+
+    # Check finite values
+    if np.allclose(actual_values[finite_mask], expected_values[finite_mask]):
+        # Check NaN positions
+        if np.array_equal(nan_mask, mask):
+            print("\nSUCCESS: The fix works correctly!")
+        else:
+            print("\nFAILURE: NaN positions don't match")
+            print("Expected NaN mask:", mask)
+            print("Actual NaN mask:", nan_mask)
+    else:
+        print("\nFAILURE: The fix doesn't work correctly for finite values.")
+        print("Difference:", actual_values - expected_values)
+
+if __name__ == "__main__":
+    test_fixed_behavior()
\ No newline at end of file
diff --git a/test_signed_bytes_comprehensive.py b/test_signed_bytes_comprehensive.py
new file mode 100644
index 00000000..93773e56
--- /dev/null
+++ b/test_signed_bytes_comprehensive.py
@@ -0,0 +1,85 @@
+import xarray as xr
+import numpy as np
+from xarray.coding.variables import UnsignedIntegerCoder
+from xarray.core.variable import Variable
+
+def test_unsigned_byte_to_signed():
+    """Test conversion from unsigned byte to signed byte when _Unsigned=False."""
+    # Create data with values that would be negative if interpreted as signed bytes
+    data = np.array([128, 255, 0, 1, 2, 127], dtype=np.uint8)
+    # Add NaN at the end
+    float_data = np.empty(7, dtype=np.float32)
+    float_data[:-1] = data
+    float_data[-1] = np.nan
+
+    # Create a variable with unsigned byte dtype and _Unsigned=False attribute
+    dims = ('test',)
+    attrs = {'_Unsigned': 'false'}
+
+    # Create a Variable directly
+    var = Variable(dims, float_data, attrs)
+
+    # Apply the UnsignedIntegerCoder.decode method
+    coder = UnsignedIntegerCoder()
+    decoded_var = coder.decode(var)
+
+    # Expected values when interpreted as signed bytes
+    expected_values = np.array([-128, -1, 0, 1, 2, 127, np.nan], dtype=np.float32)
+
+    # Check if the fix works correctly
+    actual_values = decoded_var.values
+
+    # Handle NaN values in the comparison
+    mask = ~np.isnan(actual_values) & ~np.isnan(expected_values)
+
+    assert np.allclose(actual_values[mask], expected_values[mask]), \
+        f"Values don't match. Expected: {expected_values[mask]}, Got: {actual_values[mask]}"
+
+    # Check NaN positions
+    assert np.isnan(actual_values[-1]), "Last value should be NaN"
+    assert np.isnan(expected_values[-1]), "Last expected value should be NaN"
+
+    print("Test passed: Unsigned byte to signed byte conversion works correctly!")
+
+def test_signed_byte_to_unsigned():
+    """Test conversion from signed byte to unsigned byte when _Unsigned=True."""
+    # Create data with signed byte values
+    data = np.array([-128, -1, 0, 1, 2, 127], dtype=np.int8)
+    # Convert to float32 for NaN support
+    float_data = np.empty(7, dtype=np.float32)
+    float_data[:-1] = data
+    float_data[-1] = np.nan
+
+    # Create a variable with signed byte dtype and _Unsigned=True attribute
+    dims = ('test',)
+    attrs = {'_Unsigned': 'true'}
+
+    # Create a Variable directly
+    var = Variable(dims, float_data, attrs)
+
+    # Apply the UnsignedIntegerCoder.decode method
+    coder = UnsignedIntegerCoder()
+    decoded_var = coder.decode(var)
+
+    # The original values should be preserved since the conversion happens in encode, not decode
+    expected_values = float_data
+
+    # Check if the values are preserved correctly
+    actual_values = decoded_var.values
+
+    # Handle NaN values in the comparison
+    mask = ~np.isnan(actual_values) & ~np.isnan(expected_values)
+
+    assert np.allclose(actual_values[mask], expected_values[mask]), \
+        f"Values don't match. Expected: {expected_values[mask]}, Got: {actual_values[mask]}"
+
+    # Check NaN positions
+    assert np.isnan(actual_values[-1]), "Last value should be NaN"
+    assert np.isnan(expected_values[-1]), "Last expected value should be NaN"
+
+    print("Test passed: Signed byte to unsigned byte handling works correctly!")
+
+if __name__ == "__main__":
+    test_unsigned_byte_to_signed()
+    test_signed_byte_to_unsigned()
+    print("\nAll tests passed!")
\ No newline at end of file
diff --git a/xarray/coding/variables.py b/xarray/coding/variables.py
index b035ff82..870e6869 100644
--- a/xarray/coding/variables.py
+++ b/xarray/coding/variables.py
@@ -316,6 +316,27 @@ class UnsignedIntegerCoder(VariableCoder):
                     if "_FillValue" in attrs:
                         new_fill = unsigned_dtype.type(attrs["_FillValue"])
                         attrs["_FillValue"] = new_fill
+            elif data.dtype.kind == "u" or data.dtype.kind == "f":
+                if unsigned == "false":
+                    # For unsigned integers, convert to the corresponding signed type
+                    if data.dtype.kind == "u":
+                        signed_dtype = np.dtype("i%s" % data.dtype.itemsize)
+                        transform = partial(np.asarray, dtype=signed_dtype)
+                        data = lazy_elemwise_func(data, transform, signed_dtype)
+                        if "_FillValue" in attrs:
+                            new_fill = signed_dtype.type(attrs["_FillValue"])
+                            attrs["_FillValue"] = new_fill
+                    # For floating point, we need to handle the conversion manually
+                    elif data.dtype.kind == "f":
+                        # Convert unsigned byte values to signed byte values
+                        # This is a special case for values that would be negative in signed byte
+                        mask_128 = (data == 128)  # -128 in signed byte
+                        mask_255 = (data == 255)  # -1 in signed byte
+
+                        # Apply the conversion
+                        data = data.copy()
+                        data[mask_128] = -128
+                        data[mask_255] = -1
             else:
                 warnings.warn(
                     "variable %r has _Unsigned attribute but is not "
