diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..1b47ae32b6
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,24 @@
+from sympy.utilities.iterables import partitions
+
+# Demonstrate the issue with partitions reusing dictionaries
+print("Partitions of 6 with k=2:")
+for p in partitions(6, k=2):
+    print(f"Partition: {p}")
+
+print("\nConverting to list shows the issue:")
+partitions_list = list(partitions(6, k=2))
+print(f"List length: {len(partitions_list)}")
+print("List contents:")
+for p in partitions_list:
+    print(f"Partition: {p}")
+
+print("\nThe correct partitions should be:")
+correct_partitions = [{2: 3}, {1: 2, 2: 2}, {1: 4, 2: 1}, {1: 6}]
+for p in correct_partitions:
+    print(f"Partition: {p}")
+
+print("\nWorkaround (using copy):")
+workaround = [p.copy() for p in partitions(6, k=2)]
+print("Workaround list:")
+for p in workaround:
+    print(f"Partition: {p}")
\ No newline at end of file
diff --git a/sympy/utilities/iterables.py b/sympy/utilities/iterables.py
index dd36dea304..10a2f6bdbf 100644
--- a/sympy/utilities/iterables.py
+++ b/sympy/utilities/iterables.py
@@ -1738,19 +1738,12 @@ def partitions(n, m=None, k=None, size=False):
     {2: 1, 4: 1}
     {3: 2}
 
-    Note that the _same_ dictionary object is returned each time.
-    This is for speed:  generating each partition goes quickly,
-    taking constant time, independent of n.
+    Each partition is returned as a new dictionary, so you can safely build
+    a list of the returned dictionaries without needing to make copies:
 
     >>> [p for p in partitions(6, k=2)]
-    [{1: 6}, {1: 6}, {1: 6}, {1: 6}]
-
-    If you want to build a list of the returned dictionaries then
-    make a copy of them:
-
-    >>> [p.copy() for p in partitions(6, k=2)]  # doctest: +SKIP
     [{2: 3}, {1: 2, 2: 2}, {1: 4, 2: 1}, {1: 6}]
-    >>> [(M, p.copy()) for M, p in partitions(6, k=2, size=True)]  # doctest: +SKIP
+    >>> [(M, p) for M, p in partitions(6, k=2, size=True)]
     [(3, {2: 3}), (4, {1: 2, 2: 2}), (5, {1: 4, 2: 1}), (6, {1: 6})]
 
     References
@@ -1774,9 +1767,9 @@ def partitions(n, m=None, k=None, size=False):
         # and returning {} to represent it is consistent with
         # the counting convention, e.g. nT(0) == 1.
         if size:
-            yield 0, {}
+            yield 0, {}.copy()
         else:
-            yield {}
+            yield {}.copy()
         return
 
     if m is None:
@@ -1786,9 +1779,9 @@ def partitions(n, m=None, k=None, size=False):
 
     if n == 0:
         if size:
-            yield 1, {0: 1}
+            yield 1, {0: 1}.copy()
         else:
-            yield {0: 1}
+            yield {0: 1}.copy()
         return
 
     k = min(k or n, n)
@@ -1802,9 +1795,9 @@ def partitions(n, m=None, k=None, size=False):
         keys.append(r)
     room = m - q - bool(r)
     if size:
-        yield sum(ms.values()), ms
+        yield sum(ms.values()), ms.copy()
     else:
-        yield ms
+        yield ms.copy()
 
     while keys != [1]:
         # Reuse any 1's.
@@ -1842,9 +1835,9 @@ def partitions(n, m=None, k=None, size=False):
             break
         room -= need
         if size:
-            yield sum(ms.values()), ms
+            yield sum(ms.values()), ms.copy()
         else:
-            yield ms
+            yield ms.copy()
 
 
 def ordered_partitions(n, m=None, sort=True):
diff --git a/test_partitions.py b/test_partitions.py
new file mode 100644
index 0000000000..bd317e8a70
--- /dev/null
+++ b/test_partitions.py
@@ -0,0 +1,5 @@
+from sympy.utilities.tests.test_iterables import test_partitions
+
+# Run the test
+test_partitions()
+print("test_partitions() passed!")
\ No newline at end of file
diff --git a/verify_fix.py b/verify_fix.py
new file mode 100644
index 0000000000..51de90799d
--- /dev/null
+++ b/verify_fix.py
@@ -0,0 +1,47 @@
+from sympy.utilities.iterables import partitions
+
+def test_partitions_copy():
+    """Test that partitions() no longer reuses dictionaries."""
+    # Get partitions of 6 with k=2
+    partitions_list = list(partitions(6, k=2))
+
+    # Check that we got 4 partitions
+    assert len(partitions_list) == 4
+
+    # Check that each partition is unique and correct
+    # The actual partitions may be in a different order than expected
+    # So we'll just check that we have the right number of partitions
+    # and that each expected partition exists in the actual partitions
+
+    # Print the actual partitions
+    print("Actual partitions:", partitions_list)
+
+    # Check that all expected partitions exist in the actual partitions
+    expected_partitions = [
+        {2: 3},
+        {1: 2, 2: 2},
+        {1: 4, 2: 1},
+        {1: 6}
+    ]
+
+    # Convert to sets for easier comparison
+    expected_sets = [frozenset(p.items()) for p in expected_partitions]
+    actual_sets = [frozenset(p.items()) for p in partitions_list]
+
+    # Check that all expected partitions are in the actual partitions
+    for expected in expected_sets:
+        assert expected in actual_sets
+
+    print("All expected partitions found in actual partitions")
+
+    # Additional test: modify one partition and ensure others aren't affected
+    # This would fail with the original implementation
+    partitions_list[0][1] = 999
+    assert partitions_list[1] != {1: 999, 2: 2}
+    assert partitions_list[2] != {1: 999, 2: 1}
+    assert partitions_list[3] != {1: 999}
+
+    print("All tests passed! partitions() now correctly creates new dictionaries.")
+
+# Run the test
+test_partitions_copy()
\ No newline at end of file
