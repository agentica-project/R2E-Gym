diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 00000000..f1fba527
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,23 @@
+import xarray as xr
+import numpy as np
+
+# Create a dataset with an int32 coordinate
+ds = xr.Dataset(coords={'a': np.array([0], dtype='i4')})
+print("Original dtype:", ds['a'].values.dtype)
+print("Original values:", ds['a'].values)
+
+# Stack the coordinate
+stacked_ds = ds.stack(b=('a',))
+print("Stacked dtype:", stacked_ds['a'].values.dtype)
+print("Stacked values:", stacked_ds['a'].values)
+
+# Check if dtypes are equal
+print("Dtypes equal?", ds['a'].values.dtype == stacked_ds['a'].values.dtype)
+
+# Print the stacked dataset structure
+print("\nStacked dataset structure:")
+print(stacked_ds)
+
+# Print the b coordinate
+print("\nB coordinate:")
+print(stacked_ds['b'])
\ No newline at end of file
diff --git a/xarray/core/indexes.py b/xarray/core/indexes.py
index f3f03c94..9f5b61d2 100644
--- a/xarray/core/indexes.py
+++ b/xarray/core/indexes.py
@@ -706,7 +706,32 @@ class PandasMultiIndex(PandasIndex):
                     f"from variable {name!r} that wraps a multi-index"
                 )
 
-        split_labels, levels = zip(*[lev.factorize() for lev in level_indexes])
+        # Store original values and dtypes
+        original_values = {}
+        for name, var in variables.items():
+            original_values[name] = var.values
+
+        # Factorize each level index
+        split_labels = []
+        levels = []
+        for i, (name, lev, var) in enumerate(zip(variables.keys(), level_indexes, variables.values())):
+            # Get the original values and dtype
+            orig_values = original_values[name]
+            orig_dtype = var.dtype
+
+            # Factorize the level
+            codes, uniques = lev.factorize()
+
+            # If the original dtype is an integer type, preserve it
+            if np.issubdtype(orig_dtype, np.integer):
+                # Create a new index with the original dtype
+                uniques_index = pd.Index(uniques, dtype=orig_dtype)
+                levels.append(uniques_index)
+            else:
+                levels.append(uniques)
+
+            split_labels.append(codes)
+
         labels_mesh = np.meshgrid(*split_labels, indexing="ij")
         labels = [x.ravel() for x in labels_mesh]
 
