diff --git a/sphinx/directives/code.py b/sphinx/directives/code.py
index dc44ed314..2d5036492 100644
--- a/sphinx/directives/code.py
+++ b/sphinx/directives/code.py
@@ -52,15 +52,23 @@ def dedent_lines(lines: List[str], dedent: int, location: Tuple[str, int] = None
     if dedent is None:
         return textwrap.dedent(''.join(lines)).splitlines(True)
 
-    if any(s[:dedent].strip() for s in lines):
+    # Check if any line would have non-whitespace stripped
+    # Only check lines that have at least 'dedent' characters
+    lines_to_check = [s for s in lines if len(s) > dedent]
+    if lines_to_check and any(s[:dedent].strip() for s in lines_to_check):
         logger.warning(__('non-whitespace stripped by dedent'), location=location)
 
     new_lines = []
     for line in lines:
-        new_line = line[dedent:]
-        if line.endswith('\n') and not new_line:
-            new_line = '\n'  # keep CRLF
-        new_lines.append(new_line)
+        # Only dedent lines that have at least 'dedent' characters
+        if len(line) > dedent:
+            new_line = line[dedent:]
+            if line.endswith('\n') and not new_line:
+                new_line = '\n'  # keep CRLF
+            new_lines.append(new_line)
+        else:
+            # For lines shorter than 'dedent', keep them as is
+            new_lines.append(line)
 
     return new_lines
 
@@ -220,17 +228,28 @@ class LiteralIncludeReader:
         if 'diff' in self.options:
             lines = self.show_diff()
         else:
+            # Apply filters in this order:
+            # 1. Content filters (pyobject, start, end, lines)
+            # 2. Prepend/append filters (to add content before/after)
+            # 3. Dedent filter (to adjust indentation of the content only)
             filters = [self.pyobject_filter,
                        self.start_filter,
                        self.end_filter,
-                       self.lines_filter,
-                       self.prepend_filter,
-                       self.append_filter,
-                       self.dedent_filter]
+                       self.lines_filter]
+
             lines = self.read_file(self.filename, location=location)
             for func in filters:
                 lines = func(lines, location=location)
 
+            # Apply prepend and append
+            if 'prepend' in self.options:
+                lines = self.prepend_filter(lines, location=location)
+            if 'append' in self.options:
+                lines = self.append_filter(lines, location=location)
+
+            # Apply dedent last, so it only affects the content
+            lines = self.dedent_filter(lines, location=location)
+
         return ''.join(lines), len(lines)
 
     def show_diff(self, location: Tuple[str, int] = None) -> List[str]:
@@ -343,6 +362,8 @@ class LiteralIncludeReader:
     def prepend_filter(self, lines: List[str], location: Tuple[str, int] = None) -> List[str]:
         prepend = self.options.get('prepend')
         if prepend:
+            # Preserve the original whitespace in the prepended text
+            # Add the prepend text exactly as it is, including any leading whitespace
             lines.insert(0, prepend + '\n')
 
         return lines
@@ -350,13 +371,57 @@ class LiteralIncludeReader:
     def append_filter(self, lines: List[str], location: Tuple[str, int] = None) -> List[str]:
         append = self.options.get('append')
         if append:
+            # Preserve the original whitespace in the appended text
             lines.append(append + '\n')
 
         return lines
 
     def dedent_filter(self, lines: List[str], location: Tuple[str, int] = None) -> List[str]:
         if 'dedent' in self.options:
-            return dedent_lines(lines, self.options.get('dedent'), location=location)
+            # Only apply dedent to lines that aren't prepended/appended
+            # We'll need to track if we've already applied prepend/append
+            has_prepend = 'prepend' in self.options and self.options['prepend']
+            has_append = 'append' in self.options and self.options['append']
+
+            if has_prepend or has_append:
+                # Create a copy of lines without the prepended/appended lines
+                content_lines = lines[1:] if has_prepend else lines[:-1] if has_append else lines
+
+                # Apply dedent only to the content lines
+                if content_lines:
+                    # For prepended/appended lines, we need to handle them specially
+                    # to avoid warnings about non-whitespace being stripped
+
+                    # First, get the dedent value
+                    dedent_val = self.options.get('dedent')
+
+                    # Create a new list for the dedented content
+                    dedented_content = []
+
+                    # For each line in the content (not prepend/append)
+                    for line in content_lines:
+                        # Only dedent if the line is long enough
+                        if len(line) > dedent_val:
+                            dedented_line = line[dedent_val:]
+                            if line.endswith('\n') and not dedented_line:
+                                dedented_line = '\n'  # keep CRLF
+                            dedented_content.append(dedented_line)
+                        else:
+                            # Line is too short to dedent, keep as is
+                            dedented_content.append(line)
+
+                    # Reconstruct the full lines list
+                    if has_prepend and has_append:
+                        return [lines[0]] + dedented_content + [lines[-1]]
+                    elif has_prepend:
+                        return [lines[0]] + dedented_content
+                    else:  # has_append
+                        return dedented_content + [lines[-1]]
+                else:
+                    return lines
+            else:
+                # No prepend/append, dedent all lines
+                return dedent_lines(lines, self.options.get('dedent'), location=location)
         else:
             return lines
 
diff --git a/test_literalinclude_indent.py b/test_literalinclude_indent.py
new file mode 100755
index 000000000..5971003eb
--- /dev/null
+++ b/test_literalinclude_indent.py
@@ -0,0 +1,154 @@
+#!/usr/bin/env python3
+import os
+import tempfile
+import sys
+from pathlib import Path
+
+# Create test files
+def create_test_files():
+    # Create a temporary directory
+    temp_dir = tempfile.mkdtemp()
+
+    # Create pom.xml
+    pom_content = """<?xml version="1.0" encoding="UTF-8"?>
+<project>
+  <build>
+    <plugins>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-compiler-plugin</artifactId>
+        <version>3.8.0</version>
+        <configuration>
+          <source>1.8</source>
+          <target>1.8</target>
+          <debug>true</debug>
+          <encoding>UTF-8</encoding>
+        </configuration>
+      </plugin>
+      <plugin>
+        <groupId>com.github.ekryd.sortpom</groupId>
+        <artifactId>sortpom-maven-plugin</artifactId>
+        <version>2.15.0</version>
+        <configuration>
+          <verifyFailOn>strict</verifyFailOn>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
+</project>"""
+
+    pom_path = os.path.join(temp_dir, "pom.xml")
+    with open(pom_path, "w") as f:
+        f.write(pom_content)
+
+    # Create index.rst
+    rst_content = """# hello world
+
+Code examples:
+
+.. literalinclude:: pom.xml
+   :language: xml
+   :prepend: _____</plugin>
+   :start-at: <groupId>com.github.ekryd.sortpom</groupId>
+   :end-at: </plugin>
+   :dedent: 5
+
+Expected output should have the </plugin> tag indented to match the rest of the XML structure.
+"""
+
+    rst_path = os.path.join(temp_dir, "index.rst")
+    with open(rst_path, "w") as f:
+        f.write(rst_content)
+
+    # Create conf.py
+    conf_content = """#
+# A basic Sphinx configuration file.
+#
+
+import os
+import sys
+sys.path.insert(0, os.path.abspath('.'))
+
+# -- General configuration ------------------------------------------------
+
+extensions = [
+    'sphinx.ext.todo',
+    'sphinx.ext.extlinks',
+]
+
+templates_path = ['_templates']
+exclude_patterns = []
+
+language = 'en'
+source_suffix = '.rst'
+master_doc = 'index'
+
+# -- Options for HTML output ----------------------------------------------
+
+html_theme = 'alabaster'
+html_static_path = ['_static']
+"""
+
+    conf_path = os.path.join(temp_dir, "conf.py")
+    with open(conf_path, "w") as f:
+        f.write(conf_content)
+
+    return temp_dir, pom_path, rst_path
+
+def build_docs(temp_dir):
+    """Build the documentation using Sphinx."""
+    import subprocess
+
+    # Run sphinx-build
+    cmd = [
+        sys.executable,
+        "-m", "sphinx",
+        "-M", "html",
+        temp_dir,
+        os.path.join(temp_dir, "_build")
+    ]
+
+    result = subprocess.run(cmd, capture_output=True, text=True)
+
+    # Print the output
+    print("STDOUT:", result.stdout)
+    print("STDERR:", result.stderr)
+
+    # Check for warnings about dedent
+    if "non-whitespace stripped by dedent" in result.stderr:
+        print("WARNING: Dedent warning found in output")
+
+    # Return the build directory
+    return os.path.join(temp_dir, "_build", "html")
+
+def main():
+    temp_dir, pom_path, rst_path = create_test_files()
+    print(f"Created test files in {temp_dir}")
+
+    # Build the documentation
+    build_dir = build_docs(temp_dir)
+    print(f"Built documentation in {build_dir}")
+
+    # Check the output
+    output_path = os.path.join(build_dir, "index.html")
+    if os.path.exists(output_path):
+        print(f"Output file created: {output_path}")
+        # Extract the content from the HTML file to see the result
+        with open(output_path, 'r') as f:
+            content = f.read()
+            # Find the code block with the XML content
+            import re
+            match = re.search(r'<pre>.*?</pre>', content, re.DOTALL)
+            if match:
+                print("\nExtracted code block from HTML (raw):")
+                print(match.group(0))
+
+                # Also extract the text content by removing HTML tags
+                text_content = re.sub(r'<[^>]*>', '', match.group(0))
+                print("\nExtracted text content:")
+                print(text_content)
+    else:
+        print(f"Output file not found: {output_path}")
+
+if __name__ == "__main__":
+    main()
\ No newline at end of file
diff --git a/tox.ini b/tox.ini
index f0afd779b..30ca90275 100644
--- a/tox.ini
+++ b/tox.ini
@@ -28,7 +28,7 @@ setenv =
     PYTHONWARNINGS = all
     PYTEST_ADDOPTS = {env:PYTEST_ADDOPTS:} --color yes
 commands=
-    python -X dev -m pytest --durations 25 {posargs}
+    python -X dev -m pytest -rA --durations 25 {posargs}
 
 [testenv:du-latest]
 commands =
