diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py
index 4648daf395..872351caff 100644
--- a/django/db/models/sql/query.py
+++ b/django/db/models/sql/query.py
@@ -1077,10 +1077,16 @@ class Query(BaseExpression):
         elif isinstance(value, (list, tuple)):
             # The items of the iterable may be expressions and therefore need
             # to be resolved independently.
-            return type(value)(
+            resolved_values = [
                 self.resolve_lookup_value(sub_value, can_reuse, allow_joins)
                 for sub_value in value
-            )
+            ]
+            # Handle lists and tuples differently
+            if isinstance(value, list):
+                return resolved_values
+            else:
+                # Use * to expand the contents when reconstructing the tuple
+                return type(value)(*resolved_values)
         return value
 
     def solve_lookup_type(self, lookup):
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100755
index 0000000000..3ec316e7d3
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,35 @@
+#!/usr/bin/env python
+from collections import namedtuple
+from django.db.models.sql.query import Query
+
+# Create a named tuple
+NamedTuple = namedtuple('NamedTuple', ['near', 'far'])
+test_tuple = NamedTuple(near=1, far=10)
+
+# Create a list
+test_list = [1, 10]
+
+# Create a mock Query class to test the resolve_lookup_value method
+class MockQuery(Query):
+    def __init__(self):
+        super().__init__(None)
+
+    def resolve_expression(self, *args, **kwargs):
+        # Mock method to avoid errors
+        return args[0]
+
+# Test with a named tuple
+query = MockQuery()
+try:
+    result = query.resolve_lookup_value(test_tuple, can_reuse=True, allow_joins=True)
+    print(f"Success with named tuple! Result: {result}")
+except TypeError as e:
+    print(f"Error with named tuple: {e}")
+    print("This reproduces the issue described in the ticket.")
+
+# Test with a list
+try:
+    result = query.resolve_lookup_value(test_list, can_reuse=True, allow_joins=True)
+    print(f"Success with list! Result: {result}")
+except TypeError as e:
+    print(f"Error with list: {e}")
\ No newline at end of file
diff --git a/test_namedtuple_range.py b/test_namedtuple_range.py
new file mode 100755
index 0000000000..ba2aa1d49e
--- /dev/null
+++ b/test_namedtuple_range.py
@@ -0,0 +1,34 @@
+#!/usr/bin/env python
+from collections import namedtuple
+from django.db.models import Q
+from django.db.models.sql.query import Query
+
+# Create a named tuple for range
+RangeTuple = namedtuple('RangeTuple', ['start', 'end'])
+range_tuple = RangeTuple(start=1, end=10)
+
+# Create a mock Query class to test the resolve_lookup_value method
+class MockQuery(Query):
+    def __init__(self):
+        super().__init__(None)
+
+    def resolve_expression(self, *args, **kwargs):
+        # Mock method to avoid errors
+        return args[0]
+
+# Test with a named tuple as a range argument
+query = MockQuery()
+try:
+    # Simulate using the named tuple in a range filter
+    # This would be something like: Model.objects.filter(value__range=range_tuple)
+    result = query.resolve_lookup_value(range_tuple, can_reuse=True, allow_joins=True)
+    print(f"Success! Named tuple range works: {result}")
+
+    # Test with a Q object containing a range
+    q_object = Q(value__range=range_tuple)
+    # This would trigger resolve_lookup_value for the range tuple
+    print("Q object with named tuple range created successfully")
+
+except TypeError as e:
+    print(f"Error: {e}")
+    print("The issue is still present.")
\ No newline at end of file
