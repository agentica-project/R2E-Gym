diff --git a/django/contrib/auth/base_user.py b/django/contrib/auth/base_user.py
index 5ee30bf59c..0eb286f35c 100644
--- a/django/contrib/auth/base_user.py
+++ b/django/contrib/auth/base_user.py
@@ -134,11 +134,27 @@ class AbstractBaseUser(models.Model):
     def get_session_auth_hash(self):
         """
         Return an HMAC of the password field.
+
+        If SECRET_KEY_FALLBACKS is set, the first key in the list is used.
+        If SECRET_KEY_FALLBACKS is empty, the current SECRET_KEY is used.
         """
+        from django.conf import settings
+
         key_salt = "django.contrib.auth.models.AbstractBaseUser.get_session_auth_hash"
+
+        # Determine which secret to use
+        if settings.SECRET_KEY_FALLBACKS:
+            # Use the first key in SECRET_KEY_FALLBACKS
+            secret = settings.SECRET_KEY_FALLBACKS[0]
+        else:
+            # Fall back to SECRET_KEY if no fallbacks are configured
+            secret = settings.SECRET_KEY
+
+        # Generate the HMAC using the chosen secret
         return salted_hmac(
             key_salt,
             self.password,
+            secret=secret,
             algorithm="sha256",
         ).hexdigest()
 
diff --git a/test_secret_key_fallbacks.py b/test_secret_key_fallbacks.py
new file mode 100644
index 0000000000..270863bd54
--- /dev/null
+++ b/test_secret_key_fallbacks.py
@@ -0,0 +1,109 @@
+import os
+import django
+from django.conf import settings
+from django.contrib.auth import get_user_model
+from django.contrib.auth.hashers import make_password
+from django.utils.crypto import salted_hmac
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+        ],
+        SECRET_KEY='new-secret-key',
+        SECRET_KEY_FALLBACKS=['old-secret-key'],
+        MIDDLEWARE=[],
+    )
+    django.setup()
+
+# Get the user model
+User = get_user_model()
+
+def test_session_auth_hash_with_fallbacks():
+    """
+    Test that session auth hash uses SECRET_KEY_FALLBACKS.
+    """
+    # Create a user with a password
+    password = 'testpassword'
+    user = User(
+        username='testuser',
+        password=make_password(password)
+    )
+
+    # Get the session auth hash using the user's get_session_auth_hash method
+    # This should now use the first key in SECRET_KEY_FALLBACKS
+    user_hash = user.get_session_auth_hash()
+
+    # Get the session auth hash using the first fallback key directly
+    key_salt = "django.contrib.auth.models.AbstractBaseUser.get_session_auth_hash"
+    fallback_hash = salted_hmac(
+        key_salt,
+        user.password,
+        secret=settings.SECRET_KEY_FALLBACKS[0],
+        algorithm="sha256",
+    ).hexdigest()
+
+    # Get the session auth hash using the current SECRET_KEY directly
+    current_hash = salted_hmac(
+        key_salt,
+        user.password,
+        algorithm="sha256",
+    ).hexdigest()
+
+    # With our fix, the user_hash should match the fallback_hash
+    # because we're using the first key in SECRET_KEY_FALLBACKS
+    print("=== Test with SECRET_KEY_FALLBACKS configured ===")
+    print(f"User hash (should use fallback): {user_hash}")
+    print(f"Fallback hash: {fallback_hash}")
+    print(f"Current hash (should NOT be used): {current_hash}")
+    print(f"Does user hash match fallback? {user_hash == fallback_hash}")
+    print(f"Does user hash match current? {user_hash == current_hash}")
+
+    # Now test with SECRET_KEY_FALLBACKS empty
+    print("\n=== Test with SECRET_KEY_FALLBACKS empty ===")
+    # Save the original SECRET_KEY_FALLBACKS
+    original_fallbacks = settings.SECRET_KEY_FALLBACKS
+    # Set SECRET_KEY_FALLBACKS to an empty list
+    settings.SECRET_KEY_FALLBACKS = []
+
+    # Create a new user for this test
+    user2 = User(
+        username='testuser2',
+        password=make_password(password)
+    )
+
+    # Get the session auth hash using the user's get_session_auth_hash method
+    # This should now use the current SECRET_KEY since there are no fallbacks
+    user2_hash = user2.get_session_auth_hash()
+
+    # Get the session auth hash using the current SECRET_KEY directly
+    current_hash2 = salted_hmac(
+        key_salt,
+        user2.password,
+        algorithm="sha256",
+    ).hexdigest()
+
+    # With our fix, the user2_hash should match the current_hash2
+    # because we're using the current SECRET_KEY
+    print(f"User2 hash: {user2_hash}")
+    print(f"Current hash: {current_hash2}")
+    print(f"Does user2 hash match current? {user2_hash == current_hash2}")
+
+    # Restore the original SECRET_KEY_FALLBACKS
+    settings.SECRET_KEY_FALLBACKS = original_fallbacks
+
+    print("\nThis demonstrates that our fix works correctly:")
+    print("1. When SECRET_KEY_FALLBACKS is configured, it uses the first key in the list")
+    print("2. When SECRET_KEY_FALLBACKS is empty, it falls back to the current SECRET_KEY")
+
+if __name__ == '__main__':
+    test_session_auth_hash_with_fallbacks()
\ No newline at end of file
