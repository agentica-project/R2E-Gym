diff --git a/django/contrib/auth/checks.py b/django/contrib/auth/checks.py
index 65fc266f7e..3b1d3ebc49 100644
--- a/django/contrib/auth/checks.py
+++ b/django/contrib/auth/checks.py
@@ -52,7 +52,15 @@ def check_user_model(app_configs=None, **kwargs):
         )
 
     # Check that the username field is unique
-    if not cls._meta.get_field(cls.USERNAME_FIELD).unique:
+    username_field = cls._meta.get_field(cls.USERNAME_FIELD)
+    # Check if there's a UniqueConstraint that includes the USERNAME_FIELD
+    has_unique_constraint = False
+    for constraint in cls._meta.constraints:
+        if hasattr(constraint, 'fields') and cls.USERNAME_FIELD in constraint.fields:
+            has_unique_constraint = True
+            break
+
+    if not username_field.unique and not has_unique_constraint:
         if (settings.AUTHENTICATION_BACKENDS ==
                 ['django.contrib.auth.backends.ModelBackend']):
             errors.append(
diff --git a/inspect_meta.py b/inspect_meta.py
new file mode 100644
index 0000000000..e977b1288a
--- /dev/null
+++ b/inspect_meta.py
@@ -0,0 +1,54 @@
+import os
+import sys
+import django
+from django.conf import settings
+from django.apps import apps
+
+# Configure settings
+if not settings.configured:
+    settings.configure(
+        INSTALLED_APPS=[
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+            'inspect_meta',  # Add our app
+        ],
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+    )
+    django.setup()
+
+# Register our app
+class InspectMetaConfig(django.apps.AppConfig):
+    name = 'inspect_meta'
+
+apps.register(InspectMetaConfig)
+
+from django.db import models
+from django.db.models import UniqueConstraint
+
+# Create a simple model
+class TestModel(models.Model):
+    name = models.CharField(max_length=100)
+    email = models.EmailField(unique=True)
+
+    class Meta:
+        app_label = 'inspect_meta'  # Set the app label
+        constraints = [
+            UniqueConstraint(fields=['name'], name='unique_name')
+        ]
+
+# Inspect the model's meta
+print("Model fields:")
+for field_name, field in TestModel._meta.get_fields().items():
+    if hasattr(field, 'unique'):
+        print(f"  {field_name}: unique={field.unique}")
+
+print("\nModel constraints:")
+for constraint in TestModel._meta.constraints:
+    print(f"  {constraint}")
+    if hasattr(constraint, 'fields'):
+        print(f"    fields: {constraint.fields}")
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..f842223741
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,41 @@
+import os
+import django
+from django.conf import settings
+
+# Configure settings
+if not settings.configured:
+    settings.configure(
+        INSTALLED_APPS=[
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+        ],
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        AUTHENTICATION_BACKENDS=['django.contrib.auth.backends.ModelBackend'],
+    )
+    django.setup()
+
+from django.contrib.auth.models import AbstractBaseUser
+from django.db import models
+from django.core import checks
+from django.db.models import UniqueConstraint
+
+class User(AbstractBaseUser):
+    username = models.CharField(max_length=30)
+    USERNAME_FIELD = "username"
+    class Meta:
+        constraints = [UniqueConstraint(fields=["username"], name="user_username_unq")]
+
+# Run the check
+from django.contrib.auth.checks import check_user_model
+
+# Override the AUTH_USER_MODEL for this test
+from django.test.utils import modify_settings
+with modify_settings(AUTH_USER_MODEL={'value': 'User'}):
+    errors = check_user_model()
+    for error in errors:
+        print(f"Error: {error}")
\ No newline at end of file
diff --git a/simple_test.py b/simple_test.py
new file mode 100644
index 0000000000..8d3cc8803c
--- /dev/null
+++ b/simple_test.py
@@ -0,0 +1,53 @@
+import django
+from django.conf import settings
+from django.db import models
+from django.db.models import UniqueConstraint
+from django.contrib.auth.models import AbstractBaseUser
+
+# Configure settings
+if not settings.configured:
+    settings.configure(
+        INSTALLED_APPS=[
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+        ],
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+    )
+    django.setup()
+
+# Create a model with a UniqueConstraint on the USERNAME_FIELD
+class User(AbstractBaseUser):
+    username = models.CharField(max_length=30)
+    USERNAME_FIELD = "username"
+    class Meta:
+        constraints = [UniqueConstraint(fields=["username"], name="user_username_unq")]
+
+# Check if the field is in any UniqueConstraint
+username_field = User._meta.get_field("username")
+print(f"Field unique attribute: {username_field.unique}")
+
+# Check for UniqueConstraint on the username field
+has_unique_constraint = False
+for constraint in User._meta.constraints:
+    if isinstance(constraint, UniqueConstraint) and "username" in constraint.fields:
+        has_unique_constraint = True
+        print(f"Found UniqueConstraint: {constraint}")
+
+print(f"Has unique constraint: {has_unique_constraint}")
+
+# Current check logic (from auth/checks.py)
+if not username_field.unique:
+    print("Current check would fail with: auth.E003")
+else:
+    print("Current check would pass")
+
+# Proposed check logic
+if not username_field.unique and not has_unique_constraint:
+    print("Proposed check would fail with: auth.E003")
+else:
+    print("Proposed check would pass")
\ No newline at end of file
diff --git a/test_fix.py b/test_fix.py
new file mode 100644
index 0000000000..1e74851559
--- /dev/null
+++ b/test_fix.py
@@ -0,0 +1,61 @@
+"""
+Test script to verify the fix for auth.E003 system check with UniqueConstraint.
+"""
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        INSTALLED_APPS=[
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+        ],
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+    )
+    django.setup()
+
+from django.db import models
+from django.db.models import UniqueConstraint
+from django.contrib.auth.models import AbstractBaseUser
+
+# Define a user model with a UniqueConstraint on the USERNAME_FIELD
+class UserWithUniqueConstraint(AbstractBaseUser):
+    username = models.CharField(max_length=30)
+    USERNAME_FIELD = "username"
+
+    class Meta:
+        constraints = [UniqueConstraint(fields=["username"], name="user_username_unq")]
+
+# Define a user model without any uniqueness constraint on the USERNAME_FIELD
+class UserWithoutUniqueConstraint(AbstractBaseUser):
+    username = models.CharField(max_length=30)
+    USERNAME_FIELD = "username"
+
+# Function to check if a model has a unique constraint on the USERNAME_FIELD
+def has_unique_constraint_for_username(model):
+    """Check if the model has a unique constraint on the USERNAME_FIELD."""
+    username_field = model.USERNAME_FIELD
+    for constraint in model._meta.constraints:
+        if isinstance(constraint, UniqueConstraint) and username_field in constraint.fields:
+            return True
+    return False
+
+# Test our function
+print("UserWithUniqueConstraint has unique constraint:", has_unique_constraint_for_username(UserWithUniqueConstraint))
+print("UserWithoutUniqueConstraint has unique constraint:", has_unique_constraint_for_username(UserWithoutUniqueConstraint))
+
+# Test the current check logic
+print("\nCurrent check logic:")
+print("UserWithUniqueConstraint (should fail):", not UserWithUniqueConstraint._meta.get_field("username").unique)
+print("UserWithoutUniqueConstraint (should fail):", not UserWithoutUniqueConstraint._meta.get_field("username").unique)
+
+# Test the proposed check logic
+print("\nProposed check logic:")
+print("UserWithUniqueConstraint (should pass):", not UserWithUniqueConstraint._meta.get_field("username").unique and not has_unique_constraint_for_username(UserWithUniqueConstraint))
+print("UserWithoutUniqueConstraint (should fail):", not UserWithoutUniqueConstraint._meta.get_field("username").unique and not has_unique_constraint_for_username(UserWithoutUniqueConstraint))
\ No newline at end of file
diff --git a/test_logic.py b/test_logic.py
new file mode 100644
index 0000000000..e8984aee8e
--- /dev/null
+++ b/test_logic.py
@@ -0,0 +1,73 @@
+"""
+Test script to verify the logic of our fix.
+"""
+# Mock classes to simulate the model and its meta
+class MockConstraint:
+    def __init__(self, fields):
+        self.fields = fields
+
+class MockMeta:
+    def __init__(self, object_name, constraints=[]):
+        self.object_name = object_name
+        self.constraints = constraints
+
+class MockField:
+    def __init__(self, unique=False):
+        self.unique = unique
+
+class MockModel:
+    def __init__(self, username_field_unique=False, has_unique_constraint=False):
+        self._meta = MockMeta(
+            object_name="MockUser",
+            constraints=[] if not has_unique_constraint else [MockConstraint(['username'])]
+        )
+        self.USERNAME_FIELD = "username"
+        self._meta.get_field = lambda field_name: MockField(unique=username_field_unique)
+
+# The logic we modified
+def check_username_uniqueness(model):
+    """Check if the USERNAME_FIELD is unique (either via unique=True or UniqueConstraint)."""
+    username_field = model._meta.get_field(model.USERNAME_FIELD)
+
+    # Check if there's a UniqueConstraint that includes the USERNAME_FIELD
+    has_unique_constraint = False
+    for constraint in model._meta.constraints:
+        if hasattr(constraint, 'fields') and model.USERNAME_FIELD in constraint.fields:
+            has_unique_constraint = True
+            break
+
+    # The check condition
+    is_unique = username_field.unique or has_unique_constraint
+    return is_unique
+
+# Test cases
+test_cases = [
+    {
+        "name": "No uniqueness (should be False)",
+        "model": MockModel(username_field_unique=False, has_unique_constraint=False),
+        "expected": False
+    },
+    {
+        "name": "Field unique=True (should be True)",
+        "model": MockModel(username_field_unique=True, has_unique_constraint=False),
+        "expected": True
+    },
+    {
+        "name": "UniqueConstraint (should be True)",
+        "model": MockModel(username_field_unique=False, has_unique_constraint=True),
+        "expected": True
+    },
+    {
+        "name": "Both unique=True and UniqueConstraint (should be True)",
+        "model": MockModel(username_field_unique=True, has_unique_constraint=True),
+        "expected": True
+    }
+]
+
+# Run the tests
+for case in test_cases:
+    result = check_username_uniqueness(case["model"])
+    if result == case["expected"]:
+        print(f"PASS: {case['name']}")
+    else:
+        print(f"FAIL: {case['name']} (got {result}, expected {case['expected']})")
diff --git a/verify_fix.py b/verify_fix.py
new file mode 100644
index 0000000000..83ee747cf7
--- /dev/null
+++ b/verify_fix.py
@@ -0,0 +1,81 @@
+"""
+Script to verify the fix for auth.E003 system check with UniqueConstraint.
+"""
+import os
+import sys
+import django
+from django.conf import settings
+from django.db import models
+from django.db.models import UniqueConstraint
+from django.core import checks
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        INSTALLED_APPS=[
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+        ],
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        AUTHENTICATION_BACKENDS=['django.contrib.auth.backends.ModelBackend'],
+    )
+    django.setup()
+
+# Create a custom app config for our test models
+class TestConfig(django.apps.AppConfig):
+    name = 'test_app'
+
+# Register our app
+django.apps.apps.register(TestConfig)
+
+# Define a user model with a UniqueConstraint on the USERNAME_FIELD
+class UserWithUniqueConstraint(models.Model):
+    username = models.CharField(max_length=30)
+    USERNAME_FIELD = "username"
+
+    class Meta:
+        app_label = 'test_app'
+        constraints = [UniqueConstraint(fields=["username"], name="user_username_unq")]
+
+# Define a user model without any uniqueness constraint on the USERNAME_FIELD
+class UserWithoutUniqueConstraint(models.Model):
+    username = models.CharField(max_length=30)
+    USERNAME_FIELD = "username"
+
+    class Meta:
+        app_label = 'test_app'
+
+# Import the check function after our models are defined
+from django.contrib.auth.checks import check_user_model
+
+# Test with UserWithUniqueConstraint
+print("Testing UserWithUniqueConstraint:")
+# Override AUTH_USER_MODEL for this test
+original_auth_user_model = settings.AUTH_USER_MODEL
+settings.AUTH_USER_MODEL = 'test_app.UserWithUniqueConstraint'
+errors = check_user_model()
+settings.AUTH_USER_MODEL = original_auth_user_model
+
+if errors:
+    for error in errors:
+        print(f"  Error: {error}")
+else:
+    print("  No errors - Fix works correctly!")
+
+# Test with UserWithoutUniqueConstraint
+print("\nTesting UserWithoutUniqueConstraint:")
+# Override AUTH_USER_MODEL for this test
+settings.AUTH_USER_MODEL = 'test_app.UserWithoutUniqueConstraint'
+errors = check_user_model()
+settings.AUTH_USER_MODEL = original_auth_user_model
+
+if errors:
+    for error in errors:
+        print(f"  Error: {error}")
+else:
+    print("  No errors - This is unexpected!")
\ No newline at end of file
diff --git a/verify_fix_simple.py b/verify_fix_simple.py
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/verify_fix_test.py b/verify_fix_test.py
new file mode 100644
index 0000000000..e69de29bb2
