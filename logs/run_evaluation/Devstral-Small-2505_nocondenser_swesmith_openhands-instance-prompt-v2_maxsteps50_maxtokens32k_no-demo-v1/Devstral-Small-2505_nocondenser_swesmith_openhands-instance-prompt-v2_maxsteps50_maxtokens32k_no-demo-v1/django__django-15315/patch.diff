diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py
index 88c9ca9f28..fcea1597ef 100644
--- a/django/db/models/fields/__init__.py
+++ b/django/db/models/fields/__init__.py
@@ -542,11 +542,7 @@ class Field(RegisterLookupMixin):
         return NotImplemented
 
     def __hash__(self):
-        return hash((
-            self.creation_counter,
-            self.model._meta.app_label if hasattr(self, 'model') else None,
-            self.model._meta.model_name if hasattr(self, 'model') else None,
-        ))
+        return hash(self.creation_counter)
 
     def __deepcopy__(self, memodict):
         # We don't have to deepcopy very much here, since most things are not
diff --git a/reproduce_hash_issue.py b/reproduce_hash_issue.py
new file mode 100644
index 0000000000..34752b9358
--- /dev/null
+++ b/reproduce_hash_issue.py
@@ -0,0 +1,44 @@
+import os
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        INSTALLED_APPS=[
+            'django.db.models',
+        ],
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        }
+    )
+    django.setup()
+
+from django.db import models
+
+# Create a field
+f = models.CharField(max_length=200)
+
+# Store the initial hash value
+initial_hash = hash(f)
+
+# Use the field as a key in a dictionary
+d = {f: 1}
+
+# Define a model that uses the field
+class Book(models.Model):
+    class Meta:
+        app_label = 'test_app'
+    title = f
+
+# Try to access the field in the dictionary - this should work but will fail
+try:
+    assert f in d
+    print("SUCCESS: Field is still in the dictionary after being assigned to a model")
+except AssertionError:
+    print("FAILURE: Field is no longer in the dictionary after being assigned to a model")
+    print(f"Hash before model assignment: {initial_hash}")
+    print(f"Hash after model assignment: {hash(f)}")
\ No newline at end of file
diff --git a/test_field_hash_fix.py b/test_field_hash_fix.py
new file mode 100644
index 0000000000..bfe45bfdeb
--- /dev/null
+++ b/test_field_hash_fix.py
@@ -0,0 +1,72 @@
+import os
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        INSTALLED_APPS=[
+            'django.db.models',
+        ],
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        }
+    )
+    django.setup()
+
+from django.db import models
+import unittest
+
+class TestFieldHashImmutability(unittest.TestCase):
+    def test_field_hash_does_not_change_when_assigned_to_model(self):
+        """Test that a field's hash doesn't change when assigned to a model."""
+        # Create a field
+        f = models.CharField(max_length=200)
+
+        # Store the initial hash value
+        initial_hash = hash(f)
+
+        # Use the field as a key in a dictionary
+        d = {f: 1}
+
+        # Define a model that uses the field
+        class Book(models.Model):
+            class Meta:
+                app_label = 'test_app'
+            title = f
+
+        # The hash should not have changed
+        self.assertEqual(hash(f), initial_hash)
+
+        # The field should still be in the dictionary
+        self.assertIn(f, d)
+
+    def test_field_equality(self):
+        """Test that field equality still works correctly."""
+        # Create two fields
+        f1 = models.CharField(max_length=200)
+        f2 = models.CharField(max_length=200)
+
+        # They should be equal if they're the same object
+        self.assertEqual(f1, f1)
+        self.assertNotEqual(f1, f2)
+
+        # Define two models that use the fields
+        class Book1(models.Model):
+            class Meta:
+                app_label = 'test_app'
+            title = f1
+
+        class Book2(models.Model):
+            class Meta:
+                app_label = 'test_app'
+            title = f2
+
+        # Fields from different models should not be equal
+        self.assertNotEqual(Book1._meta.get_field('title'), Book2._meta.get_field('title'))
+
+if __name__ == '__main__':
+    unittest.main()
\ No newline at end of file
