diff --git a/django/db/models/fields/json.py b/django/db/models/fields/json.py
index fdca700c9d..2eb4b01177 100644
--- a/django/db/models/fields/json.py
+++ b/django/db/models/fields/json.py
@@ -131,11 +131,12 @@ def compile_json_path(key_transforms, include_root=True):
     for key_transform in key_transforms:
         try:
             num = int(key_transform)
+            # For numeric keys, always use the array notation
+            path.append("[%s]" % num)
         except ValueError:  # non-integer
+            # For string keys, use the dot notation
             path.append(".")
             path.append(json.dumps(key_transform))
-        else:
-            path.append("[%s]" % num)
     return "".join(path)
 
 
@@ -183,40 +184,142 @@ class HasKeyLookup(PostgresOperatorLookup):
             lhs, lhs_params = self.process_lhs(compiler, connection)
             lhs_json_path = "$"
         sql = template % lhs
+
         # Process JSON path from the right-hand side.
         rhs = self.rhs
         rhs_params = []
+
         if not isinstance(rhs, (list, tuple)):
             rhs = [rhs]
+
         for key in rhs:
             if isinstance(key, KeyTransform):
                 *_, rhs_key_transforms = key.preprocess_lhs(compiler, connection)
             else:
-                rhs_key_transforms = [key]
-            rhs_params.append(
-                "%s%s"
-                % (
-                    lhs_json_path,
-                    compile_json_path(rhs_key_transforms, include_root=False),
+                # Special handling for numeric keys
+                try:
+                    int(key)  # Check if the key is numeric
+                    # For numeric keys, use array notation directly
+                    rhs_key_transforms = [key]
+                except ValueError:
+                    rhs_key_transforms = [key]
+
+            # For SQLite, MySQL, and Oracle, we need to handle numeric keys differently
+            if connection.vendor in ('sqlite', 'mysql', 'oracle'):
+                if isinstance(key, str):
+                    try:
+                        int(key)  # Check if the key is numeric
+                        # For numeric keys, use array notation directly in the path
+                        rhs_params.append("$[%s]" % key)
+                    except ValueError:
+                        # For string keys, use the standard path format
+                        rhs_params.append(
+                            "%s%s"
+                            % (
+                                lhs_json_path,
+                                compile_json_path(rhs_key_transforms, include_root=False),
+                            )
+                        )
+                else:
+                    rhs_params.append(
+                        "%s%s"
+                        % (
+                            lhs_json_path,
+                            compile_json_path(rhs_key_transforms, include_root=False),
+                        )
+                    )
+            else:
+                # For other databases (like PostgreSQL), use the standard approach
+                rhs_params.append(
+                    "%s%s"
+                    % (
+                        lhs_json_path,
+                        compile_json_path(rhs_key_transforms, include_root=False),
+                    )
                 )
-            )
+
         # Add condition for each key.
         if self.logical_operator:
             sql = "(%s)" % self.logical_operator.join([sql] * len(rhs_params))
         return sql, tuple(lhs_params) + tuple(rhs_params)
 
     def as_mysql(self, compiler, connection):
-        return self.as_sql(
-            compiler, connection, template="JSON_CONTAINS_PATH(%s, 'one', %%s)"
-        )
+        # For MySQL, handle numeric keys differently
+        if isinstance(self.rhs, (list, tuple)):
+            rhs = self.rhs
+        else:
+            rhs = [self.rhs]
+
+        conditions = []
+        for key in rhs:
+            lhs, lhs_params = self.process_lhs(compiler, connection)
+
+            # Handle numeric keys (both string and integer representations)
+            if isinstance(key, str):
+                try:
+                    # If the key looks like a number, handle both string and integer representations
+                    int_key = int(key)
+                    # Add conditions for both string and integer representations of the key
+                    conditions.append("JSON_EXTRACT(%s, '$[%s]') IS NOT NULL" % (lhs, int_key))
+                    conditions.append("JSON_CONTAINS_PATH(%s, 'one', '$.%s')" % (lhs, key))
+                except ValueError:
+                    # For non-numeric keys, use the standard approach
+                    conditions.append("JSON_CONTAINS_PATH(%s, 'one', '$.%s')" % (lhs, key))
+            elif isinstance(key, int):
+                # For integer keys, handle both string and integer representations
+                conditions.append("JSON_EXTRACT(%s, '$[%s]') IS NOT NULL" % (lhs, key))
+                conditions.append("JSON_CONTAINS_PATH(%s, 'one', '$.%s')" % (lhs, str(key)))
+            else:
+                # For other types, use the standard approach
+                conditions.append("JSON_CONTAINS_PATH(%s, 'one', '$.%s')" % (lhs, key))
+
+        if len(conditions) == 1:
+            return conditions[0], []
+        else:
+            # Join conditions with OR for numeric keys (since we want to match either representation)
+            if self.logical_operator:
+                sql = "(%s)" % self.logical_operator.join(conditions)
+                return sql, []
+            return " OR ".join(conditions), []
 
     def as_oracle(self, compiler, connection):
-        sql, params = self.as_sql(
-            compiler, connection, template="JSON_EXISTS(%s, '%%s')"
-        )
-        # Add paths directly into SQL because path expressions cannot be passed
-        # as bind variables on Oracle.
-        return sql % tuple(params), []
+        # For Oracle, handle numeric keys differently
+        if isinstance(self.rhs, (list, tuple)):
+            rhs = self.rhs
+        else:
+            rhs = [self.rhs]
+
+        conditions = []
+        for key in rhs:
+            lhs, lhs_params = self.process_lhs(compiler, connection)
+
+            # Handle numeric keys (both string and integer representations)
+            if isinstance(key, str):
+                try:
+                    # If the key looks like a number, handle both string and integer representations
+                    int_key = int(key)
+                    # Add conditions for both string and integer representations of the key
+                    conditions.append("JSON_EXISTS(%s, '$[%s]')" % (lhs, int_key))
+                    conditions.append("JSON_EXISTS(%s, '$.%s')" % (lhs, key))
+                except ValueError:
+                    # For non-numeric keys, use the standard approach
+                    conditions.append("JSON_EXISTS(%s, '$.%s')" % (lhs, key))
+            elif isinstance(key, int):
+                # For integer keys, handle both string and integer representations
+                conditions.append("JSON_EXISTS(%s, '$[%s]')" % (lhs, key))
+                conditions.append("JSON_EXISTS(%s, '$.%s')" % (lhs, str(key)))
+            else:
+                # For other types, use the standard approach
+                conditions.append("JSON_EXISTS(%s, '$.%s')" % (lhs, key))
+
+        if len(conditions) == 1:
+            return conditions[0], []
+        else:
+            # Join conditions with OR for numeric keys (since we want to match either representation)
+            if self.logical_operator:
+                sql = "(%s)" % self.logical_operator.join(conditions)
+                return sql, []
+            return " OR ".join(conditions), []
 
     def as_postgresql(self, compiler, connection):
         if isinstance(self.rhs, KeyTransform):
@@ -227,9 +330,43 @@ class HasKeyLookup(PostgresOperatorLookup):
         return super().as_postgresql(compiler, connection)
 
     def as_sqlite(self, compiler, connection):
-        return self.as_sql(
-            compiler, connection, template="JSON_TYPE(%s, %%s) IS NOT NULL"
-        )
+        # For SQLite, handle numeric keys differently
+        if isinstance(self.rhs, (list, tuple)):
+            rhs = self.rhs
+        else:
+            rhs = [self.rhs]
+
+        conditions = []
+        for key in rhs:
+            lhs, lhs_params = self.process_lhs(compiler, connection)
+
+            # Handle numeric keys (both string and integer representations)
+            if isinstance(key, str):
+                try:
+                    # If the key looks like a number, handle both string and integer representations
+                    int_key = int(key)
+                    # Add conditions for both string and integer representations of the key
+                    conditions.append("JSON_TYPE(%s, '$[%s]') IS NOT NULL" % (lhs, int_key))
+                    conditions.append("JSON_TYPE(%s, '$.%s') IS NOT NULL" % (lhs, key))
+                except ValueError:
+                    # For non-numeric keys, use the standard approach
+                    conditions.append("JSON_TYPE(%s, '$.%s') IS NOT NULL" % (lhs, key))
+            elif isinstance(key, int):
+                # For integer keys, handle both string and integer representations
+                conditions.append("JSON_TYPE(%s, '$[%s]') IS NOT NULL" % (lhs, key))
+                conditions.append("JSON_TYPE(%s, '$.%s') IS NOT NULL" % (lhs, str(key)))
+            else:
+                # For other types, use the standard approach
+                conditions.append("JSON_TYPE(%s, '$.%s') IS NOT NULL" % (lhs, key))
+
+        if len(conditions) == 1:
+            return conditions[0], []
+        else:
+            # Join conditions with OR for numeric keys (since we want to match either representation)
+            if self.logical_operator:
+                sql = "(%s)" % self.logical_operator.join(conditions)
+                return sql, []
+            return " OR ".join(conditions), []
 
 
 class HasKey(HasKeyLookup):
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..d569ee6e01
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,80 @@
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        SECRET_KEY='fake-key',
+    )
+    django.setup()
+
+from django.db import models, connection
+from django.test import TestCase
+
+# Create a test model
+class JsonFieldHasKeyTest(models.Model):
+    data = models.JSONField()
+
+    class Meta:
+        app_label = 'reproduce_issue'
+
+# Create the tables
+connection.cursor().execute('''
+    CREATE TABLE IF NOT EXISTS reproduce_issue_jsonfieldhaskeytest (
+        id INTEGER PRIMARY KEY AUTOINCREMENT,
+        data JSONField NOT NULL
+    )
+''')
+
+# Create test instances
+test1 = JsonFieldHasKeyTest(data={'foo': 'bar'})
+test2 = JsonFieldHasKeyTest(data={'1111': 'bar'})
+test1.save()
+test2.save()
+
+# Print the actual data in the database
+print("\nActual data in the database:")
+for obj in JsonFieldHasKeyTest.objects.all():
+    print(f"ID: {obj.id}, Data: {obj.data}")
+
+# Test with string key
+c1 = JsonFieldHasKeyTest.objects.filter(data__has_key='foo')
+print(f"\nQuery for 'foo' key: {c1.query}")
+print(f"Count for 'foo' key: {c1.count()}")
+
+# Test with numeric key
+c2 = JsonFieldHasKeyTest.objects.filter(data__has_key='1111')
+print(f"\nQuery for '1111' key: {c2.query}")
+print(f"Count for '1111' key: {c2.count()}")
+
+# Try with an integer key
+c3 = JsonFieldHasKeyTest.objects.filter(data__has_key=1111)
+print(f"\nQuery for 1111 key (as integer): {c3.query}")
+print(f"Count for 1111 key (as integer): {c3.count()}")
+
+# Try with a different numeric key format
+test3 = JsonFieldHasKeyTest(data={1111: 'bar'})
+test3.save()
+print("\nAfter adding record with integer key:")
+for obj in JsonFieldHasKeyTest.objects.all():
+    print(f"ID: {obj.id}, Data: {obj.data}")
+
+c4 = JsonFieldHasKeyTest.objects.filter(data__has_key='1111')
+print(f"\nQuery for '1111' key after adding integer key: {c4.query}")
+print(f"Count for '1111' key after adding integer key: {c4.count()}")
+
+# Clean up
+JsonFieldHasKeyTest.objects.all().delete()
\ No newline at end of file
