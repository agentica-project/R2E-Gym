diff --git a/django/db/migrations/operations/models.py b/django/db/migrations/operations/models.py
index c120f5d32d..51610c2e4e 100644
--- a/django/db/migrations/operations/models.py
+++ b/django/db/migrations/operations/models.py
@@ -528,6 +528,14 @@ class AlterTogetherOptionOperation(ModelOptionOperation):
     def migration_name_fragment(self):
         return 'alter_%s_%s' % (self.name_lower, self.option_name)
 
+    def reduce(self, operation, app_label):
+        # Check if this is the same type of operation on the same model
+        if isinstance(operation, self.__class__) and self.name_lower == operation.name_lower:
+            # If this operation is empty and the next one is not, we can optimize
+            if not getattr(self, self.option_name) and getattr(operation, self.option_name):
+                return [operation]
+        return True
+
 
 class AlterUniqueTogether(AlterTogetherOptionOperation):
     """
diff --git a/run_tests.py b/run_tests.py
new file mode 100644
index 0000000000..cd6ab8d1d5
--- /dev/null
+++ b/run_tests.py
@@ -0,0 +1,150 @@
+import os
+import sys
+import django
+from django.db import migrations
+from django.db.migrations.optimizer import MigrationOptimizer
+
+def test_alter_together_optimization():
+    """Test that AlterUniqueTogether and AlterIndexTogether operations are optimized."""
+    # Create a set of operations that should be optimized
+    operations = [
+        migrations.AlterUniqueTogether(
+            name='mymodel',
+            unique_together=set(),
+        ),
+        migrations.AlterIndexTogether(
+            name='mymodel',
+            index_together=set(),
+        ),
+        migrations.AlterUniqueTogether(
+            name='mymodel',
+            unique_together={("col",)},
+        ),
+        migrations.AlterIndexTogether(
+            name='mymodel',
+            index_together={("col",)},
+        ),
+    ]
+
+    # Optimize the operations
+    optimizer = MigrationOptimizer()
+    optimized_operations = optimizer.optimize(operations, app_label='myapp')
+
+    # Check if the operations were optimized
+    assert len(optimized_operations) == 2, "Operations were not optimized correctly"
+
+    # Verify the optimized operations have the correct values
+    assert optimized_operations[0].__class__.__name__ == 'AlterUniqueTogether'
+    assert optimized_operations[0].unique_together == {("col",)}
+
+    assert optimized_operations[1].__class__.__name__ == 'AlterIndexTogether'
+    assert optimized_operations[1].index_together == {("col",)}
+
+    print("Test passed!")
+
+def test_alter_together_optimization_with_different_models():
+    """Test that AlterUniqueTogether and AlterIndexTogether operations are not optimized when on different models."""
+    # Create a set of operations that should not be optimized
+    operations = [
+        migrations.AlterUniqueTogether(
+            name='model1',
+            unique_together=set(),
+        ),
+        migrations.AlterUniqueTogether(
+            name='model2',
+            unique_together={("col",)},
+        ),
+    ]
+
+    # Optimize the operations
+    optimizer = MigrationOptimizer()
+    optimized_operations = optimizer.optimize(operations, app_label='myapp')
+
+    # Check if the operations were not optimized
+    assert len(optimized_operations) == 2, "Operations were incorrectly optimized"
+
+    print("Test passed!")
+
+def test_alter_together_optimization_with_different_constraints():
+    """Test that AlterUniqueTogether and AlterIndexTogether operations are optimized correctly when constraints differ."""
+    # Create a set of operations that should be optimized
+    operations = [
+        migrations.AlterUniqueTogether(
+            name='mymodel',
+            unique_together=set(),
+        ),
+        migrations.AlterUniqueTogether(
+            name='mymodel',
+            unique_together={("col1", "col2")},
+        ),
+    ]
+
+    # Optimize the operations
+    optimizer = MigrationOptimizer()
+    optimized_operations = optimizer.optimize(operations, app_label='myapp')
+
+    # Check if the operations were optimized
+    assert len(optimized_operations) == 1, "Operations were not optimized correctly"
+
+    # Verify the optimized operations have the correct values
+    assert optimized_operations[0].__class__.__name__ == 'AlterUniqueTogether'
+    assert optimized_operations[0].unique_together == {("col1", "col2")}
+
+    print("Test passed!")
+
+def test_alter_together_optimization_with_multiple_operations():
+    """Test that multiple AlterUniqueTogether and AlterIndexTogether operations are optimized correctly."""
+    # Create a set of operations that should be optimized
+    operations = [
+        migrations.AlterUniqueTogether(
+            name='mymodel',
+            unique_together=set(),
+        ),
+        migrations.AlterIndexTogether(
+            name='mymodel',
+            index_together=set(),
+        ),
+        migrations.AlterUniqueTogether(
+            name='mymodel',
+            unique_together={("col1",)},
+        ),
+        migrations.AlterIndexTogether(
+            name='mymodel',
+            index_together={("col1",)},
+        ),
+        migrations.AlterUniqueTogether(
+            name='mymodel',
+            unique_together={("col2",)},
+        ),
+        migrations.AlterIndexTogether(
+            name='mymodel',
+            index_together={("col2",)},
+        ),
+    ]
+
+    # Optimize the operations
+    optimizer = MigrationOptimizer()
+    optimized_operations = optimizer.optimize(operations, app_label='myapp')
+
+    # Check if the operations were optimized
+    assert len(optimized_operations) == 2, "Operations were not optimized correctly"
+
+    # Verify the optimized operations have the correct values
+    assert optimized_operations[0].__class__.__name__ == 'AlterUniqueTogether'
+    assert optimized_operations[0].unique_together == {("col2",)}
+
+    assert optimized_operations[1].__class__.__name__ == 'AlterIndexTogether'
+    assert optimized_operations[1].index_together == {("col2",)}
+
+    print("Test passed!")
+
+if __name__ == "__main__":
+    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'test_settings')
+    django.setup()
+
+    test_alter_together_optimization()
+    test_alter_together_optimization_with_different_models()
+    test_alter_together_optimization_with_different_constraints()
+    test_alter_together_optimization_with_multiple_operations()
+
+    print("All tests passed!")
\ No newline at end of file
diff --git a/test_alter_together_optimization.py b/test_alter_together_optimization.py
new file mode 100644
index 0000000000..557e37021c
--- /dev/null
+++ b/test_alter_together_optimization.py
@@ -0,0 +1,56 @@
+from django.db import migrations
+from django.db.migrations.optimizer import MigrationOptimizer
+
+def test_alter_together_optimization():
+    """Test that AlterUniqueTogether and AlterIndexTogether operations are optimized."""
+    # Create a set of operations that should be optimized
+    operations = [
+        migrations.AlterUniqueTogether(
+            name='mymodel',
+            unique_together=set(),
+        ),
+        migrations.AlterIndexTogether(
+            name='mymodel',
+            index_together=set(),
+        ),
+        migrations.AlterUniqueTogether(
+            name='mymodel',
+            unique_together={("col",)},
+        ),
+        migrations.AlterIndexTogether(
+            name='mymodel',
+            index_together={("col",)},
+        ),
+    ]
+
+    # Print the operations before optimization
+    print("Operations before optimization:")
+    for i, op in enumerate(operations):
+        print(f"{i}: {op.__class__.__name__} - {getattr(op, 'unique_together' if hasattr(op, 'unique_together') else 'index_together', None)}")
+
+    # Optimize the operations
+    optimizer = MigrationOptimizer()
+    optimized_operations = optimizer.optimize(operations, app_label='myapp')
+
+    # Print the results
+    print(f"Original operations: {len(operations)}")
+    print(f"Optimized operations: {len(optimized_operations)}")
+
+    # Print the operations after optimization
+    print("Operations after optimization:")
+    for i, op in enumerate(optimized_operations):
+        print(f"{i}: {op.__class__.__name__} - {getattr(op, 'unique_together' if hasattr(op, 'unique_together') else 'index_together', None)}")
+
+    # Check if the operations were optimized
+    assert len(optimized_operations) == 2, "Operations were not optimized correctly"
+
+    # Verify the optimized operations have the correct values
+    assert optimized_operations[0].__class__.__name__ == 'AlterUniqueTogether'
+    assert optimized_operations[0].unique_together == {("col",)}
+
+    assert optimized_operations[1].__class__.__name__ == 'AlterIndexTogether'
+    assert optimized_operations[1].index_together == {("col",)}
+
+if __name__ == "__main__":
+    test_alter_together_optimization()
+    print("Test passed!")
\ No newline at end of file
diff --git a/test_settings.py b/test_settings.py
new file mode 100644
index 0000000000..711a761945
--- /dev/null
+++ b/test_settings.py
@@ -0,0 +1,23 @@
+import os
+import django
+
+BASE_DIR = os.path.dirname(os.path.abspath(__file__))
+
+SECRET_KEY = 'fake-key'
+INSTALLED_APPS = [
+    'django.contrib.contenttypes',
+    'django.contrib.auth',
+    'tests.migrations',
+]
+DATABASES = {
+    'default': {
+        'ENGINE': 'django.db.backends.sqlite3',
+        'NAME': ':memory:',
+    }
+}
+ROOT_URLCONF = 'django.urls'
+MIDDLEWARE = []
+TEMPLATES = []
+AUTHENTICATION_BACKENDS = []
+PASSWORD_HASHERS = ['django.contrib.auth.hashers.MD5PasswordHasher']
+DEBUG = True
\ No newline at end of file
