diff --git a/django/apps/registry.py b/django/apps/registry.py
index 0683f3ad3c..a5a4b85f92 100644
--- a/django/apps/registry.py
+++ b/django/apps/registry.py
@@ -376,6 +376,8 @@ class Apps:
         # Call expire cache on each model. This will purge
         # the relation tree and the fields cache.
         self.get_models.cache_clear()
+        # Clear the cache for get_swappable_settings_name
+        self.get_swappable_settings_name.cache_clear()
         if self.ready:
             # Circumvent self.get_models() to prevent that the cache is refilled.
             # This particularly prevents that an empty value is cached while cloning.
diff --git a/test_swappable_cache.py b/test_swappable_cache.py
new file mode 100644
index 0000000000..fec4de75ef
--- /dev/null
+++ b/test_swappable_cache.py
@@ -0,0 +1,75 @@
+#!/usr/bin/env python
+import django
+import inspect
+import functools
+from django.apps import apps
+from django.conf import settings
+
+# Configure Django settings
+settings.configure(
+    INSTALLED_APPS=[
+        'django.contrib.auth',
+        'django.contrib.contenttypes',
+    ],
+    DATABASES={
+        'default': {
+            'ENGINE': 'django.db.backends.sqlite3',
+            'NAME': ':memory:',
+        }
+    }
+)
+django.setup()
+
+def test_swappable_cache():
+    # Check if the method has a cache attribute
+    has_cache = hasattr(apps.get_swappable_settings_name, 'cache_clear')
+    print(f"Does get_swappable_settings_name have a cache? {has_cache}")
+
+    # Check if the method is decorated with @functools.cache
+    is_cached = isinstance(apps.get_swappable_settings_name, functools._lru_cache_wrapper)
+    print(f"Is get_swappable_settings_name a functools._lru_cache_wrapper? {is_cached}")
+
+    # Get the initial value
+    initial_value = apps.get_swappable_settings_name('auth.user')
+    print(f"Initial value: {initial_value}")
+
+    # Get the cache info if available
+    if has_cache:
+        cache_info_before = apps.get_swappable_settings_name.cache_info()
+        print(f"Cache hits before clearing: {cache_info_before.hits}")
+        print(f"Cache misses before clearing: {cache_info_before.misses}")
+
+    # Call clear_cache
+    apps.clear_cache()
+
+    # Get the cache info after clearing if available
+    if has_cache:
+        cache_info_after = apps.get_swappable_settings_name.cache_info()
+        print(f"Cache hits after clear_cache: {cache_info_after.hits}")
+        print(f"Cache misses after clear_cache: {cache_info_after.misses}")
+        print(f"Cache cleared by clear_cache? {cache_info_after.hits == 0 and cache_info_after.misses == 0}")
+
+    # Now manually clear the cache and check again
+    if has_cache:
+        apps.get_swappable_settings_name.cache_clear()
+        cache_info_manual = apps.get_swappable_settings_name.cache_info()
+        print(f"Cache hits after manual cache_clear: {cache_info_manual.hits}")
+        print(f"Cache misses after manual cache_clear: {cache_info_manual.misses}")
+        print(f"Cache cleared by manual cache_clear? {cache_info_manual.hits == 0 and cache_info_manual.misses == 0}")
+
+    # Verify the fix by checking if the method was called
+    print("\nVerifying the fix:")
+    # We'll check if our modification to clear_cache is actually being called
+    # by checking if the cache_clear method exists and can be called
+    if has_cache:
+        try:
+            # This will raise an AttributeError if cache_clear doesn't exist
+            apps.get_swappable_settings_name.cache_clear()
+            print("✓ get_swappable_settings_name.cache_clear() exists and can be called")
+        except AttributeError:
+            print("✗ get_swappable_settings_name.cache_clear() does not exist or cannot be called")
+    else:
+        print("✗ get_swappable_settings_name does not have a cache_clear method")
+
+if __name__ == "__main__":
+    test_swappable_cache()
\ No newline at end of file
