diff --git a/complex_test.py b/complex_test.py
new file mode 100644
index 0000000000..561fcb5818
--- /dev/null
+++ b/complex_test.py
@@ -0,0 +1,61 @@
+import sys
+import os
+import django
+from django.db import models
+from django.db.models import Prefetch, Q
+
+# Set up Django
+sys.path.insert(0, '/testbed')
+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'django.conf.global_settings')
+django.setup()
+
+# Create a more complex test case
+class TestCase:
+    def setUp(self):
+        # Create models
+        class Category(models.Model):
+            name = models.CharField(max_length=100)
+
+            class Meta:
+                app_label = 'test_app'
+                managed = False
+
+            def __str__(self):
+                return self.name
+
+        class Post(models.Model):
+            title = models.CharField(max_length=100)
+            category = models.ForeignKey(Category, related_name='post_set', on_delete=models.CASCADE)
+            is_published = models.BooleanField(default=True)
+
+            class Meta:
+                app_label = 'test_app'
+                managed = False
+
+            def __str__(self):
+                return self.title
+
+        self.Category = Category
+        self.Post = Post
+
+    def test_prefetch_with_slice_and_filter(self):
+        try:
+            # Try with a more complex queryset that includes filtering and slicing
+            categories = self.Category.objects.prefetch_related(
+                Prefetch(
+                    'post_set',
+                    queryset=self.Post.objects.filter(is_published=True).order_by('title')[:3],
+                    to_attr='example_posts',
+                )
+            )
+
+            print("Success! Prefetch with sliced and filtered queryset worked.")
+            return True
+        except Exception as e:
+            print(f"Error: {e}")
+            return False
+
+# Run the test
+test = TestCase()
+test.setUp()
+test.test_prefetch_with_slice_and_filter()
\ No newline at end of file
diff --git a/django/db/models/query.py b/django/db/models/query.py
index be0deb90b0..c55c6150b1 100644
--- a/django/db/models/query.py
+++ b/django/db/models/query.py
@@ -1438,9 +1438,12 @@ class QuerySet:
         return self._filter_or_exclude(True, args, kwargs)
 
     def _filter_or_exclude(self, negate, args, kwargs):
-        if (args or kwargs) and self.query.is_sliced:
+        if (args or kwargs) and self.query.is_sliced and not getattr(self, '_is_prefetch_queryset', False):
             raise TypeError("Cannot filter a query once a slice has been taken.")
         clone = self._chain()
+        # Copy the _is_prefetch_queryset flag to the clone
+        if hasattr(self, '_is_prefetch_queryset'):
+            clone._is_prefetch_queryset = True
         if self._defer_next_filter:
             self._defer_next_filter = False
             clone._deferred_filter = negate, args, kwargs
@@ -2170,6 +2173,8 @@ class Prefetch:
             # Prevent the QuerySet from being evaluated
             queryset._result_cache = []
             queryset._prefetch_done = True
+            # Mark this queryset as being used in a Prefetch object
+            queryset._is_prefetch_queryset = True
             obj_dict["queryset"] = queryset
         return obj_dict
 
diff --git a/django_settings.py b/django_settings.py
new file mode 100644
index 0000000000..2bbb3377f1
--- /dev/null
+++ b/django_settings.py
@@ -0,0 +1,13 @@
+DATABASES = {
+    'default': {
+        'ENGINE': 'django.db.backends.sqlite3',
+        'NAME': ':memory:',
+    }
+}
+
+INSTALLED_APPS = [
+    'django.contrib.contenttypes',
+    'django.contrib.auth',
+]
+
+SECRET_KEY = 'fake-key'
\ No newline at end of file
diff --git a/evaluation_test.py b/evaluation_test.py
new file mode 100644
index 0000000000..5d709b2b9a
--- /dev/null
+++ b/evaluation_test.py
@@ -0,0 +1,63 @@
+import sys
+import os
+import django
+from django.db import models
+from django.db.models import Prefetch, Q
+
+# Set up Django
+sys.path.insert(0, '/testbed')
+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'django.conf.global_settings')
+django.setup()
+
+# Create a more complex test case
+class TestCase:
+    def setUp(self):
+        # Create models
+        class Category(models.Model):
+            name = models.CharField(max_length=100)
+
+            class Meta:
+                app_label = 'test_app'
+                managed = False
+
+            def __str__(self):
+                return self.name
+
+        class Post(models.Model):
+            title = models.CharField(max_length=100)
+            category = models.ForeignKey(Category, related_name='post_set', on_delete=models.CASCADE)
+            is_published = models.BooleanField(default=True)
+
+            class Meta:
+                app_label = 'test_app'
+                managed = False
+
+            def __str__(self):
+                return self.title
+
+        self.Category = Category
+        self.Post = Post
+
+    def test_prefetch_with_slice_and_evaluate(self):
+        try:
+            # Create a prefetch object with a sliced queryset
+            prefetch = Prefetch(
+                'post_set',
+                queryset=self.Post.objects.filter(is_published=True).order_by('title')[:3],
+                to_attr='example_posts',
+            )
+
+            # This should trigger the error if it exists
+            # We need to actually evaluate the queryset to see the error
+            categories = list(self.Category.objects.prefetch_related(prefetch))
+
+            print("Success! Prefetch with sliced queryset worked.")
+            return True
+        except Exception as e:
+            print(f"Error: {e}")
+            return False
+
+# Run the test
+test = TestCase()
+test.setUp()
+test.test_prefetch_with_slice_and_evaluate()
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..232f5e7669
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,75 @@
+from django.db import models
+from django.db.models import Prefetch
+
+# Define simple models for testing
+class Category(models.Model):
+    name = models.CharField(max_length=100)
+
+    def __str__(self):
+        return self.name
+
+class Post(models.Model):
+    title = models.CharField(max_length=100)
+    category = models.ForeignKey(Category, related_name='post_set', on_delete=models.CASCADE)
+
+    def __str__(self):
+        return self.title
+
+# Create test data
+def create_test_data():
+    # Create categories
+    cat1 = Category.objects.create(name='Category 1')
+    cat2 = Category.objects.create(name='Category 2')
+
+    # Create posts
+    for i in range(10):
+        Post.objects.create(title=f'Post {i+1}', category=cat1)
+        Post.objects.create(title=f'Post {i+1} (cat2)', category=cat2)
+
+# Try to use prefetch with sliced queryset
+def test_prefetch_with_slice():
+    try:
+        # This should fail with the current implementation
+        categories = Category.objects.prefetch_related(
+            Prefetch(
+                'post_set',
+                queryset=Post.objects.all()[:3],  # Sliced queryset
+                to_attr='example_posts',
+            )
+        ).all()
+
+        # If we get here, it worked
+        print("Success! Prefetch with sliced queryset worked.")
+        for category in categories:
+            print(f"Category: {category.name}")
+            print(f"Example posts: {[post.title for post in category.example_posts]}")
+    except Exception as e:
+        print(f"Error: {e}")
+
+if __name__ == "__main__":
+    # Set up Django environment
+    import os
+    import django
+    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'django.conf.global_settings')
+    django.setup()
+
+    # Create test database
+    from django.db import connection
+    connection.cursor().execute('''
+        CREATE TABLE IF NOT EXISTS category (
+            id INTEGER PRIMARY KEY AUTOINCREMENT,
+            name VARCHAR(100)
+        )
+    ''')
+    connection.cursor().execute('''
+        CREATE TABLE IF NOT EXISTS post (
+            id INTEGER PRIMARY KEY AUTOINCREMENT,
+            title VARCHAR(100),
+            category_id INTEGER,
+            FOREIGNKEY(category_id) REFERENCES category(id)
+        )
+    ''')
+
+    # Run the test
+    create_test_data()
+    test_prefetch_with_slice()
\ No newline at end of file
diff --git a/simple_test.py b/simple_test.py
new file mode 100644
index 0000000000..5ed23befd8
--- /dev/null
+++ b/simple_test.py
@@ -0,0 +1,60 @@
+import sys
+import os
+import django
+from django.db import models
+from django.db.models import Prefetch
+
+# Set up Django
+sys.path.insert(0, '/testbed')
+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'django.conf.global_settings')
+django.setup()
+
+# Create a simple test case
+class TestCase:
+    def setUp(self):
+        # Create models
+        class Category(models.Model):
+            name = models.CharField(max_length=100)
+
+            class Meta:
+                app_label = 'test_app'
+                managed = False
+
+            def __str__(self):
+                return self.name
+
+        class Post(models.Model):
+            title = models.CharField(max_length=100)
+            category = models.ForeignKey(Category, related_name='post_set', on_delete=models.CASCADE)
+
+            class Meta:
+                app_label = 'test_app'
+                managed = False
+
+            def __str__(self):
+                return self.title
+
+        self.Category = Category
+        self.Post = Post
+
+    def test_prefetch_with_slice(self):
+        try:
+            # This should fail with the current implementation
+            categories = self.Category.objects.prefetch_related(
+                Prefetch(
+                    'post_set',
+                    queryset=self.Post.objects.all()[:3],  # Sliced queryset
+                    to_attr='example_posts',
+                )
+            )
+
+            print("Success! Prefetch with sliced queryset worked.")
+            return True
+        except Exception as e:
+            print(f"Error: {e}")
+            return False
+
+# Run the test
+test = TestCase()
+test.setUp()
+test.test_prefetch_with_slice()
\ No newline at end of file
diff --git a/test_prefetch_slice.py b/test_prefetch_slice.py
new file mode 100644
index 0000000000..5ba321de7d
--- /dev/null
+++ b/test_prefetch_slice.py
@@ -0,0 +1,70 @@
+import sys
+import os
+import django
+from django.db import models
+from django.db.models import Prefetch
+from django.test import TestCase
+
+# Set up Django
+sys.path.insert(0, '/testbed')
+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'django.conf.global_settings')
+django.setup()
+
+# Create models
+class Category(models.Model):
+    name = models.CharField(max_length=100)
+
+    def __str__(self):
+        return self.name
+
+class Post(models.Model):
+    title = models.CharField(max_length=100)
+    category = models.ForeignKey(Category, related_name='post_set', on_delete=models.CASCADE)
+    is_published = models.BooleanField(default=True)
+
+    def __str__(self):
+        return self.title
+
+# Test case
+class PrefetchSliceTest(TestCase):
+    def setUp(self):
+        # Create categories
+        self.cat1 = Category.objects.create(name='Category 1')
+        self.cat2 = Category.objects.create(name='Category 2')
+
+        # Create posts
+        for i in range(10):
+            Post.objects.create(title=f'Post {i+1}', category=self.cat1, is_published=True)
+            Post.objects.create(title=f'Post {i+1} (cat2)', category=self.cat2, is_published=True)
+
+    def test_prefetch_with_slice(self):
+        try:
+            # This should fail with the current implementation
+            categories = Category.objects.prefetch_related(
+                Prefetch(
+                    'post_set',
+                    queryset=Post.objects.filter(is_published=True).order_by('title')[:3],
+                    to_attr='example_posts',
+                )
+            )
+
+            # Force evaluation
+            categories = list(categories)
+
+            print("Success! Prefetch with sliced queryset worked.")
+            # Print results
+            for category in categories:
+                print(f"Category: {category.name}")
+                print(f"Example posts: {[post.title for post in category.example_posts]}")
+            return True
+        except Exception as e:
+            print(f"Error: {e}")
+            import traceback
+            traceback.print_exc()
+            return False
+
+if __name__ == "__main__":
+    # Run the test
+    test = PrefetchSliceTest()
+    test.setUp()
+    test.test_prefetch_with_slice()
\ No newline at end of file
diff --git a/test_with_db.py b/test_with_db.py
new file mode 100644
index 0000000000..80eb344a04
--- /dev/null
+++ b/test_with_db.py
@@ -0,0 +1,88 @@
+import sys
+import os
+import django
+from django.db import models
+from django.db.models import Prefetch, Q
+from django.conf import settings
+
+# Set up Django
+sys.path.insert(0, '/testbed')
+settings_module = 'django_settings'
+os.environ.setdefault('DJANGO_SETTINGS_MODULE', settings_module)
+django.setup()
+
+# Create models
+class Category(models.Model):
+    name = models.CharField(max_length=100)
+
+class Post(models.Model):
+    title = models.CharField(max_length=100)
+    category = models.ForeignKey(Category, related_name='post_set', on_delete=models.CASCADE)
+    is_published = models.BooleanField(default=True)
+
+# Create test data
+def create_test_data():
+    # Create categories
+    cat1 = Category.objects.create(name='Category 1')
+    cat2 = Category.objects.create(name='Category 2')
+
+    # Create posts
+    for i in range(10):
+        Post.objects.create(title=f'Post {i+1}', category=cat1, is_published=True)
+        Post.objects.create(title=f'Post {i+1} (cat2)', category=cat2, is_published=True)
+
+# Test prefetch with sliced queryset
+def test_prefetch_with_slice():
+    try:
+        # Create a prefetch object with a sliced queryset
+        categories = Category.objects.prefetch_related(
+            Prefetch(
+                'post_set',
+                queryset=Post.objects.filter(is_published=True).order_by('title')[:3],
+                to_attr='example_posts',
+            )
+        )
+
+        # Force evaluation
+        categories = list(categories)
+
+        print("Success! Prefetch with sliced queryset worked.")
+        # Print results
+        for category in categories:
+            print(f"Category: {category.name}")
+            print(f"Example posts: {[post.title for post in category.example_posts]}")
+        return True
+    except Exception as e:
+        print(f"Error: {e}")
+        import traceback
+        traceback.print_exc()
+        return False
+
+if __name__ == "__main__":
+    # Create tables
+    from django.db import connection
+    cursor = connection.cursor()
+    cursor.execute("""
+        CREATE TABLE IF NOT EXISTS category (
+            id INTEGER PRIMARY KEY AUTOINCREMENT,
+            name VARCHAR(100)
+        )
+    """)
+    cursor.execute("""
+        CREATE TABLE IF NOT EXISTS post (
+            id INTEGER PRIMARY KEY AUTOINCREMENT,
+            title VARCHAR(100),
+            category_id INTEGER,
+            is_published BOOLEAN DEFAULT TRUE,
+            FOREIGN KEY (category_id) REFERENCES category (id)
+        )
+    """)
+
+    # Run migrations
+    from django.core.management import call_command
+    call_command('makemigrations', 'test_with_db')
+    call_command('migrate')
+
+    # Create test data and run test
+    create_test_data()
+    test_prefetch_with_slice()
\ No newline at end of file
diff --git a/verify_fix.py b/verify_fix.py
new file mode 100644
index 0000000000..9d64a7a217
--- /dev/null
+++ b/verify_fix.py
@@ -0,0 +1,74 @@
+import sys
+import os
+import django
+from django.db import models
+from django.db.models import Prefetch
+from django.test import TestCase
+
+# Set up Django
+sys.path.insert(0, '/testbed')
+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'django.conf.global_settings')
+django.setup()
+
+# Create models
+class Category(models.Model):
+    name = models.CharField(max_length=100)
+
+    class Meta:
+        app_label = 'test_app'
+        managed = False
+
+    def __str__(self):
+        return self.name
+
+class Post(models.Model):
+    title = models.CharField(max_length=100)
+    category = models.ForeignKey(Category, related_name='post_set', on_delete=models.CASCADE)
+    is_published = models.BooleanField(default=True)
+
+    class Meta:
+        app_label = 'test_app'
+        managed = False
+
+    def __str__(self):
+        return self.title
+
+# Test case
+class PrefetchSliceTest(TestCase):
+    def setUp(self):
+        # Create categories
+        self.cat1 = Category.objects.create(name='Category 1')
+        self.cat2 = Category.objects.create(name='Category 2')
+
+        # Create posts
+        for i in range(10):
+            Post.objects.create(title=f'Post {i+1}', category=self.cat1, is_published=True)
+            Post.objects.create(title=f'Post {i+1} (cat2)', category=self.cat2, is_published=True)
+
+    def test_prefetch_with_slice(self):
+        # This should now work with our fix
+        categories = Category.objects.prefetch_related(
+            Prefetch(
+                'post_set',
+                queryset=Post.objects.filter(is_published=True).order_by('title')[:3],
+                to_attr='example_posts',
+            )
+        )
+
+        # Force evaluation
+        categories = list(categories)
+
+        print("Success! Prefetch with sliced queryset worked.")
+        # Print results
+        for category in categories:
+            print(f"Category: {category.name}")
+            print(f"Example posts: {[post.title for post in category.example_posts]}")
+
+        # Verify that we only got 3 posts per category
+        self.assertEqual(len(category.example_posts), 3)
+
+if __name__ == "__main__":
+    # Run the test
+    test = PrefetchSliceTest()
+    test.setUp()
+    test.test_prefetch_with_slice()
\ No newline at end of file
