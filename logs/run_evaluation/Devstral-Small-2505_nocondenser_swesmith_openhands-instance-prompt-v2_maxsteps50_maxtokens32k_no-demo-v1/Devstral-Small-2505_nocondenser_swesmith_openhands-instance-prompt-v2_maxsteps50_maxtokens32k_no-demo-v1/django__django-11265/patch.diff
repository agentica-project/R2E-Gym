diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py
index d69c24419b..c91293e12f 100644
--- a/django/db/models/sql/query.py
+++ b/django/db/models/sql/query.py
@@ -1666,6 +1666,8 @@ class Query(BaseExpression):
             filter_expr = (filter_lhs, OuterRef(filter_rhs.name))
         # Generate the inner query.
         query = Query(self.model)
+        # Copy annotations to ensure FilteredRelation annotations are preserved
+        query.annotations = self.annotations.copy()
         query.add_filter(filter_expr)
         query.clear_ordering(True)
         # Try to have as simple as possible subquery -> trim leading joins from
diff --git a/fix_filtered_relation.py b/fix_filtered_relation.py
new file mode 100644
index 0000000000..1e16e65386
--- /dev/null
+++ b/fix_filtered_relation.py
@@ -0,0 +1,88 @@
+#!/usr/bin/env python
+"""
+This script demonstrates the issue with FilteredRelation and exclude,
+and implements a fix for the split_exclude method.
+"""
+
+def fix_split_exclude():
+    """
+    Fix the split_exclude method in django/db/models/sql/query.py to handle
+    FilteredRelation annotations properly.
+    """
+    from django.db.models.sql.query import Query
+
+    original_split_exclude = Query.split_exclude
+
+    def patched_split_exclude(self, filter_expr, can_reuse, names_with_path):
+        """
+        Patched version of split_exclude that copies annotations to the new query.
+        """
+        # Generate the inner query.
+        query = Query(self.model)
+
+        # Copy annotations from the original query
+        query.annotations = self.annotations.copy()
+
+        # Rest of the original method
+        filter_lhs, filter_rhs = filter_expr
+        if isinstance(filter_rhs, F):
+            filter_expr = (filter_lhs, OuterRef(filter_rhs.name))
+        query.add_filter(filter_expr)
+        query.clear_ordering(True)
+        # Try to have as simple as possible subquery -> trim leading joins from
+        # the subquery.
+        trimmed_prefix, contains_louter = query.trim_start(names_with_path)
+
+        # Add extra check to make sure the selected field will not be null
+        # since we are adding an IN <subquery> clause. This prevents the
+        # database from tripping over IN (...,NULL,...) selects and returning
+        # nothing
+        col = query.select[0]
+        select_field = col.target
+        alias = col.alias
+        if self.is_nullable(select_field):
+            lookup_class = select_field.get_lookup('isnull')
+            lookup = lookup_class(select_field.get_col(alias), False)
+            query.where.add(lookup, AND)
+        if alias in can_reuse:
+            pk = select_field.model._meta.pk
+            # Need to add a restriction so that outer query's filters are in effect for
+            # the subquery, too.
+            query.bump_prefix(self)
+            lookup_class = select_field.get_lookup('exact')
+            # Note that the query.select[0].alias is different from alias
+            # due to bump_prefix above.
+            lookup = lookup_class(pk.get_col(query.select[0].alias),
+                                pk.get_col(alias))
+            query.where.add(lookup, AND)
+            query.external_aliases.add(alias)
+
+        condition, needed_inner = self.build_filter(
+            ('%s__in' % trimmed_prefix, query),
+            current_negated=True, branch_negated=True, can_reuse=can_reuse)
+        if contains_louter:
+            or_null_condition, _ = self.build_filter(
+                ('%s__isnull' % trimmed_prefix, True),
+                current_negated=True, branch_negated=True, can_reuse=can_reuse)
+            condition.add(or_null_condition, OR)
+            # Note that the end result will be:
+            # (outercol NOT IN innerq AND outercol IS NOT NULL) OR outercol IS NULL.
+            # This might look crazy but due to how IN works, this seems to be
+            # correct. If the IS NOT NULL check is removed then outercol NOT
+            # IN will return UNKNOWN. If the IS NULL check is removed, then if
+            # outercol IS NULL we will not match the row.
+        return condition, needed_inner
+
+    # Apply the patch
+    Query.split_exclude = patched_split_exclude
+    return original_split_exclude
+
+if __name__ == "__main__":
+    # Import necessary modules
+    from django.db.models.expressions import F, OuterRef
+    from django.db.models.sql.where import AND, OR
+
+    # Apply the fix
+    original = fix_split_exclude()
+
+    print("Patched Query.split_exclude to handle FilteredRelation annotations")
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..0162f89c7e
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,20 @@
+#!/usr/bin/env python
+import os
+import django
+from django.db.models import Q, FilteredRelation
+
+# Set up Django
+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'tests.test_sqlite')
+django.setup()
+
+from tests.filtered_relation.models import Author
+
+# Test the issue
+try:
+    results = Author.objects.annotate(
+        book_alice=FilteredRelation('book', condition=Q(book__title__iexact='poem by alice')),
+    ).exclude(book_alice__isnull=False)
+
+    print("Test passed! Results:", results)
+except Exception as e:
+    print(f"Test failed with error: {type(e).__name__}: {e}")
\ No newline at end of file
