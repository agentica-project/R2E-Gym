diff --git a/django/forms/models.py b/django/forms/models.py
index 422bc5d178..bcf591593f 100644
--- a/django/forms/models.py
+++ b/django/forms/models.py
@@ -1188,7 +1188,7 @@ class ModelChoiceField(ChoiceField):
     # This class is a subclass of ChoiceField for purity, but it doesn't
     # actually use any of ChoiceField's implementation.
     default_error_messages = {
-        'invalid_choice': _('Select a valid choice. That choice is not one of'
+        'invalid_choice': _('Select a valid choice. %(value)s is not one of'
                             ' the available choices.'),
     }
     iterator = ModelChoiceIterator
@@ -1284,7 +1284,7 @@ class ModelChoiceField(ChoiceField):
                 value = getattr(value, key)
             value = self.queryset.get(**{key: value})
         except (ValueError, TypeError, self.queryset.model.DoesNotExist):
-            raise ValidationError(self.error_messages['invalid_choice'], code='invalid_choice')
+            raise ValidationError(self.error_messages['invalid_choice'], code='invalid_choice', params={'value': value})
         return value
 
     def validate(self, value):
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..459aba74b7
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,58 @@
+import django
+from django import forms
+from django.core.exceptions import ValidationError
+from django.forms.models import ModelChoiceField, ModelMultipleChoiceField
+from django.test import TestCase, override_settings
+
+# Create a simple model for testing
+from django.db import models
+from django.db.models import Model
+
+  class TestModel(Model):
+    name = models.CharField(max_length=100)
+
+    class Meta:
+        app_label = 'reproduce_issue'
+
+# Create a simple queryset for testing
+queryset = TestModel.objects.none()
+
+# Test ModelChoiceField
+def test_modelchoicefield():
+    field = ModelChoiceField(queryset=queryset)
+
+    try:
+        field.to_python('invalid_value')
+    except ValidationError as e:
+        print("ModelChoiceField error message:", e.messages[0])
+        # The current error message doesn't include the invalid value
+        # It should include the invalid value like ModelMultipleChoiceField does
+
+# Test ModelMultipleChoiceField
+def test_modelmultiplechoicefield():
+    field = ModelMultipleChoiceField(queryset=queryset)
+
+    try:
+        field.to_python(['invalid_value'])
+    except ValidationError as e:
+        print("ModelMultipleChoiceField error message:", e.messages[0])
+        # This error message includes the invalid value
+
+# Test ChoiceField
+def test_choicefield():
+    field = forms.ChoiceField(choices=[])
+
+    try:
+        field.to_python('invalid_value')
+    except ValidationError as e:
+        print("ChoiceField error message:", e.messages[0])
+        # This error message includes the invalid value
+
+if __name__ == "__main__":
+    # Set up Django
+    django.setup()
+
+    print("Testing error messages for invalid choices:")
+    test_modelchoicefield()
+    test_modelmultiplechoicefield()
+    test_choicefield()
\ No newline at end of file
diff --git a/simple_verify.py b/simple_verify.py
new file mode 100644
index 0000000000..1c512c78f2
--- /dev/null
+++ b/simple_verify.py
@@ -0,0 +1,31 @@
+import django
+import os
+
+# Set up Django settings
+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'django.conf.global_settings')
+
+# Import Django components
+django.setup()
+
+from django.forms.models import ModelChoiceField
+from django.utils.translation import gettext as _
+
+# Check the error message format
+error_message = ModelChoiceField.default_error_messages['invalid_choice']
+print("ModelChoiceField error message format:", error_message)
+
+# Verify that the error message includes the %(value)s placeholder
+assert "%(value)s" in error_message, "Error message should include %(value)s placeholder"
+print("✓ Error message includes the %(value)s placeholder")
+
+# Check if the error message is consistent with ModelMultipleChoiceField
+from django.forms.models import ModelMultipleChoiceField
+multiple_error_message = ModelMultipleChoiceField.default_error_messages['invalid_choice']
+print("ModelMultipleChoiceField error message format:", multiple_error_message)
+
+# Verify that both error messages are consistent
+assert "%(value)s" in ModelChoiceField.default_error_messages['invalid_choice'], "ModelChoiceField error message should include the value"
+assert "%(value)s" in ModelMultipleChoiceField.default_error_messages['invalid_choice'], "ModelMultipleChoiceField error message should include the value"
+print("✓ Both error messages are consistent and include the value placeholder")
+
+print("\nVerification successful! The fix is working correctly.")
\ No newline at end of file
diff --git a/test_modelchoicefield_error.py b/test_modelchoicefield_error.py
new file mode 100644
index 0000000000..8ceb03d19b
--- /dev/null
+++ b/test_modelchoicefield_error.py
@@ -0,0 +1,52 @@
+import unittest
+from django import forms
+from django.core.exceptions import ValidationError
+from django.forms.models import ModelChoiceField, ModelMultipleChoiceField
+from django.test import TestCase
+
+class TestModelChoiceFieldErrorMessages(TestCase):
+    def test_modelchoicefield_error_message(self):
+        """Test that ModelChoiceField includes the invalid value in the error message."""
+        # Create a ModelChoiceField with an empty queryset
+        field = ModelChoiceField(queryset=[])
+
+        # Try to validate an invalid value
+        with self.assertRaises(ValidationError) as cm:
+            field.to_python('invalid_value')
+
+        # Get the error message
+        error_message = cm.exception.messages[0]
+        print("ModelChoiceField error message:", error_message)
+        # The current error message doesn't include the invalid value
+        # It should include the invalid value like ModelMultipleChoiceField does
+
+    def test_modelmultiplechoicefield_error_message(self):
+        """Test that ModelMultipleChoiceField includes the invalid value in the error message."""
+        # Create a ModelMultipleChoiceField with an empty queryset
+        field = ModelMultipleChoiceField(queryset=[])
+
+        # Try to validate an invalid value
+        with self.assertRaises(ValidationError) as cm:
+            field.to_python(['invalid_value'])
+
+        # Get the error message
+        error_message = cm.exception.messages[0]
+        print("ModelMultipleChoiceField error message:", error_message)
+        # This error message includes the invalid value
+
+    def test_choicefield_error_message(self):
+        """Test that ChoiceField includes the invalid value in the error message."""
+        # Create a ChoiceField with no choices
+        field = forms.ChoiceField(choices=[])
+
+        # Try to validate an invalid value
+        with self.assertRaises(ValidationError) as cm:
+            field.to_python('invalid_value')
+
+        # Get the error message
+        error_message = cm.exception.messages[0]
+        print("ChoiceField error message:", error_message)
+        # This error message includes the invalid value
+
+if __name__ == '__main__':
+    unittest.main()
\ No newline at end of file
diff --git a/test_reproduction.py b/test_reproduction.py
new file mode 100644
index 0000000000..711b81a18e
--- /dev/null
+++ b/test_reproduction.py
@@ -0,0 +1,57 @@
+import django
+from django import forms
+from django.core.exceptions import ValidationError
+from django.forms.models import ModelChoiceField, ModelMultipleChoiceField
+
+# Set up Django
+django.setup()
+
+# Create a simple model for testing
+from django.db import models
+from django.db.models import Model
+
+class TestModel(Model):
+    name = models.CharField(max_length=100)
+
+    class Meta:
+        app_label = 'test_reproduction'
+
+# Create a simple queryset for testing
+queryset = TestModel.objects.none()
+
+# Test ModelChoiceField
+def test_modelchoicefield():
+    field = ModelChoiceField(queryset=queryset)
+
+    try:
+        field.to_python('invalid_value')
+    except ValidationError as e:
+        print("ModelChoiceField error message:", e.messages[0])
+        # The current error message doesn't include the invalid value
+        # It should include the invalid value like ModelMultipleChoiceField does
+
+# Test ModelMultipleChoiceField
+def test_modelmultiplechoicefield():
+    field = ModelMultipleChoiceField(queryset=queryset)
+
+    try:
+        field.to_python(['invalid_value'])
+    except ValidationError as e:
+        print("ModelMultipleChoiceField error message:", e.messages[0])
+        # This error message includes the invalid value
+
+# Test ChoiceField
+def test_choicefield():
+    field = forms.ChoiceField(choices=[])
+
+    try:
+        field.to_python('invalid_value')
+    except ValidationError as e:
+        print("ChoiceField error message:", e.messages[0])
+        # This error message includes the invalid value
+
+if __name__ == "__main__":
+    print("Testing error messages for invalid choices:")
+    test_modelchoicefield()
+    test_modelmultiplechoicefield()
+    test_choicefield()
\ No newline at end of file
diff --git a/verify_fix.py b/verify_fix.py
new file mode 100644
index 0000000000..64a9921455
--- /dev/null
+++ b/verify_fix.py
@@ -0,0 +1,44 @@
+import django
+import os
+import sys
+
+# Set up Django settings
+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'django.conf.global_settings')
+
+# Import Django components
+django.setup()
+
+from django import forms
+from django.core.exceptions import ValidationError
+from django.forms.models import ModelChoiceField
+
+# Create a mock model and queryset for testing
+from django.db import models
+from django.db.models import QuerySet
+
+class MockModel(models.Model):
+    class DoesNotExist(Exception):
+        pass
+
+class MockQuerySet(QuerySet):
+    def __init__(self, *args, **kwargs):
+        super().__init__(*args, **kwargs)
+        self.model = MockModel
+
+# Test ModelChoiceField
+def test_modelchoicefield():
+    # Create a ModelChoiceField with an empty queryset
+    field = ModelChoiceField(queryset=MockQuerySet())
+
+    try:
+        field.to_python('invalid_value')
+    except ValidationError as e:
+        print("ModelChoiceField error message:", e.messages[0])
+        # Check if the error message includes the invalid value
+        assert "invalid_value" in e.messages[0], "Error message should include the invalid value"
+        print("✓ ModelChoiceField now includes the invalid value in the error message")
+
+if __name__ == "__main__":
+    print("Verifying fix for ModelChoiceField error messages:")
+    test_modelchoicefield()
+    print("\nThe fix is working correctly!")
\ No newline at end of file
