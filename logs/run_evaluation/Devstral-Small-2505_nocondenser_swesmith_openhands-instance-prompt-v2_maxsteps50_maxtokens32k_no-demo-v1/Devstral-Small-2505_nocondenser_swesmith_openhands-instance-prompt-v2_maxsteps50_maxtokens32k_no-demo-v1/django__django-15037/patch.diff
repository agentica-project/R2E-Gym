diff --git a/django/core/management/commands/inspectdb.py b/django/core/management/commands/inspectdb.py
index f9b4bfb477..3b9e676cbe 100644
--- a/django/core/management/commands/inspectdb.py
+++ b/django/core/management/commands/inspectdb.py
@@ -128,6 +128,15 @@ class Command(BaseCommand):
                             field_type = '%s(%s' % (rel_type, rel_to)
                         else:
                             field_type = "%s('%s'" % (rel_type, rel_to)
+
+                        # Check if the foreign key references a specific field
+                        for constraint in constraints.values():
+                            if (constraint['foreign_key'] is not None and
+                                len(constraint['columns']) == 1 and
+                                constraint['columns'][0] == column_name):
+                                referenced_table, referenced_column = constraint['foreign_key']
+                                if referenced_column != 'id':  # Only add to_field if not referencing the primary key
+                                    field_type += ", to_field='%s'" % referenced_column
                     else:
                         # Calling `get_field_type` to get the field type string and any
                         # additional parameters and notes.
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..b79e9bad0a
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,61 @@
+import os
+import sys
+import io
+from contextlib import redirect_stdout
+
+# Add the Django project to the Python path
+sys.path.insert(0, '/testbed')
+
+# Import Django
+import django
+from django.core.management import call_command
+from django.conf import settings
+
+# Configure Django settings
+settings.configure(
+    INSTALLED_APPS=[
+        'django.contrib.contenttypes',
+        'django.contrib.auth',
+    ],
+    DATABASES={
+        'default': {
+            'ENGINE': 'django.db.backends.postgresql',
+            'NAME': 'testdb',
+            'USER': 'postgres',
+            'PASSWORD': 'postgres',
+            'HOST': 'localhost',
+            'PORT': '5432',
+        }
+    }
+)
+
+django.setup()
+
+# Create tables as described in the issue
+from django.db import connection
+
+with connection.cursor() as cursor:
+    # Create tables
+    cursor.execute("""
+    CREATE TABLE foo (
+        id integer primary key,
+        other_id integer UNIQUE
+    )
+    """)
+
+    cursor.execute("""
+    CREATE TABLE bar (
+        id integer primary key,
+        other_id integer,
+        constraint myconst
+        FOREIGN KEY(other_id) references foo(other_id)
+    )
+    """)
+
+# Capture the output of inspectdb
+output = io.StringIO()
+with redirect_stdout(output):
+    call_command('inspectdb')
+
+# Print the output
+print(output.getvalue())
\ No newline at end of file
diff --git a/test_postgres_introspection.py b/test_postgres_introspection.py
new file mode 100644
index 0000000000..caafbebcf7
--- /dev/null
+++ b/test_postgres_introspection.py
@@ -0,0 +1,51 @@
+import sys
+import os
+sys.path.insert(0, '/testbed')
+
+from django.db.backends.postgresql.introspection import DatabaseIntrospection
+from django.db.backends.base.introspection import BaseDatabaseIntrospection
+
+# Mock a connection object
+class MockConnection:
+    def __init__(self):
+        self.features = type('obj', (object,), {
+            'supports_foreign_keys': True,
+            'ignores_table_name_case': True,
+            'ignores_column_case_in_alter': True,
+        })
+
+# Create an introspection instance
+introspection = DatabaseIntrospection(MockConnection())
+
+# Mock a cursor object
+class MockCursor:
+    def __init__(self, return_value):
+        self.return_value = return_value
+
+    def execute(self, sql, params=None):
+        self.sql = sql
+        self.params = params
+
+    def fetchall(self):
+        return self.return_value
+
+# Let's directly examine the issue in the inspectdb command
+from django.core.management.commands.inspectdb import Command
+
+# Create a command instance
+command = Command()
+
+# Let's look at how the foreign key is processed in the inspectdb command
+print("The issue is in how foreign keys to specific fields are handled in inspectdb.")
+print("When a foreign key references a specific field (not the primary key),")
+print("the generated model doesn't correctly specify the field name in the ForeignKey.")
+
+print("\nCurrent behavior:")
+print("If a foreign key references foo.other_id, the generated model will have:")
+print("    other_id = ForeignKey(Foo)")
+print("Instead of:")
+print("    other_id = ForeignKey(Foo, to_field='other_id')")
+
+print("\nThe fix needs to modify how foreign key constraints are processed in inspectdb.")
+print("Specifically, when a foreign key references a specific field, the to_field parameter")
+print("should be included in the generated ForeignKey field.")
\ No newline at end of file
diff --git a/verify_fix.py b/verify_fix.py
new file mode 100644
index 0000000000..3435125672
--- /dev/null
+++ b/verify_fix.py
@@ -0,0 +1,129 @@
+import sys
+import os
+sys.path.insert(0, '/testbed')
+
+import django
+from django.conf import settings
+from django.core.management.commands.inspectdb import Command
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        }
+    )
+    django.setup()
+
+# Create a command instance
+command = Command()
+
+# Mock the necessary objects
+class MockConnection:
+    def __init__(self):
+        self.features = type('obj', (object,), {})
+        self.introspection = MockIntrospection()
+
+class MockIntrospection:
+    def get_relations(self, cursor, table_name):
+        # Simulate a foreign key relationship from bar.other_id to foo.other_id
+        return {'other_id': ('other_id', 'foo')}
+
+    def get_constraints(self, cursor, table_name):
+        # Simulate a foreign key constraint that references a specific field
+        constraints = {
+            'myconst': {
+                'columns': ['other_id'],
+                'primary_key': False,
+                'unique': False,
+                'foreign_key': ('foo', 'other_id'),
+                'check': False,
+                'index': False,
+                'definition': None,
+                'options': None,
+            }
+        }
+        return constraints
+
+    def get_primary_key_column(self, cursor, table_name):
+        return 'id'
+
+    def get_table_description(self, cursor, table_name):
+        # Simulate table description
+        from django.db.backends.base.introspection import FieldInfo
+        return [
+            FieldInfo('id', 1, 10, 10, 0, 0, False, None),
+            FieldInfo('other_id', 1, 10, 10, 0, 0, True, None),
+        ]
+
+# Mock a cursor
+class MockCursor:
+    def __init__(self):
+        pass
+
+# Test the fix directly by examining the relevant code
+def test_fix():
+    from django.db.backends.base.introspection import FieldInfo
+
+    # Create a mock table description
+    table_description = [
+        FieldInfo('id', 1, 10, 10, 0, 0, False, None),
+        FieldInfo('other_id', 1, 10, 10, 0, 0, True, None),
+    ]
+
+    # Create mock constraints
+    constraints = {
+        'myconst': {
+            'columns': ['other_id'],
+            'primary_key': False,
+            'unique': False,
+            'foreign_key': ('foo', 'other_id'),
+            'check': False,
+            'index': False,
+            'definition': None,
+            'options': None,
+        }
+    }
+
+    # Create mock relations
+    relations = {'other_id': ('other_id', 'foo')}
+
+    # Create mock variables
+    used_column_names = ['id', 'other_id']
+    column_to_field_name = {'other_id': 'other_id'}
+    extra_params = {}
+    is_relation = True
+    table_name = 'bar'
+    known_models = ['Foo']
+    field_type = 'ForeignKey(Foo'
+
+    # Call the relevant code directly
+    for constraint in constraints.values():
+        if (constraint['foreign_key'] is not None and
+            len(constraint['columns']) == 1 and
+            constraint['columns'][0] == 'other_id'):
+            referenced_table, referenced_column = constraint['foreign_key']
+            if referenced_column != 'id':  # Only add to_field if not referencing the primary key
+                field_type += ", to_field='%s'" % referenced_column
+
+    field_type += ')'
+
+    # Print the result
+    print(f"Generated field: {field_type}")
+
+    # Verify that the foreign key includes the to_field parameter
+    if "to_field='other_id'" in field_type:
+        print("\nSuccess! The fix works. The foreign key includes the to_field parameter.")
+    else:
+        print("\nFailure! The fix doesn't work. The foreign key doesn't include the to_field parameter.")
+
+# Run the test
+if __name__ == '__main__':
+    test_fix()
\ No newline at end of file
