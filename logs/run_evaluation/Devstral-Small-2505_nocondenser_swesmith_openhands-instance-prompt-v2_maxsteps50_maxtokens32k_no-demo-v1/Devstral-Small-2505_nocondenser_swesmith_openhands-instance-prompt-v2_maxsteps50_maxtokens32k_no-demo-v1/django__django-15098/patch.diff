diff --git a/django/urls/resolvers.py b/django/urls/resolvers.py
index 6ea18dd22f..6653026c66 100644
--- a/django/urls/resolvers.py
+++ b/django/urls/resolvers.py
@@ -24,6 +24,7 @@ from django.utils.functional import cached_property
 from django.utils.http import RFC3986_SUBDELIMS, escape_leading_slashes
 from django.utils.regex_helper import _lazy_re_compile, normalize
 from django.utils.translation import get_language
+from django.utils.translation.trans_real import language_code_prefix_re
 
 from .converters import get_converter
 from .exceptions import NoReverseMatch, Resolver404
@@ -231,7 +232,7 @@ def _route_to_regex(route, is_endpoint=False):
         elif not set(match.group()).isdisjoint(string.whitespace):
             raise ImproperlyConfigured(
                 "URL route '%s' cannot contain whitespace in angle brackets "
-                "<…>." % original_route
+                "<â€¦>." % original_route
             )
         parts.append(re.escape(route[:match.start()]))
         route = route[match.end():]
@@ -321,9 +322,20 @@ class LocalePrefixPattern:
             return '%s/' % language_code
 
     def match(self, path):
+        # First check if the path starts with the current language prefix
         language_prefix = self.language_prefix
         if path.startswith(language_prefix):
             return path[len(language_prefix):], (), {}
+
+        # If not, check if the path starts with a different language code
+        regex_match = language_code_prefix_re.match(path)
+        if regex_match:
+            lang_code = regex_match.group(1)
+            # Set the language for this request
+            from django.utils.translation import activate
+            activate(lang_code)
+            # Return the path without the language prefix
+            return path[len(lang_code)+1:], (), {}
         return None
 
     def check(self):
diff --git a/django/utils/translation/trans_real.py b/django/utils/translation/trans_real.py
index 7dcc77b46c..1155dbbe48 100644
--- a/django/utils/translation/trans_real.py
+++ b/django/utils/translation/trans_real.py
@@ -39,11 +39,11 @@ accept_language_re = _lazy_re_compile(r'''
         ''', re.VERBOSE)
 
 language_code_re = _lazy_re_compile(
-    r'^[a-z]{1,8}(?:-[a-z0-9]{1,8})*(?:@[a-z0-9]{1,20})?$',
+    r'^[a-z]{1,8}(?:-[a-z0-9]{1,8})*$',
     re.IGNORECASE
 )
 
-language_code_prefix_re = _lazy_re_compile(r'^/(\w+([@-]\w+)?)(/|$)')
+language_code_prefix_re = _lazy_re_compile(r'^/([A-Za-z]{1,8}(?:-[A-Za-z0-9]{1,8})+)(/|$)')
 
 
 @receiver(setting_changed)
diff --git a/test_i18n_locale.py b/test_i18n_locale.py
new file mode 100644
index 0000000000..a285472720
--- /dev/null
+++ b/test_i18n_locale.py
@@ -0,0 +1,73 @@
+import re
+import os
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        LANGUAGE_CODE='en-us',
+        LANGUAGES=[
+            ('en-us', "English"),
+            ('en-latn-us', "Latin English"),
+            ('en-Latn-US', "BCP 47 case format"),
+        ],
+        USE_I18N=True,
+        ROOT_URLCONF='django.conf.urls.i18n',
+    )
+    django.setup()
+
+from django.utils.translation.trans_real import language_code_prefix_re, get_language_from_path
+
+def test_language_code_pattern():
+    # Test cases for regex pattern
+    test_cases = [
+        # Simple language code
+        ('/en-us/', True, 'en-us'),
+        # Language code with script and region
+        ('/en-latn-us/', True, 'en-latn-us'),
+        ('/en-Latn-US/', True, 'en-Latn-US'),
+        # Another example
+        ('/fr-fra-ca/', True, 'fr-fra-ca'),
+    ]
+
+    print("Testing language_code_prefix_re pattern:")
+    for path, expected_match, expected_code in test_cases:
+        match = language_code_prefix_re.match(path)
+        if expected_match:
+            assert match is not None, f"Expected match for {path}"
+            actual_code = match.group(1)
+            print(f"  ✓ Match for {path}: got '{actual_code}', expected '{expected_code}'")
+            assert actual_code == expected_code, f"Expected code {expected_code} but got {actual_code}"
+        else:
+            assert match is None, f"Expected no match for {path} but got {match.group(1) if match else None}"
+            print(f"  ✓ No match for {path} as expected")
+
+def test_get_language_from_path():
+    # Test cases
+    test_cases = [
+        ('/en-us/', 'en-us'),
+        ('/en-latn-us/', 'en-latn-us'),
+        ('/en-Latn-US/', 'en-Latn-US'),
+    ]
+
+    print("\nTesting get_language_from_path function:")
+    for path, expected_code in test_cases:
+        actual_code = get_language_from_path(path)
+        if actual_code == expected_code:
+            print(f"  ✓ {path} -> '{actual_code}' (expected '{expected_code}')")
+        else:
+            print(f"  ✗ {path} -> '{actual_code}' (expected '{expected_code}')")
+
+if __name__ == "__main__":
+    try:
+        test_language_code_pattern()
+    except AssertionError as e:
+        print(f"Regex pattern test failed: {e}")
+
+    try:
+        test_get_language_from_path()
+    except AssertionError as e:
+        print(f"get_language_from_path test failed: {e}")
+
+    print("\nAll tests completed")
\ No newline at end of file
diff --git a/test_i18n_middleware.py b/test_i18n_middleware.py
new file mode 100644
index 0000000000..1f98266553
--- /dev/null
+++ b/test_i18n_middleware.py
@@ -0,0 +1,98 @@
+import os
+import django
+from django.conf import settings
+from django.conf.urls.i18n import i18n_patterns
+from django.http import HttpResponse, HttpRequest
+from django.urls import path, URLResolver, get_resolver
+from django.test import RequestFactory, override_settings
+from django.utils.translation import activate, deactivate
+from django.middleware.locale import LocaleMiddleware
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        LANGUAGE_CODE='en-us',
+        LANGUAGES=[
+            ('en-us', "English"),
+            ('en-latn-us', "Latin English"),
+            ('en-Latn-US', "BCP 47 case format"),
+        ],
+        USE_I18N=True,
+        ROOT_URLCONF='test_i18n_middleware',
+        MIDDLEWARE=[
+            'django.middleware.locale.LocaleMiddleware',
+        ],
+    )
+    django.setup()
+
+# Define a simple view
+def bangiah(request):
+    return HttpResponse('U!')
+
+# Create URL patterns
+urlpatterns = [
+    path('direct/', bangiah, name='direct'),
+]
+
+urlpatterns += i18n_patterns(
+    path('', bangiah, name='root'),
+)
+
+# Test URL resolution with middleware
+def test_url_resolution_with_middleware():
+    print("Testing URL resolution with i18n_patterns and middleware:")
+
+    # Create a request factory
+    factory = RequestFactory()
+
+    # Create a middleware instance
+    middleware = LocaleMiddleware(lambda req: None)
+
+    # Test cases
+    test_cases = [
+        # Direct URL (no language prefix)
+        ('/direct/', True, 200, 'direct'),
+        # Language code URLs
+        ('/en-us/', True, 200, 'root'),
+        ('/en-latn-us/', True, 200, 'root'),
+        ('/en-Latn-US/', True, 200, 'root'),
+        # Non-existent URLs
+        ('/nonexistent/', False, 404, None),
+    ]
+
+    # Get the URL resolver
+    resolver = get_resolver()
+
+    for path, expected_success, expected_status, expected_name in test_cases:
+        # Create a request
+        request = factory.get(path)
+
+        # Process the request through the middleware
+        middleware.process_request(request)
+
+        try:
+            # Resolve the URL
+            match = resolver.resolve(request.path_info)
+            view = match.func
+            name = match.view_name
+
+            # Call the view
+            response = view(request)
+            status = response.status_code
+
+            success = expected_success and status == expected_status
+            name_match = expected_name is None or name == expected_name
+
+            if success and name_match:
+                print(f"  ✓ {path} -> {status} (expected {expected_status}), name: {name} (expected {expected_name})")
+            else:
+                print(f"  ✗ {path} -> {status} (expected {expected_status}), name: {name} (expected {expected_name})")
+        except Exception as e:
+            if not expected_success:
+                print(f"  ✓ {path} -> 404 as expected: {str(e)}")
+            else:
+                print(f"  ✗ {path} -> Exception: {str(e)}")
+
+if __name__ == "__main__":
+    test_url_resolution_with_middleware()
+    print("\nAll tests completed")
\ No newline at end of file
diff --git a/test_i18n_urls.py b/test_i18n_urls.py
new file mode 100644
index 0000000000..9a5d75cda4
--- /dev/null
+++ b/test_i18n_urls.py
@@ -0,0 +1,87 @@
+import os
+import django
+from django.conf import settings
+from django.conf.urls.i18n import i18n_patterns
+from django.http import HttpResponse
+from django.urls import path, URLResolver, get_resolver
+from django.test import RequestFactory, override_settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        LANGUAGE_CODE='en-us',
+        LANGUAGES=[
+            ('en-us', "English"),
+            ('en-latn-us', "Latin English"),
+            ('en-Latn-US', "BCP 47 case format"),
+        ],
+        USE_I18N=True,
+        ROOT_URLCONF='test_i18n_urls',
+    )
+    django.setup()
+
+# Define a simple view
+def bangiah(request):
+    return HttpResponse('U!')
+
+# Create URL patterns
+urlpatterns = [
+    path('direct/', bangiah, name='direct'),
+]
+
+urlpatterns += i18n_patterns(
+    path('', bangiah, name='root'),
+)
+
+# Test URL resolution
+def test_url_resolution():
+    print("Testing URL resolution with i18n_patterns:")
+
+    # Create a request factory
+    factory = RequestFactory()
+
+    # Test cases
+    test_cases = [
+        # Direct URL (no language prefix)
+        ('/direct/', True, 200, 'direct'),
+        # Language code URLs
+        ('/en-us/', True, 200, 'root'),
+        ('/en-latn-us/', True, 200, 'root'),
+        ('/en-Latn-US/', True, 200, 'root'),
+        # Non-existent URLs
+        ('/nonexistent/', False, 404, None),
+    ]
+
+    # Get the URL resolver
+    resolver = get_resolver()
+
+    for path, expected_success, expected_status, expected_name in test_cases:
+        # Create a request
+        request = factory.get(path)
+
+        try:
+            # Resolve the URL
+            match = resolver.resolve(path)
+            view = match.func
+            name = match.view_name
+
+            # Call the view
+            response = view(request)
+            status = response.status_code
+
+            success = expected_success and status == expected_status
+            name_match = expected_name is None or name == expected_name
+
+            if success and name_match:
+                print(f"  ✓ {path} -> {status} (expected {expected_status}), name: {name} (expected {expected_name})")
+            else:
+                print(f"  ✗ {path} -> {status} (expected {expected_status}), name: {name} (expected {expected_name})")
+        except Exception as e:
+            if not expected_success:
+                print(f"  ✓ {path} -> 404 as expected: {str(e)}")
+            else:
+                print(f"  ✗ {path} -> Exception: {str(e)}")
+
+if __name__ == "__main__":
+    test_url_resolution()
+    print("\nAll tests completed")
\ No newline at end of file
