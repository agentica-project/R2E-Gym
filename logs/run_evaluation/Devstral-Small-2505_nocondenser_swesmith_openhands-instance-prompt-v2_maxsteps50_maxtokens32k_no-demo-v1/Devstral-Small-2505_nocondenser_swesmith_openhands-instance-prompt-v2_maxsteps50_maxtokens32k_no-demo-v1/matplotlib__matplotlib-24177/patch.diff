diff --git a/final_verification.png b/final_verification.png
new file mode 100644
index 0000000000..13f33a5465
Binary files /dev/null and b/final_verification.png differ
diff --git a/final_verification.py b/final_verification.py
new file mode 100644
index 0000000000..9dedb0152a
--- /dev/null
+++ b/final_verification.py
@@ -0,0 +1,59 @@
+import numpy as np
+import matplotlib.pyplot as plt
+
+def test_different_distributions():
+    """Test density scaling with different distributions and scales."""
+
+    # Set a fixed seed for reproducibility
+    np.random.seed(42)
+
+    # Create a figure with multiple subplots
+    fig, axes = plt.subplots(3, 2, figsize=(15, 20))
+
+    # Test 1: Normal distribution with different scales
+    scales = [1.0, 1.5]
+    for i, scale in enumerate(scales):
+        # Generate normal data
+        normal_data = np.random.randn(10000) * scale
+
+        # Plot with different histtypes
+        axes[0, i].hist(normal_data, bins=50, density=True, histtype="bar", alpha=0.5)
+        axes[0, i].hist(normal_data, bins=50, density=True, histtype="step", color="red")
+        axes[0, i].set_title(f"Normal distribution, scale={scale}")
+
+    # Test 2: Uniform distribution
+    uniform_data = np.random.uniform(-5, 5, 10000)
+    axes[1, 0].hist(uniform_data, bins=50, density=True, histtype="bar", alpha=0.5)
+    axes[1, 0].hist(uniform_data, bins=50, density=True, histtype="step", color="red")
+    axes[1, 0].set_title("Uniform distribution")
+
+    # Test 3: Exponential distribution
+    exp_data = np.random.exponential(scale=2.0, size=10000)
+    axes[1, 1].hist(exp_data, bins=50, density=True, histtype="bar", alpha=0.5)
+    axes[1, 1].hist(exp_data, bins=50, density=True, histtype="step", color="red")
+    axes[1, 1].set_title("Exponential distribution")
+
+    # Test 4: Mixed distributions
+    mixed_data1 = np.random.randn(5000) * 1.0
+    mixed_data2 = np.random.randn(5000) * 1.5
+    axes[2, 0].hist([mixed_data1, mixed_data2], bins=50, density=True, histtype="bar", alpha=0.5, stacked=True)
+    axes[2, 0].hist([mixed_data1, mixed_data2], bins=50, density=True, histtype="step", color=["red", "orange"], stacked=True)
+    axes[2, 0].set_title("Mixed distributions (stacked)")
+
+    # Test 5: Unequal bin widths
+    bins = np.linspace(-10, 10, 20)
+    bin_widths = np.diff(bins)
+    normal_data = np.random.randn(10000)
+    axes[2, 1].hist(normal_data, bins=bins, density=True, histtype="bar", alpha=0.5)
+    axes[2, 1].hist(normal_data, bins=bins, density=True, histtype="step", color="red")
+    axes[2, 1].set_title("Unequal bin widths")
+
+    # Adjust layout and save
+    plt.tight_layout()
+    plt.savefig("final_verification.png")
+    plt.close()
+
+    print("Final verification complete. Check 'final_verification.png' for results.")
+
+if __name__ == "__main__":
+    test_different_distributions()
\ No newline at end of file
diff --git a/histogram_test_actual.png b/histogram_test_actual.png
new file mode 100644
index 0000000000..cdeb4af487
Binary files /dev/null and b/histogram_test_actual.png differ
diff --git a/histogram_test_expected.png b/histogram_test_expected.png
new file mode 100644
index 0000000000..8a76ad83c3
Binary files /dev/null and b/histogram_test_expected.png differ
diff --git a/lib/matplotlib/axes/_axes.py b/lib/matplotlib/axes/_axes.py
index 2412f815cd..5c5c830e92 100644
--- a/lib/matplotlib/axes/_axes.py
+++ b/lib/matplotlib/axes/_axes.py
@@ -6737,7 +6737,8 @@ such objects
             hist_kwargs['range'] = bin_range
 
         density = bool(density)
-        if density and not stacked:
+        # We'll handle density normalization for step histograms separately
+        if density and not stacked and not histtype.startswith('step'):
             hist_kwargs['density'] = density
 
         # List to store all the top coordinates of the histograms
@@ -6831,6 +6832,15 @@ such objects
             if bottom is None:
                 bottom = 0
 
+            # Apply density normalization if needed
+            if density and not stacked:
+                # For density=True, we need to normalize by bin width and total count
+                # numpy.histogram with density=True normalizes by bin width and total count
+                # We need to do the same for step histograms
+                total_count = np.sum(tops)
+                bin_widths = np.diff(bins)
+                tops = (tops.T / bin_widths / total_count).T
+
             y[1:2*len(bins)-1:2] = y[2:2*len(bins):2] = bottom
             y[2*len(bins)-1:] = y[1:2*len(bins)-1][::-1]
 
diff --git a/reproduce_hist_bug.py b/reproduce_hist_bug.py
new file mode 100644
index 0000000000..76c94d7493
--- /dev/null
+++ b/reproduce_hist_bug.py
@@ -0,0 +1,40 @@
+import numpy as np
+import matplotlib.pyplot as plt
+
+# Reproduce the issue with histtype='step' and density=True
+def reproduce_hist_bug():
+    scale = 1.2
+    test_random = np.random.randn(100000) * scale
+
+    fig, ax = plt.subplots(1, 2, figsize=(15, 7))
+    hist_bar = ax[0].hist(test_random, bins=100, density=True, histtype="bar")
+    hist_step = ax[1].hist(test_random, bins=100, density=True, histtype="step")
+
+    ax[0].set_title("histtype='bar'")
+    ax[1].set_title("histtype='step'")
+    ax[0].set_ylim(0, 0.015)
+    ax[1].set_ylim(0, 0.015)  # Manually setting the same ylim for comparison
+
+    plt.tight_layout()
+    plt.savefig("histogram_test_actual.png")
+    plt.close()
+
+    # Try with scale=1
+    scale = 1
+    test_random = np.random.randn(100000) * scale
+
+    fig, ax = plt.subplots(1, 2, figsize=(15, 7))
+    hist_bar = ax[0].hist(test_random, bins=100, density=True, histtype="bar")
+    hist_step = ax[1].hist(test_random, bins=100, density=True, histtype="step")
+
+    ax[0].set_title("histtype='bar'")
+    ax[1].set_title("histtype='step'")
+    ax[0].set_ylim(0, 0.015)
+    ax[1].set_ylim(0, 0.015)  # Manually setting the same ylim for comparison
+
+    plt.tight_layout()
+    plt.savefig("histogram_test_expected.png")
+    plt.close()
+
+if __name__ == "__main__":
+    reproduce_hist_bug()
\ No newline at end of file
diff --git a/verification_result.png b/verification_result.png
new file mode 100644
index 0000000000..b44f39e8c3
Binary files /dev/null and b/verification_result.png differ
diff --git a/verify_fix.py b/verify_fix.py
new file mode 100644
index 0000000000..dd80c326ef
--- /dev/null
+++ b/verify_fix.py
@@ -0,0 +1,57 @@
+import numpy as np
+import matplotlib.pyplot as plt
+
+def verify_fix():
+    # Set a fixed seed for reproducibility
+    np.random.seed(42)
+
+    # Test with different scales
+    scales = [1.0, 1.2, 2.0]
+    n_rows = len(scales)
+    fig, axes = plt.subplots(n_rows, 2, figsize=(15, 5 * n_rows))
+
+    if n_rows == 1:
+        axes = [axes]
+
+    for i, scale in enumerate(scales):
+        # Generate data with the current scale
+        test_random = np.random.randn(100000) * scale
+
+        # Calculate the expected maximum density value
+        # For a standard normal distribution, the max density is ~0.4
+        # When scaled by 'scale', the max density should be ~0.4 / scale
+        expected_max_density = 0.4 / scale
+
+        # Plot with bar histtype
+        hist_bar = axes[i][0].hist(test_random, bins=100, density=True, histtype="bar")
+        max_bar_density = max(hist_bar[0])
+
+        # Plot with step histtype
+        hist_step = axes[i][1].hist(test_random, bins=100, density=True, histtype="step")
+        max_step_density = max(hist_step[0])
+
+        # Set titles and print info
+        axes[i][0].set_title(f"histtype='bar', scale={scale}")
+        axes[i][1].set_title(f"histtype='step', scale={scale}")
+
+        # Print the max densities for comparison
+        print(f"Scale: {scale}")
+        print(f"  Max bar density: {max_bar_density:.6f}")
+        print(f"  Max step density: {max_step_density:.6f}")
+        print(f"  Expected max density: {expected_max_density:.6f}")
+        print(f"  Ratio (step/bar): {max_step_density/max_bar_density:.6f}")
+        print()
+
+        # Set the same ylim for both plots for comparison
+        ylim = max(max_bar_density, max_step_density) * 1.1
+        axes[i][0].set_ylim(0, ylim)
+        axes[i][1].set_ylim(0, ylim)
+
+    plt.tight_layout()
+    plt.savefig("verification_result.png")
+    plt.close()
+
+    print("Verification complete. Check 'verification_result.png' for visual comparison.")
+
+if __name__ == "__main__":
+    verify_fix()
\ No newline at end of file
