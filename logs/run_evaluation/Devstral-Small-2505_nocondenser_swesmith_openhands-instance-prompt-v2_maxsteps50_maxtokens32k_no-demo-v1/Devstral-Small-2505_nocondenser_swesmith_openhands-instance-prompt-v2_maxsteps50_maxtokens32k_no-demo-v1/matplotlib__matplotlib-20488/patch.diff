diff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py
index e0c42c5b69..97e3dded75 100644
--- a/lib/matplotlib/colors.py
+++ b/lib/matplotlib/colors.py
@@ -1473,8 +1473,16 @@ def _make_norm_from_scale(scale_cls, base_norm_cls=None, *, init=None):
                 value = np.clip(value, self.vmin, self.vmax)
             t_value = self._trf.transform(value).reshape(np.shape(value))
             t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])
-            if not np.isfinite([t_vmin, t_vmax]).all():
-                raise ValueError("Invalid vmin or vmax")
+
+            # Handle non-finite transformed vmin/vmax values
+            # If either is infinite or NaN, replace with finite values
+            if not np.isfinite(t_vmin):
+                # If t_vmin is non-finite, use a large negative value
+                t_vmin = -1000.0
+            if not np.isfinite(t_vmax):
+                # If t_vmax is non-finite, use a large positive value
+                t_vmax = 1000.0
+
             t_value -= t_vmin
             t_value /= (t_vmax - t_vmin)
             t_value = np.ma.masked_invalid(t_value, copy=False)
diff --git a/lib/matplotlib/scale.py b/lib/matplotlib/scale.py
index 62dc5192a3..5f561c0a2e 100644
--- a/lib/matplotlib/scale.py
+++ b/lib/matplotlib/scale.py
@@ -217,12 +217,29 @@ class LogTransform(Transform):
     def transform_non_affine(self, a):
         # Ignore invalid values due to nans being passed to the transform.
         with np.errstate(divide="ignore", invalid="ignore"):
+            # Make a copy to avoid modifying the input array
+            a_safe = a.copy()
+
+            # Clip extremely large values before taking the logarithm
+            # This prevents numerical instability in the transformation
+            if self._clip:
+                # For base > 1, clip values larger than exp(1000 * log(base))
+                # For base < 1, clip values smaller than exp(-1000 * log(base))
+                # 1000 is chosen to match the clipping value for negative numbers
+                if self.base > 1:
+                    max_val = np.exp(1000 * np.log(self.base))
+                    a_safe[a_safe > max_val] = max_val
+                elif self.base < 1:
+                    min_val = np.exp(-1000 * np.log(self.base))
+                    a_safe[a_safe < min_val] = min_val
+
             log = {np.e: np.log, 2: np.log2, 10: np.log10}.get(self.base)
             if log:  # If possible, do everything in a single call to NumPy.
-                out = log(a)
+                out = log(a_safe)
             else:
-                out = np.log(a)
+                out = np.log(a_safe)
                 out /= np.log(self.base)
+
             if self._clip:
                 # SVG spec says that conforming viewers must support values up
                 # to 3.4e38 (C float); however experiments suggest that
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..bf81ef39ce
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,45 @@
+import numpy as np
+import matplotlib.pyplot as plt
+import matplotlib.colors as colors
+import matplotlib.image as mimage
+import matplotlib.transforms as mtransforms
+
+# Create data with a huge range
+data = np.full((5, 5), -1, dtype=np.float64)
+data[0:2, :] = 1E20
+
+# Create a figure and axis
+fig, ax = plt.subplots()
+norm = colors.LogNorm(vmin=100, vmax=data.max())
+
+# Create an image object
+im = mimage.AxesImage(ax)
+im.set_data(data)
+im.set_norm(norm)
+
+# This should trigger the error
+try:
+    # Simulate what happens in the test more closely
+    bbox = mtransforms.Bbox([[0, 0], [1, 1]])
+    transformed_bbox = mtransforms.TransformedBbox(bbox, mtransforms.IdentityTransform())
+    clip_bbox = mtransforms.Bbox([[0, 0], [1, 1]])
+
+    # Create a masked array like in the test
+    masked_data = np.ma.masked_array(data, mask=data <= 0)
+
+    # Call _make_image directly with the masked data
+    im._make_image(masked_data, bbox, transformed_bbox, clip_bbox)
+    print("Transformation successful")
+except ValueError as e:
+    print(f"Error: {e}")
+
+# Also try direct normalization with masked array
+try:
+    masked_data = np.ma.masked_array(data, mask=data <= 0)
+    result = norm(masked_data)
+    print("Direct normalization successful")
+    print(f"Result shape: {result.shape}")
+    print(f"Result min: {result.min()}")
+    print(f"Result max: {result.max()}")
+except ValueError as e:
+    print(f"Direct normalization error: {e}")
\ No newline at end of file
