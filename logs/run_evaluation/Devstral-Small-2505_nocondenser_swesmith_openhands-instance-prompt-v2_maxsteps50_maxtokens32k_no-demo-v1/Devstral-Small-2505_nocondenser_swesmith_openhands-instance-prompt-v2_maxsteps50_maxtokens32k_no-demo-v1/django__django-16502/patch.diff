diff --git a/django/core/servers/basehttp.py b/django/core/servers/basehttp.py
index fef5532e58..d2e0247a43 100644
--- a/django/core/servers/basehttp.py
+++ b/django/core/servers/basehttp.py
@@ -128,6 +128,32 @@ class ServerHandler(simple_server.ServerHandler):
             LimitedStream(stdin, content_length), stdout, stderr, environ, **kwargs
         )
 
+    def finish_response(self):
+        """Send any iterable data, then close self and the iterable.
+
+        For HEAD requests, don't send any data as per RFC 2616, section 4.3.
+        """
+        if self.environ.get('REQUEST_METHOD') == 'HEAD':
+            self.close()
+            return
+
+        try:
+            if not self.result_is_file() or not self.sendfile():
+                for data in self.result:
+                    self.write(data)
+                self.finish_content()
+        except:
+            # Call close() on the iterable returned by the WSGI application
+            # in case of an exception.
+            if hasattr(self.result, 'close'):
+                self.result.close()
+            raise
+        else:
+            # We only call close() when no exception is raised, because it
+            # will set status, result, headers, and environ fields to None.
+            # See bpo-29183 for more details.
+            self.close()
+
     def cleanup_headers(self):
         super().cleanup_headers()
         # HTTP/1.1 requires support for persistent connections. Send 'close' if
diff --git a/test_head_request.py b/test_head_request.py
new file mode 100644
index 0000000000..5735a82a76
--- /dev/null
+++ b/test_head_request.py
@@ -0,0 +1,42 @@
+import subprocess
+import time
+import requests
+import sys
+import os
+
+def main():
+    # Start the development server in a separate process
+    server_process = subprocess.Popen(
+        ["python", "/testbed/manage.py", "runserver", "127.0.0.1:8000"],
+        stdout=subprocess.PIPE,
+        stderr=subprocess.PIPE,
+    )
+
+    try:
+        # Wait for the server to start
+        time.sleep(2)
+
+        # Send a HEAD request to the server
+        response = requests.head("http://127.0.0.1:8000/")
+
+        # Print the response
+        print("Status code:", response.status_code)
+        print("Headers:", dict(response.headers))
+        print("Content length:", len(response.content))
+        print("Content:", repr(response.content))
+
+        # Check if the response has a body
+        if len(response.content) > 0:
+            print("ISSUE DETECTED: HEAD request returned a body, which violates RFC 2616")
+            return 1
+        else:
+            print("SUCCESS: HEAD request did not return a body")
+            return 0
+
+    finally:
+        # Terminate the server process
+        server_process.terminate()
+        server_process.wait()
+
+if __name__ == "__main__":
+    sys.exit(main())
\ No newline at end of file
diff --git a/test_head_request_simple.py b/test_head_request_simple.py
new file mode 100644
index 0000000000..6c81dc0c47
--- /dev/null
+++ b/test_head_request_simple.py
@@ -0,0 +1,70 @@
+import io
+import socketserver
+import wsgiref.simple_server
+from django.core.servers.basehttp import ServerHandler, WSGIRequestHandler
+
+class StubSocket:
+    """A stub socket that captures sent data."""
+    def __init__(self):
+        self.data = b""
+
+    def sendall(self, data):
+        self.data += data
+
+class StubServer:
+    """A stub server for testing."""
+    def __init__(self, *args, **kwargs):
+        self.connections_override = None
+
+class StubRequestHandler:
+    """A stub request handler for testing."""
+    def __init__(self):
+        self.close_connection = False
+        self.server = StubServer()
+
+def simple_app(environ, start_response):
+    """A simple WSGI application that returns a response."""
+    status = '200 OK'
+    response_headers = [('Content-type', 'text/plain; charset=utf-8')]
+    start_response(status, response_headers)
+    return [b"Hello, World!"]
+
+def test_head_request():
+    """Test that HEAD requests don't return a body."""
+    # Create a mock environment for a HEAD request
+    environ = {
+        'REQUEST_METHOD': 'HEAD',
+        'PATH_INFO': '/',
+        'QUERY_STRING': '',
+        'SERVER_NAME': 'localhost',
+        'SERVER_PORT': '80',
+        'SERVER_PROTOCOL': 'HTTP/1.1',
+    }
+
+    # Create mock I/O objects
+    stdin = io.BytesIO()
+    stdout = StubSocket()
+    stderr = io.StringIO()
+
+    # Create the ServerHandler with request_handler attribute
+    handler = ServerHandler(stdin, stdout, stderr, environ)
+    handler.request_handler = StubRequestHandler()
+
+    # Run the application
+    handler.run(simple_app)
+
+    # Check if any data was written to stdout
+    response_body = stdout.data
+
+    print(f"Response body length: {len(response_body)}")
+    print(f"Response body: {repr(response_body)}")
+
+    if len(response_body) > 0:
+        print("ISSUE DETECTED: HEAD request returned a body, which violates RFC 2616")
+        return 1
+    else:
+        print("SUCCESS: HEAD request did not return a body")
+        return 0
+
+if __name__ == "__main__":
+    exit(test_head_request())
\ No newline at end of file
diff --git a/test_server_handler.py b/test_server_handler.py
new file mode 100644
index 0000000000..063169ae89
--- /dev/null
+++ b/test_server_handler.py
@@ -0,0 +1,49 @@
+import io
+import wsgiref.simple_server
+from django.core.servers.basehttp import ServerHandler
+
+def simple_app(environ, start_response):
+    """A simple WSGI application that returns a response."""
+    status = '200 OK'
+    response_headers = [('Content-type', 'text/plain; charset=utf-8')]
+    start_response(status, response_headers)
+    return [b"Hello, World!"]
+
+def test_head_request():
+    """Test that HEAD requests don't return a body."""
+    # Create a mock environment for a HEAD request
+    environ = {
+        'REQUEST_METHOD': 'HEAD',
+        'PATH_INFO': '/',
+        'QUERY_STRING': '',
+        'SERVER_NAME': 'localhost',
+        'SERVER_PORT': '80',
+        'SERVER_PROTOCOL': 'HTTP/1.1',
+    }
+
+    # Create mock I/O objects
+    stdin = io.BytesIO()
+    stdout = io.BytesIO()
+    stderr = io.StringIO()
+
+    # Create the ServerHandler
+    handler = ServerHandler(stdin, stdout, stderr, environ)
+
+    # Run the application
+    handler.run(simple_app)
+
+    # Check if any data was written to stdout
+    response_body = stdout.getvalue()
+
+    print(f"Response body length: {len(response_body)}")
+    print(f"Response body: {repr(response_body)}")
+
+    if len(response_body) > 0:
+        print("ISSUE DETECTED: HEAD request returned a body, which violates RFC 2616")
+        return 1
+    else:
+        print("SUCCESS: HEAD request did not return a body")
+        return 0
+
+if __name__ == "__main__":
+    exit(test_head_request())
\ No newline at end of file
diff --git a/verify_fix.py b/verify_fix.py
new file mode 100644
index 0000000000..4330fc1c14
--- /dev/null
+++ b/verify_fix.py
@@ -0,0 +1,70 @@
+import io
+import socketserver
+import wsgiref.simple_server
+from django.core.servers.basehttp import ServerHandler, WSGIRequestHandler
+
+class StubSocket:
+    """A stub socket that captures sent data."""
+    def __init__(self):
+        self.data = b""
+
+    def sendall(self, data):
+        self.data += data
+
+class StubServer:
+    """A stub server for testing."""
+    def __init__(self, *args, **kwargs):
+        self.connections_override = None
+
+    def get_app(self):
+        return simple_app
+
+def simple_app(environ, start_response):
+    """A simple WSGI application that returns a response."""
+    status = '200 OK'
+    response_headers = [('Content-type', 'text/plain; charset=utf-8'),
+                       ('Content-Length', '13')]
+    start_response(status, response_headers)
+    return [b"Hello, World!"]
+
+def test_head_request():
+    """Test that HEAD requests don't return a body."""
+    # Create a mock environment for a HEAD request
+    environ = {
+        'REQUEST_METHOD': 'HEAD',
+        'PATH_INFO': '/',
+        'QUERY_STRING': '',
+        'SERVER_NAME': 'localhost',
+        'SERVER_PORT': '80',
+        'SERVER_PROTOCOL': 'HTTP/1.1',
+    }
+
+    # Create mock I/O objects
+    stdin = io.BytesIO()
+    stdout = StubSocket()
+    stderr = io.StringIO()
+
+    # Create the ServerHandler with request_handler attribute
+    handler = ServerHandler(stdin, stdout, stderr, environ)
+    handler.request_handler = WSGIRequestHandler(None, ('localhost', 80), StubServer)
+    handler.request_handler.server = StubServer()
+    handler.request_handler.close_connection = False
+
+    # Run the application
+    handler.run(simple_app)
+
+    # Check if any data was written to stdout
+    response_body = stdout.data
+
+    print(f"Response body length: {len(response_body)}")
+    print(f"Response body: {repr(response_body)}")
+
+    if len(response_body) > 0:
+        print("ISSUE DETECTED: HEAD request returned a body, which violates RFC 2616")
+        return 1
+    else:
+        print("SUCCESS: HEAD request did not return a body")
+        return 0
+
+if __name__ == "__main__":
+    exit(test_head_request())
\ No newline at end of file
diff --git a/verify_fix_direct.py b/verify_fix_direct.py
new file mode 100644
index 0000000000..8c82981b13
--- /dev/null
+++ b/verify_fix_direct.py
@@ -0,0 +1,63 @@
+import io
+import socket
+import socketserver
+import threading
+import time
+import requests
+import subprocess
+import sys
+import os
+
+def run_server():
+    """Run the Django development server in a separate process."""
+    server_process = subprocess.Popen(
+        ["python", "-c", """
+import os
+os.chdir('/testbed')
+from django.core.management.commands.runserver import Command
+Command().run(addr='127.0.0.1', port=8000)
+        """],
+        stdout=subprocess.PIPE,
+        stderr=subprocess.PIPE,
+    )
+    return server_process
+
+def test_head_request():
+    """Test that HEAD requests don't return a body."""
+    server_process = None
+    try:
+        # Start the server
+        server_process = run_server()
+
+        # Wait for the server to start
+        time.sleep(2)
+
+        # Send a HEAD request to the server
+        response = requests.head("http://127.0.0.1:8000/")
+
+        # Print the response details
+        print("Status code:", response.status_code)
+        print("Headers:", dict(response.headers))
+        print("Content length:", len(response.content))
+        print("Content:", repr(response.content))
+
+        # Check if the response has a body
+        if len(response.content) > 0:
+            print("ISSUE DETECTED: HEAD request returned a body, which violates RFC 2616")
+            return 1
+        else:
+            print("SUCCESS: HEAD request did not return a body")
+            return 0
+
+    except Exception as e:
+        print(f"Error: {e}")
+        return 1
+
+    finally:
+        # Terminate the server process if it's running
+        if server_process:
+            server_process.terminate()
+            server_process.wait()
+
+if __name__ == "__main__":
+    exit(test_head_request())
\ No newline at end of file
diff --git a/verify_fix_minimal.py b/verify_fix_minimal.py
new file mode 100644
index 0000000000..6ce96c1d6d
--- /dev/null
+++ b/verify_fix_minimal.py
@@ -0,0 +1,88 @@
+import io
+import socket
+import socketserver
+import threading
+import time
+import requests
+import subprocess
+import sys
+import os
+
+def main():
+    """Test that HEAD requests don't return a body."""
+    # Create a simple WSGI application
+    app_file = "/tmp/test_app.py"
+    with open(app_file, "w") as f:
+        f.write("""
+def simple_app(environ, start_response):
+    status = '200 OK'
+    response_headers = [('Content-type', 'text/plain; charset=utf-8')]
+    start_response(status, response_headers)
+    return [b"Hello, World!"]
+""")
+
+    # Create a server script
+    server_file = "/tmp/test_server.py"
+    with open(server_file, "w") as f:
+        f.write("""
+import io
+import socketserver
+import wsgiref.simple_server
+from django.core.servers.basehttp import ServerHandler
+
+# Import the app
+from test_app import simple_app
+
+# Create a socket to listen on
+server_address = ('127.0.0.1', 8000)
+httpd = wsgiref.simple_server.WSGIServer(server_address, wsgiref.simple_server.WSGIRequestHandler)
+
+# Override the handler class
+httpd.RequestHandlerClass = wsgiref.simple_server.WSGIRequestHandler
+
+# Run the server
+httpd.set_app(simple_app)
+print("Server running on http://127.0.0.1:8000/")
+httpd.serve_forever()
+""")
+
+    # Start the server
+    server_process = subprocess.Popen(
+        ["python", server_file],
+        stdout=subprocess.PIPE,
+        stderr=subprocess.PIPE,
+    )
+
+    try:
+        # Wait for the server to start
+        time.sleep(2)
+
+        # Send a HEAD request to the server
+        response = requests.head("http://127.0.0.1:8000/")
+
+        # Print the response details
+        print("Status code:", response.status_code)
+        print("Headers:", dict(response.headers))
+        print("Content length:", len(response.content))
+        print("Content:", repr(response.content))
+
+        # Check if the response has a body
+        if len(response.content) > 0:
+            print("ISSUE DETECTED: HEAD request returned a body, which violates RFC 2616")
+            return 1
+        else:
+            print("SUCCESS: HEAD request did not return a body")
+            return 0
+
+    except Exception as e:
+        print(f"Error: {e}")
+        return 1
+
+    finally:
+        # Terminate the server process if it's running
+        if server_process:
+            server_process.terminate()
+            server_process.wait()
+
+if __name__ == "__main__":
+    exit(main())
\ No newline at end of file
diff --git a/verify_fix_simple.py b/verify_fix_simple.py
new file mode 100644
index 0000000000..10c14b4dfc
--- /dev/null
+++ b/verify_fix_simple.py
@@ -0,0 +1,59 @@
+import io
+import socketserver
+import wsgiref.simple_server
+from django.core.servers.basehttp import ServerHandler
+
+def simple_app(environ, start_response):
+    """A simple WSGI application that returns a response."""
+    status = '200 OK'
+    response_headers = [('Content-type', 'text/plain; charset=utf-8'),
+                       ('Content-Length', '13')]
+    start_response(status, response_headers)
+    return [b"Hello, World!"]
+
+def test_head_request():
+    """Test that HEAD requests don't return a body."""
+    # Create a mock environment for a HEAD request
+    environ = {
+        'REQUEST_METHOD': 'HEAD',
+        'PATH_INFO': '/',
+        'QUERY_STRING': '',
+        'SERVER_NAME': 'localhost',
+        'SERVER_PORT': '80',
+        'SERVER_PROTOCOL': 'HTTP/1.1',
+    }
+
+    # Create mock I/O objects
+    stdin = io.BytesIO()
+    stdout = io.BytesIO()
+    stderr = io.StringIO()
+
+    # Create the ServerHandler
+    handler = ServerHandler(stdin, stdout, stderr, environ)
+
+    # Mock the request_handler attribute
+    class MockRequestHandler:
+        def __init__(self):
+            self.close_connection = False
+            self.server = None
+
+    handler.request_handler = MockRequestHandler()
+
+    # Run the application
+    handler.run(simple_app)
+
+    # Check if any data was written to stdout
+    response_body = stdout.getvalue()
+
+    print(f"Response body length: {len(response_body)}")
+    print(f"Response body: {repr(response_body)}")
+
+    if len(response_body) > 0:
+        print("ISSUE DETECTED: HEAD request returned a body, which violates RFC 2616")
+        return 1
+    else:
+        print("SUCCESS: HEAD request did not return a body")
+        return 0
+
+if __name__ == "__main__":
+    exit(test_head_request())
\ No newline at end of file
