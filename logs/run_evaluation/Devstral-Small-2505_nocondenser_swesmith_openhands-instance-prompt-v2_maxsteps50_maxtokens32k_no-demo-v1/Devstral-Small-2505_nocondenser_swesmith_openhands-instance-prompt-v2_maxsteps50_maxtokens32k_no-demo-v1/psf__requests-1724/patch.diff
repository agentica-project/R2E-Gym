diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100755
index 00000000..b1b039a6
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,91 @@
+#!/usr/bin/env python
+# -*- coding: utf-8 -*-
+
+"""
+Script to reproduce the Unicode method name issue in requests.
+"""
+
+import sys
+import os
+
+# Add the testbed directory to the path so we can import the local requests
+sys.path.insert(0, os.path.abspath('/testbed'))
+
+# Import the local requests module directly
+import requests.models
+import requests.sessions
+import requests.api
+from requests.models import Request
+from requests.sessions import Session
+from requests.api import request
+
+# For Python 3 compatibility
+try:
+    unicode = unicode  # noqa: F821 - undefined name 'unicode'
+except NameError:
+    # In Python 3, unicode is str
+    unicode = str
+
+def simulate_python2_behavior(method_value):
+    """
+    Simulate the behavior in Python 2.7 where:
+    - If method_value is a str (bytes), it works fine
+    - If method_value is a unicode object, it causes UnicodeDecodeError when used with httplib
+    """
+    # In Python 2.7, the issue happens when the method is a unicode object
+    # and it's used in httplib.py which expects a str (bytes)
+
+    # For our simulation, we'll use a more direct approach
+    # In Python 2.7, if method_value is unicode, it would cause issues
+    # when used in the HTTP connection
+
+    # In Python 2.7, str is bytes and unicode is unicode
+    # In Python 3, str is unicode and bytes is bytes
+
+    # Let's simulate the behavior by checking the type
+    # In Python 3, we need to check if it's the "unicode" type from Python 2
+    # which is now the "str" type in Python 3
+
+    # For our simulation, we'll consider any string-like object that's not bytes
+    # as potentially causing the issue in Python 2.7
+
+    if sys.version_info[0] >= 3:
+        # In Python 3
+        if isinstance(method_value, str):
+            # In Python 3, str is unicode, which would be problematic in Python 2.7
+            return "Unicode method would cause UnicodeDecodeError in Python 2.7"
+        elif isinstance(method_value, bytes):
+            # In Python 3, bytes is bytes, which would be fine in Python 2.7
+            return "String method would work fine in Python 2.7"
+        else:
+            # Other types wouldn't be used as HTTP methods
+            return "Unknown type"
+    else:
+        # In Python 2, we'd just check if it's unicode
+        if isinstance(method_value, unicode):  # noqa: F821
+            return "Unicode method would cause UnicodeDecodeError in Python 2.7"
+        else:
+            return "String method would work fine in Python 2.7"
+
+def test_with_string_method():
+    """Test with string method name (should work)."""
+    method_value = 'POST'
+    result = simulate_python2_behavior(method_value)
+    print(f"String method test: {result}")
+    # Return True if it would work in Python 2.7
+    return "work fine" in result
+
+def test_with_unicode_method():
+    """Test with unicode method name (should fail with UnicodeDecodeError)."""
+    method_value = u'POST'
+    result = simulate_python2_behavior(method_value)
+    print(f"Unicode method test: {result}")
+    # Return False if it would cause UnicodeDecodeError in Python 2.7
+    return "UnicodeDecodeError" not in result
+
+if __name__ == "__main__":
+    print("Testing with string method name:")
+    test_with_string_method()
+
+    print("\nTesting with unicode method name:")
+    test_with_unicode_method()
\ No newline at end of file
