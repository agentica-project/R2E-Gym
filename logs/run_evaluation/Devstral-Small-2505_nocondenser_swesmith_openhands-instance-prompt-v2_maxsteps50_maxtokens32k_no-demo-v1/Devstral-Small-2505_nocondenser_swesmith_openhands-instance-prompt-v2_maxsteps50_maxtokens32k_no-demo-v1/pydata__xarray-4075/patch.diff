diff --git a/comprehensive_test.py b/comprehensive_test.py
new file mode 100644
index 00000000..f3dc70e3
--- /dev/null
+++ b/comprehensive_test.py
@@ -0,0 +1,75 @@
+import numpy as np
+import xarray as xr
+
+def test_boolean_weights():
+    """Test weighted mean with boolean weights."""
+    dta = xr.DataArray([1., 1., 1.])
+    wgt = xr.DataArray(np.array([1, 1, 0], dtype=bool))
+
+    # Current behavior with fix
+    result = dta.weighted(wgt).mean()
+    print("Boolean weights test:")
+    print("Result:", result)
+    print("Expected: 1.0")
+    print("Pass:", np.isclose(result, 1.0))
+    print()
+
+def test_mixed_weights():
+    """Test with a mix of boolean and numeric weights."""
+    dta = xr.DataArray([1., 2., 3., 4.])
+    bool_wgt = xr.DataArray(np.array([True, False, True, False], dtype=bool))
+    numeric_wgt = xr.DataArray([1, 2, 3, 4])
+
+    # With boolean weights
+    result_bool = dta.weighted(bool_wgt).mean()
+    print("Mixed weights test (boolean):")
+    print("Result:", result_bool)
+    print("Expected: 2.0 (average of 1 and 3)")
+    print("Pass:", np.isclose(result_bool, 2.0))
+
+    # With numeric weights
+    result_numeric = dta.weighted(numeric_wgt).mean()
+    print("\nMixed weights test (numeric):")
+    print("Result:", result_numeric)
+    print("Expected: 3.0 ((1*1 + 3*3) / (1+3))")
+    print("Pass:", np.isclose(result_numeric, 3.0))
+    print()
+
+def test_edge_cases():
+    """Test edge cases."""
+    # All False weights
+    dta = xr.DataArray([1., 2., 3.])
+    wgt = xr.DataArray(np.array([False, False, False], dtype=bool))
+    result = dta.weighted(wgt).mean()
+    print("Edge case - all False weights:")
+    print("Result:", result)
+    print("Expected: NaN")
+    print("Pass:", np.isnan(result))
+
+    # All True weights
+    wgt = xr.DataArray(np.array([True, True, True], dtype=bool))
+    result = dta.weighted(wgt).mean()
+    print("\nEdge case - all True weights:")
+    print("Result:", result)
+    print("Expected: 2.0 (average of 1, 2, 3)")
+    print("Pass:", np.isclose(result, 2.0))
+    print()
+
+def test_dimension_reduction():
+    """Test with dimension reduction."""
+    dta = xr.DataArray([[1., 2.], [3., 4.]], dims=("x", "y"))
+    wgt = xr.DataArray([[[True, False], [False, True]]], dims=("z", "x", "y"))
+
+    # Reduce over x dimension
+    result = dta.weighted(wgt).mean(dim="x")
+    print("Dimension reduction test:")
+    print("Result:", result)
+    print("Expected shape: (y: 2, z: 1)")
+    print("Pass:", result.shape == (2, 1) and result.dims == ('y', 'z'))
+    print("Values:", result.values)
+
+if __name__ == "__main__":
+    test_boolean_weights()
+    test_mixed_weights()
+    test_edge_cases()
+    test_dimension_reduction()
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 00000000..999276d8
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,20 @@
+import numpy as np
+import xarray as xr
+
+# Reproduce the issue
+dta = xr.DataArray([1., 1., 1.])
+wgt = xr.DataArray(np.array([1, 1, 0], dtype=np.bool))
+
+# Current behavior
+result = dta.weighted(wgt).mean()
+print("Current result:", result)
+
+# Expected behavior
+# The sum of weights should be 2 (1+1), not True
+# So the weighted mean should be (1*1 + 1*1) / 2 = 1
+print("Expected result: <xarray.DataArray ()>\narray(1.)")
+
+# Let's also check the sum_of_weights directly
+sum_of_weights = wgt.dot(dta.notnull())
+print("\nSum of weights (current):", sum_of_weights)
+print("Sum of weights (expected):", wgt.dot(dta.notnull() * 1))
\ No newline at end of file
diff --git a/xarray/core/weighted.py b/xarray/core/weighted.py
index 996d2e4c..99f60289 100644
--- a/xarray/core/weighted.py
+++ b/xarray/core/weighted.py
@@ -1,5 +1,7 @@
 from typing import TYPE_CHECKING, Hashable, Iterable, Optional, Union, overload
 
+import numpy as np
+
 from .computation import dot
 from .options import _get_keep_attrs
 
@@ -142,7 +144,12 @@ class Weighted:
         # we need to mask data values that are nan; else the weights are wrong
         mask = da.notnull()
 
-        sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
+        # Convert boolean weights to integers to avoid boolean arithmetic issues
+        weights = self.weights
+        if weights.dtype == np.bool_ or weights.dtype == bool:
+            weights = weights * 1
+
+        sum_of_weights = self._reduce(mask, weights, dim=dim, skipna=False)
 
         # 0-weights are not valid
         valid_weights = sum_of_weights != 0.0
