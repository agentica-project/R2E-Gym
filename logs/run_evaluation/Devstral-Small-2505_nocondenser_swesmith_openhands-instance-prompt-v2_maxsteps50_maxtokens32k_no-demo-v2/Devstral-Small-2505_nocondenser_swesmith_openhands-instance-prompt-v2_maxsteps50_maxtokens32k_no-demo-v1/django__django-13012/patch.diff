diff --git a/comprehensive_test.py b/comprehensive_test.py
new file mode 100644
index 0000000000..6278a7717e
--- /dev/null
+++ b/comprehensive_test.py
@@ -0,0 +1,107 @@
+import os
+import django
+from django.conf import settings
+from django.db import models
+from django.db.models import IntegerField, Value, ExpressionWrapper, Sum, F, Q
+
+# Set up Django
+if not settings.configured:
+    settings.configure(
+        SECRET_KEY='fake-key',
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+        ],
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        }
+    )
+    django.setup()
+
+# Create a simple model
+class Model(models.Model):
+    column_a = models.CharField(max_length=100)
+    column_b = models.IntegerField()
+    column_c = models.IntegerField()
+
+    class Meta:
+        # We don't need to create an actual table for this test
+        app_label = 'comprehensive_test'
+        managed = False
+
+def test_constant_value():
+    """Test with a constant value."""
+    print("Test with constant value:")
+    query1 = Model.objects.annotate(expr_res=ExpressionWrapper(Value(3), output_field=IntegerField()))
+    query2 = Model.objects.annotate(expr_res=Value(3, output_field=IntegerField()))
+    print(f"With ExpressionWrapper: {str(query1.query)}")
+    print(f"Without ExpressionWrapper: {str(query2.query)}")
+    print()
+
+def test_field_reference():
+    """Test with a field reference."""
+    print("Test with field reference:")
+    query1 = Model.objects.annotate(expr_res=ExpressionWrapper(F('column_b'), output_field=IntegerField()))
+    query2 = Model.objects.annotate(expr_res=F('column_b'))
+    print(f"With ExpressionWrapper: {str(query1.query)}")
+    print(f"Without ExpressionWrapper: {str(query2.query)}")
+    print()
+
+def test_complex_expression():
+    """Test with a complex expression."""
+    print("Test with complex expression:")
+    expr = ExpressionWrapper(F('column_b') + Value(1), output_field=IntegerField())
+    query = Model.objects.annotate(expr_res=expr).values('expr_res', 'column_a').annotate(sum=Sum('column_c'))
+    print(f"Complex expression: {str(query.query)}")
+    print()
+
+def test_multiple_annotations():
+    """Test with multiple annotations."""
+    print("Test with multiple annotations:")
+    query = Model.objects.annotate(
+        expr1=ExpressionWrapper(Value(3), output_field=IntegerField()),
+        expr2=ExpressionWrapper(F('column_b'), output_field=IntegerField())
+    ).values('expr1', 'expr2', 'column_a').annotate(sum=Sum('column_c'))
+    print(f"Multiple annotations: {str(query.query)}")
+    print()
+
+def test_filtering():
+    """Test with filtering."""
+    print("Test with filtering:")
+    query = Model.objects.filter(
+        column_b=ExpressionWrapper(Value(3), output_field=IntegerField())
+    )
+    print(f"Filtering with ExpressionWrapper: {str(query.query)}")
+    print()
+
+def test_issue_description():
+    """Test the specific issue described in the problem statement."""
+    print("Test the specific issue described in the problem statement:")
+
+    # Function that reproduces the issue
+    def execQuery_with_wrapper(expr):
+        expr = ExpressionWrapper(expr, output_field=IntegerField())
+        query = Model.objects.annotate(expr_res=expr).values('expr_res', 'column_a').annotate(sum=Sum('column_b'))
+        return str(query.query)
+
+    # Function that works correctly
+    def execQuery_without_wrapper():
+        query = Model.objects.annotate(expr_res=Value(3, output_field=IntegerField())).values('expr_res', 'column_a').annotate(sum=Sum('column_b'))
+        return str(query.query)
+
+    print("With ExpressionWrapper:")
+    print(execQuery_with_wrapper(Value(3)))
+    print("\nWithout ExpressionWrapper:")
+    print(execQuery_without_wrapper())
+    print()
+
+# Run all tests
+if __name__ == "__main__":
+    test_constant_value()
+    test_field_reference()
+    test_complex_expression()
+    test_multiple_annotations()
+    test_filtering()
+    test_issue_description()
\ No newline at end of file
diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py
index c1a76584f0..c6e188754e 100644
--- a/django/db/models/expressions.py
+++ b/django/db/models/expressions.py
@@ -568,7 +568,7 @@ class ResolvedOuterRef(F):
         col = super().resolve_expression(*args, **kwargs)
         # FIXME: Rename possibly_multivalued to multivalued and fix detection
         # for non-multivalued JOINs (e.g. foreign key fields). This should take
-        # into account only many-to-many and one-to-many relationships.
+        # into accountÂ only many-to-many and one-to-many relationships.
         col.possibly_multivalued = LOOKUP_SEP in self.name
         return col
 
@@ -866,6 +866,13 @@ class ExpressionWrapper(Expression):
     def as_sql(self, compiler, connection):
         return self.expression.as_sql(compiler, connection)
 
+    def get_group_by_cols(self, alias=None):
+        # If the wrapped expression is a constant (like Value), it should not be
+        # included in the GROUP BY clause
+        if hasattr(self.expression, 'get_group_by_cols') and not self.expression.contains_column_references:
+            return []
+        return super().get_group_by_cols(alias)
+
     def __repr__(self):
         return "{}({})".format(self.__class__.__name__, self.expression)
 
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..351613a9dd
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,50 @@
+import os
+import django
+from django.conf import settings
+from django.db import models
+from django.db.models import IntegerField, Value, ExpressionWrapper, Sum
+
+# Set up Django
+if not settings.configured:
+    settings.configure(
+        SECRET_KEY='fake-key',
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+        ],
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        }
+    )
+    django.setup()
+
+# Create a simple model
+class Model(models.Model):
+    column_a = models.CharField(max_length=100)
+    column_b = models.IntegerField()
+
+    class Meta:
+        # We don't need to create an actual table for this test
+        app_label = 'reproduce_issue'
+        managed = False
+
+# Function that reproduces the issue
+def execQuery_with_wrapper(expr):
+    expr = ExpressionWrapper(expr, output_field=IntegerField())
+    # We're not actually executing the query, just printing the SQL
+    query = Model.objects.annotate(expr_res=expr).values('expr_res', 'column_a').annotate(sum=Sum('column_b'))
+    return str(query.query)
+
+# Function that works correctly
+def execQuery_without_wrapper():
+    # We're not actually executing the query, just printing the SQL
+    query = Model.objects.annotate(expr_res=Value(3, output_field=IntegerField())).values('expr_res', 'column_a').annotate(sum=Sum('column_b'))
+    return str(query.query)
+
+# Test the functions
+print("With ExpressionWrapper:")
+print(execQuery_with_wrapper(Value(3)))
+print("\nWithout ExpressionWrapper:")
+print(execQuery_without_wrapper())
\ No newline at end of file
