diff --git a/astropy/io/fits/card.py b/astropy/io/fits/card.py
index 8c1ac5d738..ce7787fa7a 100644
--- a/astropy/io/fits/card.py
+++ b/astropy/io/fits/card.py
@@ -551,6 +551,11 @@ class Card(_Verify):
         if it is not the length of a card image (80 columns).  If the card
         image is longer than 80 columns, assume it contains ``CONTINUE``
         card(s).
+
+        Parameters
+        ----------
+        image : str or bytes
+            The card image as a string or bytes object.
         """
 
         card = cls()
@@ -689,45 +694,83 @@ class Card(_Verify):
         self._rawvalue = field
 
     def _parse_keyword(self):
-        keyword = self._image[:KEYWORD_LENGTH].strip()
-        keyword_upper = keyword.upper()
-
-        if keyword_upper in self._special_keywords:
-            return keyword_upper
-        elif (keyword_upper == 'HIERARCH' and self._image[8] == ' ' and
-              HIERARCH_VALUE_INDICATOR in self._image):
-            # This is valid HIERARCH card as described by the HIERARCH keyword
-            # convention:
-            # http://fits.gsfc.nasa.gov/registry/hierarch_keyword.html
-            self._hierarch = True
-            self._value_indicator = HIERARCH_VALUE_INDICATOR
-            keyword = self._image.split(HIERARCH_VALUE_INDICATOR, 1)[0][9:]
-            return keyword.strip()
+        """Parse the keyword from the card image."""
+        # Handle bytes or string input
+        if isinstance(self._image, bytes):
+            keyword = self._image[:KEYWORD_LENGTH].strip()
+            keyword_upper = keyword.upper().decode('ascii', errors='replace')
+
+            if keyword_upper in self._special_keywords:
+                return keyword_upper.decode('ascii', errors='replace')
+            elif (keyword_upper == 'HIERARCH' and self._image[8] == b' ' and
+                  HIERARCH_VALUE_INDICATOR.encode('ascii') in self._image):
+                self._hierarch = True
+                self._value_indicator = HIERARCH_VALUE_INDICATOR.encode('ascii')
+                keyword = self._image.split(HIERARCH_VALUE_INDICATOR.encode('ascii'), 1)[0][9:]
+                return keyword.strip().decode('ascii', errors='replace')
+            else:
+                val_ind_idx = self._image.find(VALUE_INDICATOR.encode('ascii'))
+                if 0 <= val_ind_idx <= KEYWORD_LENGTH:
+                    # The value indicator should appear in byte 8, but we are
+                    # flexible and allow this to be fixed
+                    if val_ind_idx < KEYWORD_LENGTH:
+                        keyword = keyword[:val_ind_idx]
+                        keyword_upper = keyword_upper[:val_ind_idx]
+
+                    rest = self._image[val_ind_idx + VALUE_INDICATOR_LEN:]
+
+                    # So far this looks like a standard FITS keyword; check whether
+                    # the value represents a RVKC; if so then we pass things off to
+                    # the RVKC parser
+                    if self._check_if_rvkc_image(keyword, rest):
+                        return self._keyword
+
+                    return keyword_upper.decode('ascii', errors='replace')
+                else:
+                    warnings.warn(
+                        'The following header keyword is invalid or follows an '
+                        'unrecognized non-standard convention:\n{}'
+                        .format(self._image), AstropyUserWarning)
+                    self._invalid = True
+                    return keyword.decode('ascii', errors='replace')
         else:
-            val_ind_idx = self._image.find(VALUE_INDICATOR)
-            if 0 <= val_ind_idx <= KEYWORD_LENGTH:
-                # The value indicator should appear in byte 8, but we are
-                # flexible and allow this to be fixed
-                if val_ind_idx < KEYWORD_LENGTH:
-                    keyword = keyword[:val_ind_idx]
-                    keyword_upper = keyword_upper[:val_ind_idx]
-
-                rest = self._image[val_ind_idx + VALUE_INDICATOR_LEN:]
-
-                # So far this looks like a standard FITS keyword; check whether
-                # the value represents a RVKC; if so then we pass things off to
-                # the RVKC parser
-                if self._check_if_rvkc_image(keyword, rest):
-                    return self._keyword
+            # String input
+            keyword = self._image[:KEYWORD_LENGTH].strip()
+            keyword_upper = keyword.upper()
 
+            if keyword_upper in self._special_keywords:
                 return keyword_upper
+            elif (keyword_upper == 'HIERARCH' and self._image[8] == ' ' and
+                  HIERARCH_VALUE_INDICATOR in self._image):
+                self._hierarch = True
+                self._value_indicator = HIERARCH_VALUE_INDICATOR
+                keyword = self._image.split(HIERARCH_VALUE_INDICATOR, 1)[0][9:]
+                return keyword.strip()
             else:
-                warnings.warn(
-                    'The following header keyword is invalid or follows an '
-                    'unrecognized non-standard convention:\n{}'
-                    .format(self._image), AstropyUserWarning)
-                self._invalid = True
-                return keyword
+                val_ind_idx = self._image.find(VALUE_INDICATOR)
+                if 0 <= val_ind_idx <= KEYWORD_LENGTH:
+                    # The value indicator should appear in byte 8, but we are
+                    # flexible and allow this to be fixed
+                    if val_ind_idx < KEYWORD_LENGTH:
+                        keyword = keyword[:val_ind_idx]
+                        keyword_upper = keyword_upper[:val_ind_idx]
+
+                    rest = self._image[val_ind_idx + VALUE_INDICATOR_LEN:]
+
+                    # So far this looks like a standard FITS keyword; check whether
+                    # the value represents a RVKC; if so then we pass things off to
+                    # the RVKC parser
+                    if self._check_if_rvkc_image(keyword, rest):
+                        return self._keyword
+
+                    return keyword_upper
+                else:
+                    warnings.warn(
+                        'The following header keyword is invalid or follows an '
+                        'unrecognized non-standard convention:\n{}'
+                        .format(self._image), AstropyUserWarning)
+                    self._invalid = True
+                    return keyword
 
     def _parse_value(self):
         """Extract the keyword value from the card image."""
@@ -1277,9 +1320,15 @@ def _pad(input):
         if strlen == 0:
             return input
         else:
-            return input + ' ' * (Card.length - strlen)
+            if isinstance(input, bytes):
+                return input + b' ' * (Card.length - strlen)
+            else:
+                return input + ' ' * (Card.length - strlen)
 
     # minimum length is 80
     else:
         strlen = _len % Card.length
-        return input + ' ' * (Card.length - strlen)
+        if isinstance(input, bytes):
+            return input + b' ' * (Card.length - strlen)
+        else:
+            return input + ' ' * (Card.length - strlen)
diff --git a/astropy/io/fits/header.py b/astropy/io/fits/header.py
index ad07e6d52d..9ff2ccdced 100644
--- a/astropy/io/fits/header.py
+++ b/astropy/io/fits/header.py
@@ -334,19 +334,24 @@ class Header:
 
         Parameters
         ----------
-        data : str
-           String containing the entire header.
+        data : str or bytes
+           String or bytes containing the entire header.
 
-        sep : str, optional
-            The string separating cards from each other, such as a newline.  By
-            default there is no card separator (as is the case in a raw FITS
-            file).
+        sep : str or bytes, optional
+            The string or bytes separating cards from each other, such as a
+            newline.  By default there is no card separator (as is the case in
+            a raw FITS file).
 
         Returns
         -------
         header
             A new `Header` instance.
         """
+        # Handle bytes input by decoding to unicode
+        if isinstance(data, bytes):
+            data = decode_ascii(data)
+            if isinstance(sep, bytes):
+                sep = decode_ascii(sep)
 
         cards = []
 
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..22df89226c
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,43 @@
+#!/usr/bin/env python
+"""
+Script to reproduce the issue with Header.fromstring not accepting bytes.
+"""
+
+from astropy.io import fits
+
+# Create a simple FITS header as a string
+header_str = "SIMPLE  =                    T / conforms to FITS standard\n"
+header_str += "BITPIX  =                    8 / array data type\n"
+header_str += "NAXIS   =                    0 / number of array dimensions\n"
+header_str += "END\n"
+
+print("Testing with unicode string (should work):")
+try:
+    header1 = fits.Header.fromstring(header_str)
+    print("Success! Header created from unicode string.")
+    print(header1)
+except Exception as e:
+    print(f"Failed: {e}")
+
+print("\nTesting with bytes (currently fails):")
+try:
+    header2 = fits.Header.fromstring(header_str.encode('ascii'))
+    print("Success! Header created from bytes.")
+    print(header2)
+except Exception as e:
+    print(f"Failed: {e}")
+
+print("\nTesting Card.fromstring with bytes:")
+try:
+    # Get just the SIMPLE card
+    simple_card_str = "SIMPLE  =                    T / conforms to FITS standard"
+    simple_card_bytes = simple_card_str.encode('ascii')
+    print(f"Input type: {type(simple_card_bytes)}")
+    card = fits.Card.fromstring(simple_card_bytes)
+    print("Success! Card created from bytes.")
+    print(f"Card._image type: {type(card._image)}")
+    print(card)
+except Exception as e:
+    import traceback
+    print(f"Failed: {e}")
+    traceback.print_exc()
\ No newline at end of file
