diff --git a/django/forms/fields.py b/django/forms/fields.py
index 36dad72704..4e06c9b296 100644
--- a/django/forms/fields.py
+++ b/django/forms/fields.py
@@ -341,6 +341,8 @@ class DecimalField(IntegerField):
         """
         if value in self.empty_values:
             return None
+        if isinstance(value, dict):
+            raise ValidationError(self.error_messages['invalid'], code='invalid')
         if self.localize:
             value = formats.sanitize_separators(value)
         value = str(value).strip()
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..208fbff8e1
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,99 @@
+import sys
+import os
+
+# Add the testbed directory to the Python path
+sys.path.insert(0, '/testbed')
+
+# Configure Django settings
+from django.conf import settings
+if not settings.configured:
+    settings.configure(
+        INSTALLED_APPS=[
+            'django.contrib.admin',
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+            'django.contrib.sessions',
+            'django.contrib.messages',
+            'django.contrib.staticfiles',
+        ],
+        USE_I18N=False,
+    )
+
+from django.forms import DecimalField
+from django.core.exceptions import ValidationError
+from django.utils import formats
+
+def test_decimal_field_with_dict():
+    """Test that DecimalField.to_python() raises ValidationError, not TypeError, when given a dict."""
+    field = DecimalField(max_digits=5, decimal_places=2)
+
+    # Let's trace through the execution to see what's happening
+    print("Testing with a dictionary value...")
+
+    # First, let's see what happens when we try to convert the dict to a string
+    test_dict = {"key": "value"}
+    print(f"String representation of dict: {str(test_dict)}")
+
+    # Let's look at the to_python method to understand what's happening
+    print("\nAnalyzing to_python method:")
+    print("1. If value is in empty_values, return None")
+    print("2. If value is a dict, raise ValidationError directly")
+    print("3. If localized, sanitize separators")
+    print("4. Convert value to string and strip")
+    print("5. Try to create Decimal from string")
+    print("6. If DecimalException, raise ValidationError")
+
+    # Let's try to reproduce the issue by manually stepping through the code
+    print("\nManually stepping through the code with the fix:")
+
+    # Step 1: Check if value is in empty_values
+    print(f"Is dict in empty_values? {test_dict in field.empty_values}")
+
+    # Step 2: Check if value is a dict (our fix)
+    print(f"Is value a dict? {isinstance(test_dict, dict)}")
+    print("With our fix, this would raise ValidationError directly")
+
+    # Step 3: If localized, sanitize separators
+    if field.localize:
+        test_dict = formats.sanitize_separators(test_dict)
+        print(f"After sanitize_separators: {test_dict}")
+
+    # Step 4: Convert value to string and strip
+    try:
+        str_value = str(test_dict).strip()
+        print(f"String representation: {str_value}")
+    except TypeError as e:
+        print(f"TypeError during str(): {e}")
+        print("This is the issue - TypeError before ValidationError")
+
+    # Step 5: Try to create Decimal from string
+    try:
+        from decimal import Decimal, DecimalException
+        decimal_value = Decimal(str_value)
+        print(f"Decimal value: {decimal_value}")
+    except DecimalException as e:
+        print(f"DecimalException: {e}")
+        print("This would raise ValidationError")
+    except TypeError as e:
+        print(f"TypeError during Decimal(): {e}")
+        print("This is the issue - TypeError before ValidationError")
+
+    # Now let's try to run to_python with the dict
+    print("\nRunning to_python with the dict (should raise ValidationError):")
+    try:
+        result = field.to_python(test_dict)
+        print("UNEXPECTED: No exception was raised")
+        return False
+    except TypeError as e:
+        print(f"ISSUE REPRODUCED: TypeError was raised: {e}")
+        return True
+    except ValidationError as e:
+        print(f"FIXED: ValidationError was raised: {e}")
+        return False
+    except Exception as e:
+        print(f"UNEXPECTED: Other exception was raised: {e}")
+        return False
+
+if __name__ == "__main__":
+    issue_exists = test_decimal_field_with_dict()
+    sys.exit(1 if issue_exists else 0)
\ No newline at end of file
diff --git a/test_decimal_field_fix.py b/test_decimal_field_fix.py
new file mode 100644
index 0000000000..3903d710b1
--- /dev/null
+++ b/test_decimal_field_fix.py
@@ -0,0 +1,54 @@
+import unittest
+import sys
+import os
+
+# Add the testbed directory to the Python path
+sys.path.insert(0, '/testbed')
+
+# Configure Django settings
+from django.conf import settings
+if not settings.configured:
+    settings.configure(
+        INSTALLED_APPS=[
+            'django.contrib.admin',
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+            'django.contrib.sessions',
+            'django.contrib.messages',
+            'django.contrib.staticfiles',
+        ],
+        USE_I18N=False,
+    )
+
+from django.forms import DecimalField
+from django.core.exceptions import ValidationError
+
+class DecimalFieldTest(unittest.TestCase):
+    def test_decimal_field_with_dict(self):
+        """Test that DecimalField.to_python() raises ValidationError, not TypeError, when given a dict."""
+        field = DecimalField(max_digits=5, decimal_places=2)
+        test_dict = {"key": "value"}
+
+        with self.assertRaises(ValidationError):
+            field.to_python(test_dict)
+
+    def test_decimal_field_with_valid_value(self):
+        """Test that DecimalField.to_python() works correctly with valid values."""
+        field = DecimalField(max_digits=5, decimal_places=2)
+
+        from decimal import Decimal
+
+        # Test with string
+        self.assertEqual(field.to_python("12.34"), Decimal("12.34"))
+
+        # Test with int
+        self.assertEqual(field.to_python(123), Decimal("123"))
+
+        # Test with float
+        self.assertEqual(field.to_python(12.34), Decimal("12.34"))
+
+        # Test with None
+        self.assertIsNone(field.to_python(None))
+
+if __name__ == "__main__":
+    unittest.main()
\ No newline at end of file
