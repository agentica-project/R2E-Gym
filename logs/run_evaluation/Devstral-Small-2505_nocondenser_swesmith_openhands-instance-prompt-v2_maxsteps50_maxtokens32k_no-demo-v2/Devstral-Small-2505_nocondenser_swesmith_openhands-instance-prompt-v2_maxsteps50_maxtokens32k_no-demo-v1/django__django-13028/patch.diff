diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py
index ce18098fd2..7f20771def 100644
--- a/django/db/models/sql/query.py
+++ b/django/db/models/sql/query.py
@@ -1124,7 +1124,10 @@ class Query(BaseExpression):
 
     def check_filterable(self, expression):
         """Raise an error if expression cannot be used in a WHERE clause."""
-        if not getattr(expression, 'filterable', True):
+        # Check if the expression has a filterable attribute that's explicitly set to False
+        # We need to be careful not to confuse model fields named 'filterable' with
+        # the internal filterable attribute used by Django
+        if hasattr(expression, 'filterable') and getattr(expression, 'filterable') is False:
             raise NotSupportedError(
                 expression.__class__.__name__ + ' is disallowed in the filter '
                 'clause.'
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..30409b9226
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,92 @@
+import os
+import sys
+import django
+from django.db import models, NotSupportedError
+from django.utils import timezone
+
+# Set up Django settings
+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'test_settings')
+django.setup()
+
+# Define the models from the issue description
+class Produit(models.Model):
+    name = models.CharField(max_length=255)
+
+    def __str__(self):
+        return self.name
+
+class Plateforme(models.Model):
+    name = models.CharField(max_length=255)
+
+    def __str__(self):
+        return self.name
+
+class ProductMetaDataType(models.Model):
+    label = models.CharField(max_length=255, unique=True, blank=False, null=False)
+    filterable = models.BooleanField(default=False, verbose_name="filterable")
+
+    def __str__(self):
+        return self.label
+
+class ProductMetaData(models.Model):
+    id = models.BigAutoField(primary_key=True)
+    product = models.ForeignKey(Produit, null=False, blank=False, on_delete=models.CASCADE)
+    value = models.TextField(null=False, blank=False)
+    marketplace = models.ForeignKey(Plateforme, null=False, blank=False, on_delete=models.CASCADE)
+    date_created = models.DateTimeField(null=True, default=timezone.now)
+    metadata_type = models.ForeignKey(ProductMetaDataType, null=False, blank=False, on_delete=models.CASCADE)
+
+# Create test data
+def create_test_data():
+    # Create a product
+    product = Produit.objects.create(name="Test Product")
+
+    # Create a platform
+    platform = Plateforme.objects.create(name="Test Platform")
+
+    # Create a metadata type with filterable=True
+    metadata_type = ProductMetaDataType.objects.create(
+        label="Test Metadata",
+        filterable=True
+    )
+
+    # Create metadata
+    metadata = ProductMetaData.objects.create(
+        product=product,
+        value="Test Value",
+        marketplace=platform,
+        metadata_type=metadata_type
+    )
+
+    return metadata_type
+
+def test_filter():
+    # Create test data
+    metadata_type = create_test_data()
+
+    try:
+        # Try to filter ProductMetaData with metadata_type
+        results = ProductMetaData.objects.filter(value="Test Value", metadata_type=metadata_type)
+        print("Filter successful!")
+        return True
+    except NotSupportedError as e:
+        print(f"Error: {e}")
+        return False
+
+if __name__ == "__main__":
+    # Create tables
+    Produit._meta.db_table = 'test_produit'
+    Plateforme._meta.db_table = 'test_plateforme'
+    ProductMetaDataType._meta.db_table = 'test_productmetadata_type'
+    ProductMetaData._meta.db_table = 'test_productmetadata'
+
+    # Run the test
+    success = test_filter()
+
+    # Clean up
+    ProductMetaData.objects.all().delete()
+    ProductMetaDataType.objects.all().delete()
+    Plateforme.objects.all().delete()
+    Produit.objects.all().delete()
+
+    sys.exit(0 if success else 1)
\ No newline at end of file
diff --git a/test_direct.py b/test_direct.py
new file mode 100644
index 0000000000..5a93a669c5
--- /dev/null
+++ b/test_direct.py
@@ -0,0 +1,67 @@
+import sys
+import os
+
+# Add the testbed directory to the Python path
+sys.path.insert(0, '/testbed')
+
+# Import the relevant modules
+from django.db.models.sql.query import Query
+from django.db import NotSupportedError
+
+# Create a mock class with a filterable attribute
+class MockModel:
+    filterable = True
+
+    def __str__(self):
+        return "MockModel"
+
+# Create a mock class with filterable=False
+class NonFilterableModel:
+    filterable = False
+
+    def __str__(self):
+        return "NonFilterableModel"
+
+# Create a mock model field named filterable
+class ModelWithFilterableField:
+    def __init__(self):
+        self.filterable = "This is a field, not a boolean flag"
+
+    def __str__(self):
+        return "ModelWithFilterableField"
+
+# Test the check_filterable method
+def test_check_filterable():
+    # Create a Query instance
+    query = Query(None)
+
+    # Test with a filterable model
+    try:
+        query.check_filterable(MockModel())
+        print("Filterable model test passed")
+    except NotSupportedError as e:
+        print(f"Filterable model test failed: {e}")
+        return False
+
+    # Test with a non-filterable model
+    try:
+        query.check_filterable(NonFilterableModel())
+        print("Non-filterable model test unexpectedly passed")
+        return False
+    except NotSupportedError as e:
+        print(f"Non-filterable model test passed with expected error: {e}")
+
+    # Test with a model that has a field named filterable
+    model_with_field = ModelWithFilterableField()
+    try:
+        query.check_filterable(model_with_field)
+        print("Model with filterable field test passed - field not confused with attribute")
+    except NotSupportedError as e:
+        print(f"Model with filterable field test failed: {e}")
+        return False
+
+    return True
+
+if __name__ == "__main__":
+    success = test_check_filterable()
+    sys.exit(0 if success else 1)
\ No newline at end of file
diff --git a/test_filterable.py b/test_filterable.py
new file mode 100644
index 0000000000..f041043142
--- /dev/null
+++ b/test_filterable.py
@@ -0,0 +1,85 @@
+import os
+import sys
+import django
+from django.db import models, NotSupportedError
+from django.utils import timezone
+
+# Set up Django settings
+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'django.conf.global_settings')
+
+# Create a custom settings object
+class Settings:
+    SECRET_KEY = 'fake-key-for-testing'
+    INSTALLED_APPS = [
+        'django.contrib.contenttypes',
+        'django.contrib.auth',
+    ]
+    DATABASES = {
+        'default': {
+            'ENGINE': 'django.db.backends.sqlite3',
+            'NAME': ':memory:',
+        }
+    }
+    ROOT_URLCONF = 'django.urls'
+    TIME_ZONE = 'UTC'
+    USE_TZ = True
+    LOGGING_CONFIG = None
+    LOGGING = {}
+
+# Set the settings
+django.settings = Settings()
+django.setup = lambda: None  # Override setup to do nothing
+
+# Define the models from the issue description
+class Produit(models.Model):
+    name = models.CharField(max_length=255)
+
+    def __str__(self):
+        return self.name
+
+class Plateforme(models.Model):
+    name = models.CharField(max_length=255)
+
+    def __str__(self):
+        return self.name
+
+class ProductMetaDataType(models.Model):
+    label = models.CharField(max_length=255, unique=True, blank=False, null=False)
+    filterable = models.BooleanField(default=False, verbose_name="filterable")
+
+    def __str__(self):
+        return self.label
+
+class ProductMetaData(models.Model):
+    id = models.BigAutoField(primary_key=True)
+    product = models.ForeignKey(Produit, null=False, blank=False, on_delete=models.CASCADE)
+    value = models.TextField(null=False, blank=False)
+    marketplace = models.ForeignKey(Plateforme, null=False, blank=False, on_delete=models.CASCADE)
+    date_created = models.DateTimeField(null=True, default=timezone.now)
+    metadata_type = models.ForeignKey(ProductMetaDataType, null=False, blank=False, on_delete=models.CASCADE)
+
+# Create a test for the issue
+def test_filterable_field():
+    # Create a ProductMetaDataType instance with filterable=True
+    metadata_type = ProductMetaDataType(filterable=True, label="Test Metadata")
+
+    # Create a filter Q object
+    from django.db.models import Q
+    q = Q(metadata_type=metadata_type)
+
+    # This should trigger the check_filterable method
+    try:
+        # Simulate what happens in the query.py file
+        from django.db.models.sql.query import SQLQuery
+        query = SQLQuery(models.ProductMetaData)
+        query.check_filterable(metadata_type)
+        print("Test passed - no error raised")
+        return True
+    except NotSupportedError as e:
+        print(f"Test failed - Error: {e}")
+        return False
+
+if __name__ == "__main__":
+    # Run the test
+    success = test_filterable_field()
+    sys.exit(0 if success else 1)
\ No newline at end of file
diff --git a/test_settings.py b/test_settings.py
new file mode 100644
index 0000000000..be80bc7bcc
--- /dev/null
+++ b/test_settings.py
@@ -0,0 +1,18 @@
+import os
+from django.conf.global_settings import *
+
+# Required settings
+SECRET_KEY = 'fake-key-for-testing'
+INSTALLED_APPS = [
+    'django.contrib.contenttypes',
+    'django.contrib.auth',
+]
+DATABASES = {
+    'default': {
+        'ENGINE': 'django.db.backends.sqlite3',
+        'NAME': ':memory:',
+    }
+}
+ROOT_URLCONF = 'django.urls'
+TIME_ZONE = 'UTC'
+USE_TZ = True
\ No newline at end of file
