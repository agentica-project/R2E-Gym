diff --git a/analyze_issue.py b/analyze_issue.py
new file mode 100644
index 0000000000..509063b9c3
--- /dev/null
+++ b/analyze_issue.py
@@ -0,0 +1,47 @@
+#!/usr/bin/env python
+"""
+This script analyzes the issue with models.E015 being raised when ordering uses lookups that are not transforms.
+"""
+
+import sys
+from django.db.models.query_utils import RegisterLookupMixin
+from django.db.models.lookups import IsNull, Transform
+
+def analyze_get_transform():
+    """Analyze the get_transform method in RegisterLookupMixin."""
+    print("Analyzing get_transform method in RegisterLookupMixin:")
+
+    # Create a mock field with a get_transform method
+    class MockField:
+        def __init__(self, lookup_name, lookup_class):
+            self.lookup_name = lookup_name
+            self.lookup_class = lookup_class
+
+        def get_transform(self, lookup_name):
+            if lookup_name == self.lookup_name:
+                return self.lookup_class
+            return None
+
+    # Test with a Transform lookup
+    transform_field = MockField('transform', Transform)
+    transform_result = transform_field.get_transform('transform')
+    print(f"Transform lookup result: {transform_result}")
+    print(f"Is Transform? {isinstance(transform_result, type) and issubclass(transform_result, Transform)}")
+
+    # Test with an IsNull lookup
+    isnull_field = MockField('isnull', IsNull)
+    isnull_result = isnull_field.get_transform('isnull')
+    print(f"IsNull lookup result: {isnull_result}")
+    print(f"Is Transform? {isnull_result is not None and issubclass(isnull_result, Transform)}")
+
+    # This is the key issue - IsNull is not a subclass of Transform
+    print(f"Is IsNull a subclass of Transform? {issubclass(IsNull, Transform)}")
+
+    # In the current code, the check is:
+    # if found is not None and not issubclass(found, Transform):
+    #     return None
+    #
+    # This rejects IsNull because it's not a subclass of Transform
+
+if __name__ == "__main__":
+    analyze_get_transform()
\ No newline at end of file
diff --git a/django/db/models/base.py b/django/db/models/base.py
index 6c9e9d3707..1a6ae1933b 100644
--- a/django/db/models/base.py
+++ b/django/db/models/base.py
@@ -1747,6 +1747,12 @@ class Model(metaclass=ModelBase):
                     else:
                         _cls = None
                 except (FieldDoesNotExist, AttributeError):
+                    # If this is a lookup (starts with underscore), it's valid for ordering
+                    # even if it's not a transform
+                    if part.startswith('_'):
+                        continue
+
+                    # For regular field parts, check if they exist and are valid transforms
                     if fld is None or fld.get_transform(part) is None:
                         errors.append(
                             checks.Error(
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100755
index 0000000000..aa75e57516
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,51 @@
+#!/usr/bin/env python
+import os
+import sys
+import django
+from django.db import models
+from django.apps import apps
+from django.core.management import call_command
+from io import StringIO
+
+# Set up Django
+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'django.conf.global_settings')
+django.setup()
+
+# Define models similar to those in the issue
+class Product(models.Model):
+    name = models.CharField(max_length=80)
+    parent = models.ForeignKey('self', models.CASCADE, null=True)
+
+    class Meta:
+        app_label = 'reproduce_issue'
+
+class Supply(models.Model):
+    product = models.ForeignKey(Product, models.CASCADE)
+
+    class Meta:
+        app_label = 'reproduce_issue'
+
+class Stock(models.Model):
+    supply = models.ForeignKey(Supply, models.CASCADE)
+
+    class Meta:
+        app_label = 'reproduce_issue'
+        ordering = ['supply__product__parent__isnull']  # This should be valid
+
+# Register the models
+app_config = apps.get_app_config('reproduce_issue')
+app_config.models['Product'] = Product
+app_config.models['Supply'] = Supply
+app_config.models['Stock'] = Stock
+
+# Run the check command and capture output
+out = StringIO()
+sys.stdout = out
+try:
+    call_command('check')
+    print("Check passed!")
+except SystemExit as e:
+    print(f"Check failed with exit code {e.code}")
+sys.stdout = sys.__stdout__
+
+print(out.getvalue())
\ No newline at end of file
diff --git a/test_ordering_validation.py b/test_ordering_validation.py
new file mode 100644
index 0000000000..d030eff5eb
--- /dev/null
+++ b/test_ordering_validation.py
@@ -0,0 +1,58 @@
+#!/usr/bin/env python
+import os
+import sys
+from django.db import models
+from django.core.checks import Error
+from django.db.models.base import ModelBase
+
+# Add the issue description to the file for reference
+ISSUE_DESCRIPTION = """
+models.E015 is raised when ordering uses lookups that are not transforms.
+Description
+
+./manage.py check
+SystemCheckError: System check identified some issues:
+ERRORS:
+app.Stock: (models.E015) 'ordering' refers to the nonexistent field, related field, or lookup 'supply__product__parent__isnull'.
+However this ordering works fine:
+>>> list(Stock.objects.order_by('supply__product__parent__isnull').values_list('pk', flat=True)[:5])
+[1292, 1293, 1300, 1295, 1294]
+>>> list(Stock.objects.order_by('-supply__product__parent__isnull').values_list('pk', flat=True)[:5])
+[108, 109, 110, 23, 107]
+I believe it was fine until #29408 was implemented.
+Stock.supply is a foreign key to Supply, Supply.product is a foreign key to Product, Product.parent is a ForeignKey('self', models.CASCADE, null=True)
+"""
+
+def test_ordering_validation():
+    """Test that ordering validation correctly handles lookups like __isnull."""
+
+    # Define models similar to those in the issue
+    class Product(models.Model):
+        name = models.CharField(max_length=80)
+        parent = models.ForeignKey('self', models.CASCADE, null=True)
+
+    class Supply(models.Model):
+        product = models.ForeignKey(Product, models.CASCADE)
+
+    class Stock(models.Model):
+        supply = models.ForeignKey(Supply, models.CASCADE)
+
+        class Meta:
+            ordering = ['supply__product__parent__isnull']
+
+    # Check if the model passes validation
+    errors = ModelBase._check_ordering(Stock)
+
+    # Print the errors
+    if errors:
+        print("Validation failed with errors:")
+        for error in errors:
+            print(f"  - {error}")
+        return False
+    else:
+        print("Validation passed!")
+        return True
+
+if __name__ == "__main__":
+    print(ISSUE_DESCRIPTION)
+    test_ordering_validation()
\ No newline at end of file
diff --git a/verify_fix.py b/verify_fix.py
new file mode 100644
index 0000000000..87fdde1be9
--- /dev/null
+++ b/verify_fix.py
@@ -0,0 +1,44 @@
+#!/usr/bin/env python
+"""
+This script verifies that the fix for models.E015 works correctly.
+"""
+
+import os
+import sys
+import django
+from django.db import models
+from django.core.checks import Error
+from django.db.models.base import ModelBase
+
+def verify_fix():
+    """Verify that the fix for models.E015 works correctly."""
+
+    # Define models similar to those in the issue
+    class Product(models.Model):
+        name = models.CharField(max_length=80)
+        parent = models.ForeignKey('self', models.CASCADE, null=True)
+
+    class Supply(models.Model):
+        product = models.ForeignKey(Product, models.CASCADE)
+
+    class Stock(models.Model):
+        supply = models.ForeignKey(Supply, models.CASCADE)
+
+        class Meta:
+            ordering = ['supply__product__parent__isnull']
+
+    # Check if the model passes validation
+    errors = ModelBase._check_ordering(Stock)
+
+    # Print the results
+    if errors:
+        print("Validation failed with errors:")
+        for error in errors:
+            print(f"  - {error}")
+        return False
+    else:
+        print("Validation passed! The fix works.")
+        return True
+
+if __name__ == "__main__":
+    verify_fix()
\ No newline at end of file
diff --git a/verify_fix_simple.py b/verify_fix_simple.py
new file mode 100644
index 0000000000..bc5ee040c1
--- /dev/null
+++ b/verify_fix_simple.py
@@ -0,0 +1,60 @@
+#!/usr/bin/env python
+"""
+This script verifies that the fix for models.E015 works correctly.
+"""
+
+import sys
+from django.db.models.query_utils import RegisterLookupMixin
+from django.db.models.lookups import IsNull, Transform
+
+def verify_fix():
+    """Verify that the fix for models.E015 works correctly."""
+
+    # Create a mock field with a get_transform method
+    class MockField:
+        def __init__(self, lookup_name=None, lookup_class=None):
+            self.lookup_name = lookup_name
+            self.lookup_class = lookup_class
+
+        def get_transform(self, lookup_name):
+            if self.lookup_name and lookup_name == self.lookup_name:
+                return self.lookup_class
+            return None
+
+    # Test cases
+    test_cases = [
+        # (field, part, should_allow)
+        (None, 'isnull', True),  # Lookup should be allowed
+        (None, 'something_else', False),  # Invalid field
+        (MockField('transform', Transform), 'transform', True),  # Valid transform
+        (MockField('transform', Transform), 'not_a_transform', False),  # Invalid transform
+    ]
+
+    # Simulate the fixed code
+    for field, part, should_allow in test_cases:
+        # This is the key part of our fix:
+        # If the part starts with underscore, it's a lookup like __isnull
+        # which should be allowed even if it's not a transform
+        if part.startswith('_'):
+            allow = True
+        else:
+            transform = field.get_transform(part) if field is not None else None
+            allow = field is not None and transform is not None
+
+        # Print debug info
+        print(f"Field part: {part}, Transform: {transform}, Allow: {allow}")
+
+        result = "Allowed" if allow else "Not allowed"
+        expected = "Allowed" if should_allow else "Not allowed"
+
+        print(f"Field part: {part}, Result: {result}, Expected: {expected}")
+
+        if allow != should_allow:
+            print(f"  ERROR: Expected {expected} but got {result}")
+            return False
+
+    print("All tests passed! The fix works.")
+    return True
+
+if __name__ == "__main__":
+    verify_fix()
\ No newline at end of file
