diff --git a/analyze_issue.py b/analyze_issue.py
new file mode 100644
index 0000000000..6aa8cd4320
--- /dev/null
+++ b/analyze_issue.py
@@ -0,0 +1,43 @@
+import os
+import sys
+import django
+from django.conf import settings
+
+# Set up Django
+if not settings.configured:
+    settings.configure(
+        SECRET_KEY='fake-key-for-testing',
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        }
+    )
+    django.setup()
+
+# Import the relevant classes
+from django.forms.widgets import RadioSelect, ChoiceWidget
+from django.forms.models import ModelChoiceField, ModelChoiceIterator
+
+# Analyze the ModelChoiceIterator
+print("ModelChoiceIterator.__iter__ method:")
+print("=" * 50)
+import inspect
+print(inspect.getsource(ModelChoiceIterator.__iter__))
+
+print("\nRadioSelect class:")
+print("=" * 50)
+print(inspect.getsource(RadioSelect))
+
+print("\nChoiceWidget.optgroups method (where blank option is added):")
+print("=" * 50)
+print(inspect.getsource(ChoiceWidget.optgroups))
+
+print("\nModelChoiceField.__init__ method (where empty_label is set):")
+print("=" * 50)
+print(inspect.getsource(ModelChoiceField.__init__))
\ No newline at end of file
diff --git a/django/forms/models.py b/django/forms/models.py
index dafc11f995..56cff05c2b 100644
--- a/django/forms/models.py
+++ b/django/forms/models.py
@@ -1146,7 +1146,8 @@ class ModelChoiceIterator:
         self.queryset = field.queryset
 
     def __iter__(self):
-        if self.field.empty_label is not None:
+        # Only include the empty label if the field is not required or empty_label is explicitly set
+        if self.field.empty_label is not None and (not self.field.required or self.field.empty_label != ModelChoiceField.default_empty_label):
             yield ("", self.field.empty_label)
         queryset = self.queryset
         # Can't use iterator() when queryset uses prefetch_related()
@@ -1180,6 +1181,7 @@ class ModelChoiceField(ChoiceField):
                             ' the available choices.'),
     }
     iterator = ModelChoiceIterator
+    default_empty_label = "---------"
 
     def __init__(self, queryset, *, empty_label="---------",
                  required=True, widget=None, label=None, initial=None,
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..9d63b57a75
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,60 @@
+import os
+import sys
+import django
+from django import forms
+from django.db import models
+from django.conf import settings
+
+# Set up Django
+if not settings.configured:
+    settings.configure(
+        SECRET_KEY='fake-key-for-testing',
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        }
+    )
+    django.setup()
+
+# Add our app to INSTALLED_APPS
+settings.INSTALLED_APPS = list(settings.INSTALLED_APPS) + ['test_app']
+
+# Define models
+class BatchData(models.Model):
+    name = models.CharField(max_length=100)
+    app_label = 'test_app'
+
+    def __str__(self):
+        return self.name
+
+class TestRun(models.Model):
+    data_file = models.ForeignKey(BatchData, on_delete=models.SET_NULL, null=True, blank=False)
+    app_label = 'test_app'
+
+# Create a form with RadioSelect widget
+class TestRunForm(forms.ModelForm):
+    class Meta:
+        model = TestRun
+        fields = ['data_file']
+        widgets = {'data_file': forms.RadioSelect()}
+
+# Create test data
+batch_data = BatchData.objects.create(name="First Data File")
+
+# Create a new form instance
+form = TestRunForm()
+
+# Print the rendered form to see the issue
+print("Form rendered with RadioSelect widget:")
+print(form['data_file'])
+
+# Check if the first option (blank option) is selected
+first_option = form['data_file'].field.choices[0]
+print("\nFirst option (should be blank):", first_option)
+print("Is blank option selected by default?", form['data_file'].initial == "")
\ No newline at end of file
diff --git a/test_radioselect_blank.py b/test_radioselect_blank.py
new file mode 100644
index 0000000000..f227bbfd87
--- /dev/null
+++ b/test_radioselect_blank.py
@@ -0,0 +1,52 @@
+import os
+import sys
+import django
+from django import forms
+from django.db import models
+from django.test import TestCase
+from django.forms.widgets import RadioSelect
+
+# Set up Django
+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'django.conf.global_settings')
+django.setup()
+
+# Define models
+class BatchData(models.Model):
+    name = models.CharField(max_length=100)
+
+    def __str__(self):
+        return self.name
+
+class TestRun(models.Model):
+    data_file = models.ForeignKey(BatchData, on_delete=models.SET_NULL, null=True, blank=False)
+
+# Create a form with RadioSelect widget
+class TestRunForm(forms.ModelForm):
+    class Meta:
+        model = TestRun
+        fields = ['data_file']
+        widgets = {'data_file': RadioSelect()}
+
+class RadioSelectBlankTest(TestCase):
+    def test_radioselect_blank_option(self):
+        # Create test data
+        batch_data = BatchData.objects.create(name="First Data File")
+
+        # Create a new form instance
+        form = TestRunForm()
+
+        # Check if the first option (blank option) is included
+        first_option = form['data_file'].field.choices[0]
+        print("First option:", first_option)
+
+        # Check if the blank option is selected by default
+        is_blank_selected = form['data_file'].initial == ""
+        print("Is blank option selected by default?", is_blank_selected)
+
+        # This is what we want to test - the blank option should not be included
+        # when blank=False on the model field
+        self.assertNotEqual(first_option[0], '', "Blank option should not be included when blank=False")
+
+if __name__ == '__main__':
+    from django.core.management import execute_from_command_line
+    execute_from_command_line(sys.argv)
\ No newline at end of file
