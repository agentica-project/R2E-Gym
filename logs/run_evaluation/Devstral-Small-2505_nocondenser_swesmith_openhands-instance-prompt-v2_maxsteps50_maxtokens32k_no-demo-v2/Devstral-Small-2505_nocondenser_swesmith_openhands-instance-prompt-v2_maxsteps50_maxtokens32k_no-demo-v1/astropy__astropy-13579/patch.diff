diff --git a/astropy/wcs/wcsapi/wrappers/sliced_wcs.py b/astropy/wcs/wcsapi/wrappers/sliced_wcs.py
index d7605b078c..d4ba86aad2 100644
--- a/astropy/wcs/wcsapi/wrappers/sliced_wcs.py
+++ b/astropy/wcs/wcsapi/wrappers/sliced_wcs.py
@@ -246,12 +246,21 @@ class SlicedLowLevelWCS(BaseWCSWrapper):
         world_arrays = tuple(map(np.asanyarray, world_arrays))
         world_arrays_new = []
         iworld_curr = -1
+
+        # First pass: collect values for kept dimensions and determine what values
+        # would be needed for dropped dimensions
         for iworld in range(self._wcs.world_n_dim):
             if iworld in self._world_keep:
                 iworld_curr += 1
-                world_arrays_new.append(world_arrays[iworld_curr])
+                if iworld_curr < len(world_arrays):
+                    world_arrays_new.append(world_arrays[iworld_curr])
+                else:
+                    # If we don't have enough input arrays, use 0.0 as a default
+                    world_arrays_new.append(0.0)
             else:
-                world_arrays_new.append(1.)
+                # For dropped dimensions, use the reference value from the WCS
+                # This is important for coupled dimensions (e.g., through PC matrix)
+                world_arrays_new.append(self._wcs.wcs.crval[iworld])
 
         world_arrays_new = np.broadcast_arrays(*world_arrays_new)
         pixel_arrays = list(self._wcs.world_to_pixel_values(*world_arrays_new))
diff --git a/pyproject.toml b/pyproject.toml
index 7a3b85fc92..83f08ed124 100644
--- a/pyproject.toml
+++ b/pyproject.toml
@@ -1,5 +1,5 @@
 [build-system]
-requires = ["setuptools",
+requires = ["setuptools==68.0.0",
             "setuptools_scm>=6.2",
             "wheel",
             "cython==0.29.30",
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..2554433f2f
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,54 @@
+import numpy as np
+import astropy.wcs
+from astropy.coordinates import SkyCoord
+import astropy.units as u
+from astropy.wcs import wcsapi
+
+# Create the WCS as described in the issue
+nx = 100
+ny = 25
+nz = 2
+wcs_header = {
+    'WCSAXES': 3,
+    'CRPIX1': (nx + 1)/2,
+    'CRPIX2': (ny + 1)/2,
+    'CRPIX3': 1.0,
+    'PC1_1': 0.0,
+    'PC1_2': -1.0,
+    'PC1_3': 0.0,
+    'PC2_1': 1.0,
+    'PC2_2': 0.0,
+    'PC2_3': -1.0,
+    'CDELT1': 5,
+    'CDELT2': 5,
+    'CDELT3': 0.055,
+    'CUNIT1': 'arcsec',
+    'CUNIT2': 'arcsec',
+    'CUNIT3': 'Angstrom',
+    'CTYPE1': 'HPLN-TAN',
+    'CTYPE2': 'HPLT-TAN',
+    'CTYPE3': 'WAVE',
+    'CRVAL1': 0.0,
+    'CRVAL2': 0.0,
+    'CRVAL3': 1.05,
+}
+
+fits_wcs = astropy.wcs.WCS(header=wcs_header)
+
+# Test the full WCS
+world_vals = [0.0, 0.0, 1.05]  # Tx, Ty, wavelength in Angstroms
+result_full = fits_wcs.world_to_pixel_values(*world_vals)
+print("Full WCS world_to_pixel_values result:", result_full)
+
+# Test the sliced WCS
+ll_sliced_wcs = wcsapi.SlicedLowLevelWCS(fits_wcs, 0)
+result_sliced = ll_sliced_wcs.world_to_pixel_values(*world_vals[:2])
+print("Sliced WCS world_to_pixel_values result:", result_sliced)
+
+# Test pixel_to_world for both
+px, py, pz = fits_wcs.world_to_pixel_values(*world_vals)
+result_full_p2w = fits_wcs.pixel_to_world_values(px, py, pz)
+print("Full WCS pixel_to_world_values result:", result_full_p2w)
+
+result_sliced_p2w = ll_sliced_wcs.pixel_to_world_values(px, py)
+print("Sliced WCS pixel_to_world_values result:", result_sliced_p2w)
\ No newline at end of file
